// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: istioinstaller_types.proto

package v1alpha1

import (
	"fmt"
	protobuf "github.com/gogo/protobuf/types"
	"github.com/golang/protobuf/proto"
	"io"
	v11 "k8s.io/api/autoscaling/v1"
	"k8s.io/api/core/v1"
	v12 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Default behavior of the sidecar for handling outbound traffic from the application.
type PolicyTelemetryConfig_OutboundPolicy int32

const (
	// Outbound traffic to unknown destinations will be allowed, in case there are no
	// services or ServiceEntries for the destination port
	PolicyTelemetryConfig_ALLOW_ANY PolicyTelemetryConfig_OutboundPolicy = 0
	// Restrict outbound traffic to services defined in the service registry as well
	// as those defined through ServiceEntries
	PolicyTelemetryConfig_REGISTRY_ONLY PolicyTelemetryConfig_OutboundPolicy = 1
)

var PolicyTelemetryConfig_OutboundPolicy_name = map[int32]string{
	0: "ALLOW_ANY",
	1: "REGISTRY_ONLY",
}

var PolicyTelemetryConfig_OutboundPolicy_value = map[string]int32{
	"ALLOW_ANY":     0,
	"REGISTRY_ONLY": 1,
}

func (x PolicyTelemetryConfig_OutboundPolicy) String() string {
	return proto.EnumName(PolicyTelemetryConfig_OutboundPolicy_name, int32(x))
}

func (PolicyTelemetryConfig_OutboundPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{3, 0}
}

// LogLevel sets the component log level. Mappings to underlying log levels are not necessarily 1:1 and depend on
// component support of these levels e.g. DEBUG or INFO may result in the same log verbosity.
type CommonComponentConfig_LogLevel int32

const (
	CommonComponentConfig_NONE  CommonComponentConfig_LogLevel = 0
	CommonComponentConfig_ERROR CommonComponentConfig_LogLevel = 1
	CommonComponentConfig_WARN  CommonComponentConfig_LogLevel = 2
	CommonComponentConfig_DEBUG CommonComponentConfig_LogLevel = 3
	CommonComponentConfig_INFO  CommonComponentConfig_LogLevel = 4
)

var CommonComponentConfig_LogLevel_name = map[int32]string{
	0: "NONE",
	1: "ERROR",
	2: "WARN",
	3: "DEBUG",
	4: "INFO",
}

var CommonComponentConfig_LogLevel_value = map[string]int32{
	"NONE":  0,
	"ERROR": 1,
	"WARN":  2,
	"DEBUG": 3,
	"INFO":  4,
}

func (x CommonComponentConfig_LogLevel) String() string {
	return proto.EnumName(CommonComponentConfig_LogLevel_name, int32(x))
}

func (CommonComponentConfig_LogLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{14, 0}
}

// Selects the type of ingress.
// Ingress type.
type IngressGatewayConfig_IngressType int32

const (
	IngressGatewayConfig_ISTIO      IngressGatewayConfig_IngressType = 0
	IngressGatewayConfig_KUBERNETES IngressGatewayConfig_IngressType = 1
)

var IngressGatewayConfig_IngressType_name = map[int32]string{
	0: "ISTIO",
	1: "KUBERNETES",
}

var IngressGatewayConfig_IngressType_value = map[string]int32{
	"ISTIO":      0,
	"KUBERNETES": 1,
}

func (x IngressGatewayConfig_IngressType) String() string {
	return proto.EnumName(IngressGatewayConfig_IngressType_name, int32(x))
}

func (IngressGatewayConfig_IngressType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{16, 0}
}

// change to Local to preserve source IP or Cluster for default behaviour or leave commented out
// ???
// External traffic policy.
type IngressGatewayConfig_ExternalTrafficPolicy int32

const (
	IngressGatewayConfig_NONE IngressGatewayConfig_ExternalTrafficPolicy = 0
	// Preserves source IP.
	IngressGatewayConfig_LOCAL   IngressGatewayConfig_ExternalTrafficPolicy = 1
	IngressGatewayConfig_CLUSTER IngressGatewayConfig_ExternalTrafficPolicy = 2
)

var IngressGatewayConfig_ExternalTrafficPolicy_name = map[int32]string{
	0: "NONE",
	1: "LOCAL",
	2: "CLUSTER",
}

var IngressGatewayConfig_ExternalTrafficPolicy_value = map[string]int32{
	"NONE":    0,
	"LOCAL":   1,
	"CLUSTER": 2,
}

func (x IngressGatewayConfig_ExternalTrafficPolicy) String() string {
	return proto.EnumName(IngressGatewayConfig_ExternalTrafficPolicy_name, int32(x))
}

func (IngressGatewayConfig_ExternalTrafficPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{16, 1}
}

type K8SObjectOverlay_PatchType int32

const (
	K8SObjectOverlay_STRATEGIC K8SObjectOverlay_PatchType = 0
	K8SObjectOverlay_JSON      K8SObjectOverlay_PatchType = 1
)

var K8SObjectOverlay_PatchType_name = map[int32]string{
	0: "STRATEGIC",
	1: "JSON",
}

var K8SObjectOverlay_PatchType_value = map[string]int32{
	"STRATEGIC": 0,
	"JSON":      1,
}

func (x K8SObjectOverlay_PatchType) String() string {
	return proto.EnumName(K8SObjectOverlay_PatchType_name, int32(x))
}

func (K8SObjectOverlay_PatchType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{21, 0}
}

type K8SObjectOverlay_Op int32

const (
	K8SObjectOverlay_ADD     K8SObjectOverlay_Op = 0
	K8SObjectOverlay_REMOVE  K8SObjectOverlay_Op = 1
	K8SObjectOverlay_REPLACE K8SObjectOverlay_Op = 2
	K8SObjectOverlay_MERGE   K8SObjectOverlay_Op = 3
)

var K8SObjectOverlay_Op_name = map[int32]string{
	0: "ADD",
	1: "REMOVE",
	2: "REPLACE",
	3: "MERGE",
}

var K8SObjectOverlay_Op_value = map[string]int32{
	"ADD":     0,
	"REMOVE":  1,
	"REPLACE": 2,
	"MERGE":   3,
}

func (x K8SObjectOverlay_Op) String() string {
	return proto.EnumName(K8SObjectOverlay_Op_name, int32(x))
}

func (K8SObjectOverlay_Op) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{21, 1}
}

type InstallerStatus_Status int32

const (
	InstallerStatus_NONE     InstallerStatus_Status = 0
	InstallerStatus_UPDATING InstallerStatus_Status = 1
	InstallerStatus_HEALTHY  InstallerStatus_Status = 2
	InstallerStatus_ERROR    InstallerStatus_Status = 3
)

var InstallerStatus_Status_name = map[int32]string{
	0: "NONE",
	1: "UPDATING",
	2: "HEALTHY",
	3: "ERROR",
}

var InstallerStatus_Status_value = map[string]int32{
	"NONE":     0,
	"UPDATING": 1,
	"HEALTHY":  2,
	"ERROR":    3,
}

func (x InstallerStatus_Status) String() string {
	return proto.EnumName(InstallerStatus_Status_name, int32(x))
}

func (InstallerStatus_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{22, 0}
}

type IstioInstaller struct {
	Spec                 *InstallerSpec   `protobuf:"bytes,3,opt,name=spec,proto3" json:"spec,omitempty"`
	Status               *InstallerStatus `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *IstioInstaller) Reset()         { *m = IstioInstaller{} }
func (m *IstioInstaller) String() string { return proto.CompactTextString(m) }
func (*IstioInstaller) ProtoMessage()    {}
func (*IstioInstaller) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{0}
}
func (m *IstioInstaller) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IstioInstaller) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IstioInstaller.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IstioInstaller) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IstioInstaller.Merge(m, src)
}
func (m *IstioInstaller) XXX_Size() int {
	return m.Size()
}
func (m *IstioInstaller) XXX_DiscardUnknown() {
	xxx_messageInfo_IstioInstaller.DiscardUnknown(m)
}

var xxx_messageInfo_IstioInstaller proto.InternalMessageInfo

func (m *IstioInstaller) GetSpec() *InstallerSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *IstioInstaller) GetStatus() *InstallerStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// InstallerSpec defines the desired state of IstioInstaller.
type InstallerSpec struct {
	// URL for the install package. e.g.
	//   http://github.com/istio/istio/releases/install/1.1.2
	//   http://github.com/istio/istio/releases/install/lts
	//   file://tmp/istio-installer/nightly
	// Uses compiled in install package by default.
	InstallPackagePath string `protobuf:"bytes,1,opt,name=install_package_path,json=installPackagePath,proto3" json:"install_package_path,omitempty"`
	// Root for docker image paths e.g. docker.io/istio-release.
	// Releases are published to docker hub under 'istio' project.
	//  Daily builds from prow are on gcr.io, and nightly builds from circle on docker.io/istionightly
	Hub string `protobuf:"bytes,3,opt,name=hub,proto3" json:"hub,omitempty"`
	// Version tag for docker images e.g. 1.0.6
	Tag string `protobuf:"bytes,4,opt,name=tag,proto3" json:"tag,omitempty"`
	// Prefix added to all namespaces for any installed component.
	DefaultNamespacePrefix string `protobuf:"bytes,5,opt,name=default_namespace_prefix,json=defaultNamespacePrefix,proto3" json:"default_namespace_prefix,omitempty"`
	// Selection and configuration of core Istio features.
	TrafficManagement *TrafficManagementConfig `protobuf:"bytes,25,opt,name=traffic_management,json=trafficManagement,proto3" json:"traffic_management,omitempty"`
	PolicyTelemetry   *PolicyTelemetryConfig   `protobuf:"bytes,26,opt,name=policy_telemetry,json=policyTelemetry,proto3" json:"policy_telemetry,omitempty"`
	Security          *SecurityConfig          `protobuf:"bytes,28,opt,name=security,proto3" json:"security,omitempty"`
	ConfigManagement  *ConfigManagementConfig  `protobuf:"bytes,29,opt,name=config_management,json=configManagement,proto3" json:"config_management,omitempty"`
	// Ingress/egress gateway installation and configuration.
	IngressGateway []*IngressGatewayConfig `protobuf:"bytes,30,rep,name=ingress_gateway,json=ingressGateway,proto3" json:"ingress_gateway,omitempty"`
	EgressGateway  []*EgressGatewayConfig  `protobuf:"bytes,31,rep,name=egress_gateway,json=egressGateway,proto3" json:"egress_gateway,omitempty"`
	// List of external operators that will be installed (but not managed)
	// by the IstioInstaller e.g. prometheus, grafana, kiali.
	ExternalOperators []*OperatorConfig `protobuf:"bytes,50,rep,name=external_operators,json=externalOperators,proto3" json:"external_operators,omitempty"`
	// Global k8s defaults. Can be overridden per component.
	K8SDefaults          *KubernetesResourcesConfig `protobuf:"bytes,80,opt,name=k8s_defaults,json=k8sDefaults,proto3" json:"k8s_defaults,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *InstallerSpec) Reset()         { *m = InstallerSpec{} }
func (m *InstallerSpec) String() string { return proto.CompactTextString(m) }
func (*InstallerSpec) ProtoMessage()    {}
func (*InstallerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{1}
}
func (m *InstallerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstallerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstallerSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstallerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallerSpec.Merge(m, src)
}
func (m *InstallerSpec) XXX_Size() int {
	return m.Size()
}
func (m *InstallerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_InstallerSpec proto.InternalMessageInfo

func (m *InstallerSpec) GetInstallPackagePath() string {
	if m != nil {
		return m.InstallPackagePath
	}
	return ""
}

func (m *InstallerSpec) GetHub() string {
	if m != nil {
		return m.Hub
	}
	return ""
}

func (m *InstallerSpec) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

func (m *InstallerSpec) GetDefaultNamespacePrefix() string {
	if m != nil {
		return m.DefaultNamespacePrefix
	}
	return ""
}

func (m *InstallerSpec) GetTrafficManagement() *TrafficManagementConfig {
	if m != nil {
		return m.TrafficManagement
	}
	return nil
}

func (m *InstallerSpec) GetPolicyTelemetry() *PolicyTelemetryConfig {
	if m != nil {
		return m.PolicyTelemetry
	}
	return nil
}

func (m *InstallerSpec) GetSecurity() *SecurityConfig {
	if m != nil {
		return m.Security
	}
	return nil
}

func (m *InstallerSpec) GetConfigManagement() *ConfigManagementConfig {
	if m != nil {
		return m.ConfigManagement
	}
	return nil
}

func (m *InstallerSpec) GetIngressGateway() []*IngressGatewayConfig {
	if m != nil {
		return m.IngressGateway
	}
	return nil
}

func (m *InstallerSpec) GetEgressGateway() []*EgressGatewayConfig {
	if m != nil {
		return m.EgressGateway
	}
	return nil
}

func (m *InstallerSpec) GetExternalOperators() []*OperatorConfig {
	if m != nil {
		return m.ExternalOperators
	}
	return nil
}

func (m *InstallerSpec) GetK8SDefaults() *KubernetesResourcesConfig {
	if m != nil {
		return m.K8SDefaults
	}
	return nil
}

// Configuration options for traffic management.
type TrafficManagementConfig struct {
	// Selects whether traffic management is installed.
	// Must be enabled to enable any sub-component.
	Enabled *protobuf.BoolValue `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Namespace that all traffic management components are installed into.
	Namespace     string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	ClusterDomain string `protobuf:"bytes,24,opt,name=cluster_domain,json=clusterDomain,proto3" json:"cluster_domain,omitempty"`
	// Component specific config.
	Pilot                *PilotComponentConfig           `protobuf:"bytes,30,opt,name=pilot,proto3" json:"pilot,omitempty"`
	Proxy                *ProxyComponentConfig           `protobuf:"bytes,31,opt,name=proxy,proto3" json:"proxy,omitempty"`
	SidecarInjector      *SidecarInjectorComponentConfig `protobuf:"bytes,32,opt,name=sidecar_injector,json=sidecarInjector,proto3" json:"sidecar_injector,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *TrafficManagementConfig) Reset()         { *m = TrafficManagementConfig{} }
func (m *TrafficManagementConfig) String() string { return proto.CompactTextString(m) }
func (*TrafficManagementConfig) ProtoMessage()    {}
func (*TrafficManagementConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{2}
}
func (m *TrafficManagementConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrafficManagementConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrafficManagementConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrafficManagementConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrafficManagementConfig.Merge(m, src)
}
func (m *TrafficManagementConfig) XXX_Size() int {
	return m.Size()
}
func (m *TrafficManagementConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TrafficManagementConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TrafficManagementConfig proto.InternalMessageInfo

func (m *TrafficManagementConfig) GetEnabled() *protobuf.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *TrafficManagementConfig) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *TrafficManagementConfig) GetClusterDomain() string {
	if m != nil {
		return m.ClusterDomain
	}
	return ""
}

func (m *TrafficManagementConfig) GetPilot() *PilotComponentConfig {
	if m != nil {
		return m.Pilot
	}
	return nil
}

func (m *TrafficManagementConfig) GetProxy() *ProxyComponentConfig {
	if m != nil {
		return m.Proxy
	}
	return nil
}

func (m *TrafficManagementConfig) GetSidecarInjector() *SidecarInjectorComponentConfig {
	if m != nil {
		return m.SidecarInjector
	}
	return nil
}

// Configuration options for the policy and telemetry feature.
type PolicyTelemetryConfig struct {
	// If set, allows traffic in cases when the mixer policy service cannot be reached.
	PolicyCheckFailOpen *protobuf.BoolValue `protobuf:"bytes,10,opt,name=policy_check_fail_open,json=policyCheckFailOpen,proto3" json:"policy_check_fail_open,omitempty"`
	// Selects the outbound traffic policy mode.
	OutboundTrafficPolicyMode PolicyTelemetryConfig_OutboundPolicy `protobuf:"varint,11,opt,name=outbound_traffic_policy_mode,json=outboundTrafficPolicyMode,proto3,enum=v1alpha1.PolicyTelemetryConfig_OutboundPolicy" json:"outbound_traffic_policy_mode,omitempty"`
	Policy                    *PolicyComponentConfig               `protobuf:"bytes,50,opt,name=policy,proto3" json:"policy,omitempty"`
	Telemetry                 *TelemetryComponentConfig            `protobuf:"bytes,51,opt,name=telemetry,proto3" json:"telemetry,omitempty"`
	XXX_NoUnkeyedLiteral      struct{}                             `json:"-"`
	XXX_unrecognized          []byte                               `json:"-"`
	XXX_sizecache             int32                                `json:"-"`
}

func (m *PolicyTelemetryConfig) Reset()         { *m = PolicyTelemetryConfig{} }
func (m *PolicyTelemetryConfig) String() string { return proto.CompactTextString(m) }
func (*PolicyTelemetryConfig) ProtoMessage()    {}
func (*PolicyTelemetryConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{3}
}
func (m *PolicyTelemetryConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicyTelemetryConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PolicyTelemetryConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PolicyTelemetryConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyTelemetryConfig.Merge(m, src)
}
func (m *PolicyTelemetryConfig) XXX_Size() int {
	return m.Size()
}
func (m *PolicyTelemetryConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyTelemetryConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyTelemetryConfig proto.InternalMessageInfo

func (m *PolicyTelemetryConfig) GetPolicyCheckFailOpen() *protobuf.BoolValue {
	if m != nil {
		return m.PolicyCheckFailOpen
	}
	return nil
}

func (m *PolicyTelemetryConfig) GetOutboundTrafficPolicyMode() PolicyTelemetryConfig_OutboundPolicy {
	if m != nil {
		return m.OutboundTrafficPolicyMode
	}
	return PolicyTelemetryConfig_ALLOW_ANY
}

func (m *PolicyTelemetryConfig) GetPolicy() *PolicyComponentConfig {
	if m != nil {
		return m.Policy
	}
	return nil
}

func (m *PolicyTelemetryConfig) GetTelemetry() *TelemetryComponentConfig {
	if m != nil {
		return m.Telemetry
	}
	return nil
}

// Configuration options for security feature.
type SecurityConfig struct {
	// Selects whether security feature is installed. Must be set for any sub-component to be installed.
	Enabled *protobuf.BoolValue `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Namespace that security components are installed into.
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Enables MTLS for control plane.
	// Will result in delays starting the pods while secrets are propagated, not recommended for tests.
	ControlPlaneMtls *protobuf.BoolValue `protobuf:"bytes,13,opt,name=control_plane_mtls,json=controlPlaneMtls,proto3" json:"control_plane_mtls,omitempty"`
	// Enables MTLS for service to service traffic.
	DataPlaneMtls        *protobuf.BoolValue         `protobuf:"bytes,14,opt,name=data_plane_mtls,json=dataPlaneMtls,proto3" json:"data_plane_mtls,omitempty"`
	TrustDomain          string                      `protobuf:"bytes,15,opt,name=trust_domain,json=trustDomain,proto3" json:"trust_domain,omitempty"`
	SelfSigned           *protobuf.BoolValue         `protobuf:"bytes,16,opt,name=self_signed,json=selfSigned,proto3" json:"self_signed,omitempty"`
	CreateMeshPolicy     *protobuf.BoolValue         `protobuf:"bytes,17,opt,name=create_mesh_policy,json=createMeshPolicy,proto3" json:"create_mesh_policy,omitempty"`
	Citadel              *CitadelComponentConfig     `protobuf:"bytes,20,opt,name=citadel,proto3" json:"citadel,omitempty"`
	CertManager          *CertManagerComponentConfig `protobuf:"bytes,21,opt,name=cert_manager,json=certManager,proto3" json:"cert_manager,omitempty"`
	NodeAgent            *NodeAgentComponentConfig   `protobuf:"bytes,22,opt,name=node_agent,json=nodeAgent,proto3" json:"node_agent,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *SecurityConfig) Reset()         { *m = SecurityConfig{} }
func (m *SecurityConfig) String() string { return proto.CompactTextString(m) }
func (*SecurityConfig) ProtoMessage()    {}
func (*SecurityConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{4}
}
func (m *SecurityConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityConfig.Merge(m, src)
}
func (m *SecurityConfig) XXX_Size() int {
	return m.Size()
}
func (m *SecurityConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityConfig proto.InternalMessageInfo

func (m *SecurityConfig) GetEnabled() *protobuf.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *SecurityConfig) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *SecurityConfig) GetControlPlaneMtls() *protobuf.BoolValue {
	if m != nil {
		return m.ControlPlaneMtls
	}
	return nil
}

func (m *SecurityConfig) GetDataPlaneMtls() *protobuf.BoolValue {
	if m != nil {
		return m.DataPlaneMtls
	}
	return nil
}

func (m *SecurityConfig) GetTrustDomain() string {
	if m != nil {
		return m.TrustDomain
	}
	return ""
}

func (m *SecurityConfig) GetSelfSigned() *protobuf.BoolValue {
	if m != nil {
		return m.SelfSigned
	}
	return nil
}

func (m *SecurityConfig) GetCreateMeshPolicy() *protobuf.BoolValue {
	if m != nil {
		return m.CreateMeshPolicy
	}
	return nil
}

func (m *SecurityConfig) GetCitadel() *CitadelComponentConfig {
	if m != nil {
		return m.Citadel
	}
	return nil
}

func (m *SecurityConfig) GetCertManager() *CertManagerComponentConfig {
	if m != nil {
		return m.CertManager
	}
	return nil
}

func (m *SecurityConfig) GetNodeAgent() *NodeAgentComponentConfig {
	if m != nil {
		return m.NodeAgent
	}
	return nil
}

// Configuration options for the pilot component.
type PilotComponentConfig struct {
	Common *CommonComponentConfig `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	// Enables sidecar in the pilot pod.
	Sidecar              *protobuf.BoolValue `protobuf:"bytes,10,opt,name=sidecar,proto3" json:"sidecar,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *PilotComponentConfig) Reset()         { *m = PilotComponentConfig{} }
func (m *PilotComponentConfig) String() string { return proto.CompactTextString(m) }
func (*PilotComponentConfig) ProtoMessage()    {}
func (*PilotComponentConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{5}
}
func (m *PilotComponentConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PilotComponentConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PilotComponentConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PilotComponentConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PilotComponentConfig.Merge(m, src)
}
func (m *PilotComponentConfig) XXX_Size() int {
	return m.Size()
}
func (m *PilotComponentConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PilotComponentConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PilotComponentConfig proto.InternalMessageInfo

func (m *PilotComponentConfig) GetCommon() *CommonComponentConfig {
	if m != nil {
		return m.Common
	}
	return nil
}

func (m *PilotComponentConfig) GetSidecar() *protobuf.BoolValue {
	if m != nil {
		return m.Sidecar
	}
	return nil
}

// Configuration options for the proxy.
type ProxyComponentConfig struct {
	Common               *CommonComponentConfig `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *ProxyComponentConfig) Reset()         { *m = ProxyComponentConfig{} }
func (m *ProxyComponentConfig) String() string { return proto.CompactTextString(m) }
func (*ProxyComponentConfig) ProtoMessage()    {}
func (*ProxyComponentConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{6}
}
func (m *ProxyComponentConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProxyComponentConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProxyComponentConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProxyComponentConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProxyComponentConfig.Merge(m, src)
}
func (m *ProxyComponentConfig) XXX_Size() int {
	return m.Size()
}
func (m *ProxyComponentConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ProxyComponentConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ProxyComponentConfig proto.InternalMessageInfo

func (m *ProxyComponentConfig) GetCommon() *CommonComponentConfig {
	if m != nil {
		return m.Common
	}
	return nil
}

// Configuration options for the sidecar injector component.
type SidecarInjectorComponentConfig struct {
	Common *CommonComponentConfig `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	// Selects whether auto-injection is enabled in namespaces by default.
	EnableNamespacesByDefault *protobuf.BoolValue `protobuf:"bytes,10,opt,name=enable_namespaces_by_default,json=enableNamespacesByDefault,proto3" json:"enable_namespaces_by_default,omitempty"`
	XXX_NoUnkeyedLiteral      struct{}            `json:"-"`
	XXX_unrecognized          []byte              `json:"-"`
	XXX_sizecache             int32               `json:"-"`
}

func (m *SidecarInjectorComponentConfig) Reset()         { *m = SidecarInjectorComponentConfig{} }
func (m *SidecarInjectorComponentConfig) String() string { return proto.CompactTextString(m) }
func (*SidecarInjectorComponentConfig) ProtoMessage()    {}
func (*SidecarInjectorComponentConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{7}
}
func (m *SidecarInjectorComponentConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SidecarInjectorComponentConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SidecarInjectorComponentConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SidecarInjectorComponentConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SidecarInjectorComponentConfig.Merge(m, src)
}
func (m *SidecarInjectorComponentConfig) XXX_Size() int {
	return m.Size()
}
func (m *SidecarInjectorComponentConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SidecarInjectorComponentConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SidecarInjectorComponentConfig proto.InternalMessageInfo

func (m *SidecarInjectorComponentConfig) GetCommon() *CommonComponentConfig {
	if m != nil {
		return m.Common
	}
	return nil
}

func (m *SidecarInjectorComponentConfig) GetEnableNamespacesByDefault() *protobuf.BoolValue {
	if m != nil {
		return m.EnableNamespacesByDefault
	}
	return nil
}

// Configuration options for the policy enforcement component.
type PolicyComponentConfig struct {
	Common               *CommonComponentConfig `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *PolicyComponentConfig) Reset()         { *m = PolicyComponentConfig{} }
func (m *PolicyComponentConfig) String() string { return proto.CompactTextString(m) }
func (*PolicyComponentConfig) ProtoMessage()    {}
func (*PolicyComponentConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{8}
}
func (m *PolicyComponentConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicyComponentConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PolicyComponentConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PolicyComponentConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyComponentConfig.Merge(m, src)
}
func (m *PolicyComponentConfig) XXX_Size() int {
	return m.Size()
}
func (m *PolicyComponentConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyComponentConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyComponentConfig proto.InternalMessageInfo

func (m *PolicyComponentConfig) GetCommon() *CommonComponentConfig {
	if m != nil {
		return m.Common
	}
	return nil
}

// Configuration options for the telemetry component.
type TelemetryComponentConfig struct {
	Common               *CommonComponentConfig `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *TelemetryComponentConfig) Reset()         { *m = TelemetryComponentConfig{} }
func (m *TelemetryComponentConfig) String() string { return proto.CompactTextString(m) }
func (*TelemetryComponentConfig) ProtoMessage()    {}
func (*TelemetryComponentConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{9}
}
func (m *TelemetryComponentConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TelemetryComponentConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TelemetryComponentConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TelemetryComponentConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TelemetryComponentConfig.Merge(m, src)
}
func (m *TelemetryComponentConfig) XXX_Size() int {
	return m.Size()
}
func (m *TelemetryComponentConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TelemetryComponentConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TelemetryComponentConfig proto.InternalMessageInfo

func (m *TelemetryComponentConfig) GetCommon() *CommonComponentConfig {
	if m != nil {
		return m.Common
	}
	return nil
}

// Configuration options for Citadel component.
type CitadelComponentConfig struct {
	Common               *CommonComponentConfig `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *CitadelComponentConfig) Reset()         { *m = CitadelComponentConfig{} }
func (m *CitadelComponentConfig) String() string { return proto.CompactTextString(m) }
func (*CitadelComponentConfig) ProtoMessage()    {}
func (*CitadelComponentConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{10}
}
func (m *CitadelComponentConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CitadelComponentConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CitadelComponentConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CitadelComponentConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CitadelComponentConfig.Merge(m, src)
}
func (m *CitadelComponentConfig) XXX_Size() int {
	return m.Size()
}
func (m *CitadelComponentConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CitadelComponentConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CitadelComponentConfig proto.InternalMessageInfo

func (m *CitadelComponentConfig) GetCommon() *CommonComponentConfig {
	if m != nil {
		return m.Common
	}
	return nil
}

// Configuration options for certificate manager component.
type CertManagerComponentConfig struct {
	Common               *CommonComponentConfig `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *CertManagerComponentConfig) Reset()         { *m = CertManagerComponentConfig{} }
func (m *CertManagerComponentConfig) String() string { return proto.CompactTextString(m) }
func (*CertManagerComponentConfig) ProtoMessage()    {}
func (*CertManagerComponentConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{11}
}
func (m *CertManagerComponentConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertManagerComponentConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CertManagerComponentConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CertManagerComponentConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertManagerComponentConfig.Merge(m, src)
}
func (m *CertManagerComponentConfig) XXX_Size() int {
	return m.Size()
}
func (m *CertManagerComponentConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CertManagerComponentConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CertManagerComponentConfig proto.InternalMessageInfo

func (m *CertManagerComponentConfig) GetCommon() *CommonComponentConfig {
	if m != nil {
		return m.Common
	}
	return nil
}

// Configuration options for node agent component.
type NodeAgentComponentConfig struct {
	Common               *CommonComponentConfig `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *NodeAgentComponentConfig) Reset()         { *m = NodeAgentComponentConfig{} }
func (m *NodeAgentComponentConfig) String() string { return proto.CompactTextString(m) }
func (*NodeAgentComponentConfig) ProtoMessage()    {}
func (*NodeAgentComponentConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{12}
}
func (m *NodeAgentComponentConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeAgentComponentConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeAgentComponentConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeAgentComponentConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeAgentComponentConfig.Merge(m, src)
}
func (m *NodeAgentComponentConfig) XXX_Size() int {
	return m.Size()
}
func (m *NodeAgentComponentConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeAgentComponentConfig.DiscardUnknown(m)
}

var xxx_messageInfo_NodeAgentComponentConfig proto.InternalMessageInfo

func (m *NodeAgentComponentConfig) GetCommon() *CommonComponentConfig {
	if m != nil {
		return m.Common
	}
	return nil
}

// Configuration options for configuration management feature.
type ConfigManagementConfig struct {
	Common               *CommonComponentConfig `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *ConfigManagementConfig) Reset()         { *m = ConfigManagementConfig{} }
func (m *ConfigManagementConfig) String() string { return proto.CompactTextString(m) }
func (*ConfigManagementConfig) ProtoMessage()    {}
func (*ConfigManagementConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{13}
}
func (m *ConfigManagementConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigManagementConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigManagementConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigManagementConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigManagementConfig.Merge(m, src)
}
func (m *ConfigManagementConfig) XXX_Size() int {
	return m.Size()
}
func (m *ConfigManagementConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigManagementConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigManagementConfig proto.InternalMessageInfo

func (m *ConfigManagementConfig) GetCommon() *CommonComponentConfig {
	if m != nil {
		return m.Common
	}
	return nil
}

// Configuration common to all components.
type CommonComponentConfig struct {
	// Selects whether policy enforcement is installed.
	// Q. is this enough to cover both mixer.policy.enabled and disablePolicyChecks?
	Enabled *protobuf.BoolValue `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Namespace that all resources for this feature are installed into.
	Namespace string                         `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Debug     CommonComponentConfig_LogLevel `protobuf:"varint,3,opt,name=debug,proto3,enum=v1alpha1.CommonComponentConfig_LogLevel" json:"debug,omitempty"`
	// Additional environment variables for the container.
	Env map[string]string `protobuf:"bytes,60,rep,name=env,proto3" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Additional command line arguments for the container.
	Args map[string]string `protobuf:"bytes,61,rep,name=args,proto3" json:"args,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Kubernetes resource spec.
	K8S                  *KubernetesResourcesConfig `protobuf:"bytes,80,opt,name=k8s,proto3" json:"k8s,omitempty"`
	ValuesOverrides      map[string]interface{}     `protobuf:"bytes,6,opt,name=data" json:"valuesOverrides,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *CommonComponentConfig) Reset()         { *m = CommonComponentConfig{} }
func (m *CommonComponentConfig) String() string { return proto.CompactTextString(m) }
func (*CommonComponentConfig) ProtoMessage()    {}
func (*CommonComponentConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{14}
}
func (m *CommonComponentConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommonComponentConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommonComponentConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommonComponentConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommonComponentConfig.Merge(m, src)
}
func (m *CommonComponentConfig) XXX_Size() int {
	return m.Size()
}
func (m *CommonComponentConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CommonComponentConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CommonComponentConfig proto.InternalMessageInfo

func (m *CommonComponentConfig) GetEnabled() *protobuf.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *CommonComponentConfig) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *CommonComponentConfig) GetDebug() CommonComponentConfig_LogLevel {
	if m != nil {
		return m.Debug
	}
	return CommonComponentConfig_NONE
}

func (m *CommonComponentConfig) GetEnv() map[string]string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *CommonComponentConfig) GetArgs() map[string]string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *CommonComponentConfig) GetK8S() *KubernetesResourcesConfig {
	if m != nil {
		return m.K8S
	}
	return nil
}

// KubernetesResourcesConfig is a common set of k8s resource configs for components.
type KubernetesResourcesConfig struct {
	// k8s resources settings.
	// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#resource-requests-and-limits-of-pod-and-container
	Resources *Resources `protobuf:"bytes,1,opt,name=resources,proto3" json:"resources,omitempty"`
	// k8s readinessProbe settings.
	// https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/
	ReadinessProbe *v1.Probe `protobuf:"bytes,2,opt,name=readiness_probe,json=readinessProbe,proto3" json:"readiness_probe,omitempty"`
	// k8s Deployment replicas setting.
	// https://kubernetes.io/docs/concepts/workloads/controllers/deployment/
	ReplicaCount uint32 `protobuf:"varint,3,opt,name=replica_count,json=replicaCount,proto3" json:"replica_count,omitempty"`
	// k8s HorizontalPodAutoscaler settings.
	// https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/
	HpaSpec *v11.HorizontalPodAutoscalerSpec `protobuf:"bytes,4,opt,name=hpa_spec,json=hpaSpec,proto3" json:"hpa_spec,omitempty"`
	// k8s PodDisruptionBudget settings.
	// https://kubernetes.io/docs/concepts/workloads/pods/disruptions/#how-disruption-budgets-work
	PodDisruptionBudget *PodDisruptionBudgetSpec `protobuf:"bytes,5,opt,name=pod_disruption_budget,json=podDisruptionBudget,proto3" json:"pod_disruption_budget,omitempty"`
	// k8s pod annotations.
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
	PodAnnotations map[string]string `protobuf:"bytes,6,rep,name=pod_annotations,json=podAnnotations,proto3" json:"pod_annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// k8s nodeSelector.
	// https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
	NodeSelector map[string]string                       `protobuf:"bytes,7,rep,name=node_selector,json=nodeSelector,proto3" json:"node_selector,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	NodeAffinity *KubernetesResourcesConfig_NodeAffinity `protobuf:"bytes,8,opt,name=node_affinity,json=nodeAffinity,proto3" json:"node_affinity,omitempty"`
	// k8s imagePullPolicy.
	// https://kubernetes.io/docs/concepts/containers/images/
	ImagePullPolicy string `protobuf:"bytes,9,opt,name=image_pull_policy,json=imagePullPolicy,proto3" json:"image_pull_policy,omitempty"`
	// k8s priority_class_name. Default for all resources unless overridden.
	// https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass
	PriorityClassName string `protobuf:"bytes,10,opt,name=priority_class_name,json=priorityClassName,proto3" json:"priority_class_name,omitempty"`
	// Kustomize style overrides for k8s resources in rendered manifests.
	Overlays             []*K8SObjectOverlay `protobuf:"bytes,100,rep,name=overlays,proto3" json:"overlays,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *KubernetesResourcesConfig) Reset()         { *m = KubernetesResourcesConfig{} }
func (m *KubernetesResourcesConfig) String() string { return proto.CompactTextString(m) }
func (*KubernetesResourcesConfig) ProtoMessage()    {}
func (*KubernetesResourcesConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{15}
}
func (m *KubernetesResourcesConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubernetesResourcesConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubernetesResourcesConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubernetesResourcesConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesResourcesConfig.Merge(m, src)
}
func (m *KubernetesResourcesConfig) XXX_Size() int {
	return m.Size()
}
func (m *KubernetesResourcesConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesResourcesConfig.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesResourcesConfig proto.InternalMessageInfo

func (m *KubernetesResourcesConfig) GetResources() *Resources {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *KubernetesResourcesConfig) GetReadinessProbe() *v1.Probe {
	if m != nil {
		return m.ReadinessProbe
	}
	return nil
}

func (m *KubernetesResourcesConfig) GetReplicaCount() uint32 {
	if m != nil {
		return m.ReplicaCount
	}
	return 0
}

func (m *KubernetesResourcesConfig) GetHpaSpec() *v11.HorizontalPodAutoscalerSpec {
	if m != nil {
		return m.HpaSpec
	}
	return nil
}

func (m *KubernetesResourcesConfig) GetPodDisruptionBudget() *PodDisruptionBudgetSpec {
	if m != nil {
		return m.PodDisruptionBudget
	}
	return nil
}

func (m *KubernetesResourcesConfig) GetPodAnnotations() map[string]string {
	if m != nil {
		return m.PodAnnotations
	}
	return nil
}

func (m *KubernetesResourcesConfig) GetNodeSelector() map[string]string {
	if m != nil {
		return m.NodeSelector
	}
	return nil
}

func (m *KubernetesResourcesConfig) GetNodeAffinity() *KubernetesResourcesConfig_NodeAffinity {
	if m != nil {
		return m.NodeAffinity
	}
	return nil
}

func (m *KubernetesResourcesConfig) GetImagePullPolicy() string {
	if m != nil {
		return m.ImagePullPolicy
	}
	return ""
}

func (m *KubernetesResourcesConfig) GetPriorityClassName() string {
	if m != nil {
		return m.PriorityClassName
	}
	return ""
}

func (m *KubernetesResourcesConfig) GetOverlays() []*K8SObjectOverlay {
	if m != nil {
		return m.Overlays
	}
	return nil
}

// k8s node affinity.
// https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
type KubernetesResourcesConfig_NodeAffinity struct {
	ArchAmd64            uint32   `protobuf:"varint,1,opt,name=arch_amd64,json=archAmd64,proto3" json:"arch_amd64,omitempty"`
	ArchS390X            uint32   `protobuf:"varint,2,opt,name=arch_s390x,json=archS390x,proto3" json:"arch_s390x,omitempty"`
	ArchPpc64Le          uint32   `protobuf:"varint,3,opt,name=arch_ppc64le,json=archPpc64le,proto3" json:"arch_ppc64le,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KubernetesResourcesConfig_NodeAffinity) Reset() {
	*m = KubernetesResourcesConfig_NodeAffinity{}
}
func (m *KubernetesResourcesConfig_NodeAffinity) String() string { return proto.CompactTextString(m) }
func (*KubernetesResourcesConfig_NodeAffinity) ProtoMessage()    {}
func (*KubernetesResourcesConfig_NodeAffinity) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{15, 2}
}
func (m *KubernetesResourcesConfig_NodeAffinity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubernetesResourcesConfig_NodeAffinity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubernetesResourcesConfig_NodeAffinity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubernetesResourcesConfig_NodeAffinity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesResourcesConfig_NodeAffinity.Merge(m, src)
}
func (m *KubernetesResourcesConfig_NodeAffinity) XXX_Size() int {
	return m.Size()
}
func (m *KubernetesResourcesConfig_NodeAffinity) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesResourcesConfig_NodeAffinity.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesResourcesConfig_NodeAffinity proto.InternalMessageInfo

func (m *KubernetesResourcesConfig_NodeAffinity) GetArchAmd64() uint32 {
	if m != nil {
		return m.ArchAmd64
	}
	return 0
}

func (m *KubernetesResourcesConfig_NodeAffinity) GetArchS390X() uint32 {
	if m != nil {
		return m.ArchS390X
	}
	return 0
}

func (m *KubernetesResourcesConfig_NodeAffinity) GetArchPpc64Le() uint32 {
	if m != nil {
		return m.ArchPpc64Le
	}
	return 0
}

// Configuration options for ingress gateways.
type IngressGatewayConfig struct {
	// Common gateway configuration.
	Gateway     *GatewayConfig                   `protobuf:"bytes,10,opt,name=gateway,proto3" json:"gateway,omitempty"`
	IngressType IngressGatewayConfig_IngressType `protobuf:"varint,11,opt,name=ingress_type,json=ingressType,proto3,enum=v1alpha1.IngressGatewayConfig_IngressType" json:"ingress_type,omitempty"`
	// enableHttps will add port 443 on the ingress.
	// It REQUIRES that the certificates are installed  in the
	// expected secrets - enabling this option without certificates
	// will result in LDS rejection and the ingress will not work.
	HttpsEnabled *protobuf.BoolValue `protobuf:"bytes,12,opt,name=https_enabled,json=httpsEnabled,proto3" json:"https_enabled,omitempty"`
	// Sets the IP address for the load balancer.
	// If unset, IP address will be allocated automatically if the provider
	// platform supports auto allocation.
	LoadBalancerIp string `protobuf:"bytes,13,opt,name=load_balancer_ip,json=loadBalancerIp,proto3" json:"load_balancer_ip,omitempty"`
	// ???
	LoadBalancerSourceRanges []string `protobuf:"bytes,14,rep,name=load_balancer_source_ranges,json=loadBalancerSourceRanges,proto3" json:"load_balancer_source_ranges,omitempty"`
	// ???
	ExternalIps []string `protobuf:"bytes,15,rep,name=external_ips,json=externalIps,proto3" json:"external_ips,omitempty"`
	// If true, ingress gateway fetches credentials from SDS server to handle TLS connections.
	SdsEnabled            *protobuf.BoolValue                        `protobuf:"bytes,16,opt,name=sds_enabled,json=sdsEnabled,proto3" json:"sds_enabled,omitempty"`
	ExternalTrafficPolicy IngressGatewayConfig_ExternalTrafficPolicy `protobuf:"varint,17,opt,name=externalTrafficPolicy,proto3,enum=v1alpha1.IngressGatewayConfig_ExternalTrafficPolicy" json:"externalTrafficPolicy,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}                                   `json:"-"`
	XXX_unrecognized      []byte                                     `json:"-"`
	XXX_sizecache         int32                                      `json:"-"`
}

func (m *IngressGatewayConfig) Reset()         { *m = IngressGatewayConfig{} }
func (m *IngressGatewayConfig) String() string { return proto.CompactTextString(m) }
func (*IngressGatewayConfig) ProtoMessage()    {}
func (*IngressGatewayConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{16}
}
func (m *IngressGatewayConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngressGatewayConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngressGatewayConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IngressGatewayConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngressGatewayConfig.Merge(m, src)
}
func (m *IngressGatewayConfig) XXX_Size() int {
	return m.Size()
}
func (m *IngressGatewayConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_IngressGatewayConfig.DiscardUnknown(m)
}

var xxx_messageInfo_IngressGatewayConfig proto.InternalMessageInfo

func (m *IngressGatewayConfig) GetGateway() *GatewayConfig {
	if m != nil {
		return m.Gateway
	}
	return nil
}

func (m *IngressGatewayConfig) GetIngressType() IngressGatewayConfig_IngressType {
	if m != nil {
		return m.IngressType
	}
	return IngressGatewayConfig_ISTIO
}

func (m *IngressGatewayConfig) GetHttpsEnabled() *protobuf.BoolValue {
	if m != nil {
		return m.HttpsEnabled
	}
	return nil
}

func (m *IngressGatewayConfig) GetLoadBalancerIp() string {
	if m != nil {
		return m.LoadBalancerIp
	}
	return ""
}

func (m *IngressGatewayConfig) GetLoadBalancerSourceRanges() []string {
	if m != nil {
		return m.LoadBalancerSourceRanges
	}
	return nil
}

func (m *IngressGatewayConfig) GetExternalIps() []string {
	if m != nil {
		return m.ExternalIps
	}
	return nil
}

func (m *IngressGatewayConfig) GetSdsEnabled() *protobuf.BoolValue {
	if m != nil {
		return m.SdsEnabled
	}
	return nil
}

func (m *IngressGatewayConfig) GetExternalTrafficPolicy() IngressGatewayConfig_ExternalTrafficPolicy {
	if m != nil {
		return m.ExternalTrafficPolicy
	}
	return IngressGatewayConfig_NONE
}

// Configuration options for egress gateways.
type EgressGatewayConfig struct {
	// Common gateway configuration.
	Gateway              *GatewayConfig `protobuf:"bytes,10,opt,name=gateway,proto3" json:"gateway,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *EgressGatewayConfig) Reset()         { *m = EgressGatewayConfig{} }
func (m *EgressGatewayConfig) String() string { return proto.CompactTextString(m) }
func (*EgressGatewayConfig) ProtoMessage()    {}
func (*EgressGatewayConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{17}
}
func (m *EgressGatewayConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EgressGatewayConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EgressGatewayConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EgressGatewayConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EgressGatewayConfig.Merge(m, src)
}
func (m *EgressGatewayConfig) XXX_Size() int {
	return m.Size()
}
func (m *EgressGatewayConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_EgressGatewayConfig.DiscardUnknown(m)
}

var xxx_messageInfo_EgressGatewayConfig proto.InternalMessageInfo

func (m *EgressGatewayConfig) GetGateway() *GatewayConfig {
	if m != nil {
		return m.Gateway
	}
	return nil
}

// Configuration options for internal load balancer gateways.
type LoadBalancingGatewayConfig struct {
	// Common gateway configuration.
	Gateway *GatewayConfig `protobuf:"bytes,10,opt,name=gateway,proto3" json:"gateway,omitempty"`
	// Sets the IP address for the load balancer.
	// If unset, IP address will be allocated automatically if the provider
	// platform supports auto allocation.
	// TODO: create IP type here and elsewhere.
	// TODO: look into tagging these
	LoadBalancerIp       string   `protobuf:"bytes,11,opt,name=load_balancer_ip,json=loadBalancerIp,proto3" json:"load_balancer_ip,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoadBalancingGatewayConfig) Reset()         { *m = LoadBalancingGatewayConfig{} }
func (m *LoadBalancingGatewayConfig) String() string { return proto.CompactTextString(m) }
func (*LoadBalancingGatewayConfig) ProtoMessage()    {}
func (*LoadBalancingGatewayConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{18}
}
func (m *LoadBalancingGatewayConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadBalancingGatewayConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoadBalancingGatewayConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoadBalancingGatewayConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadBalancingGatewayConfig.Merge(m, src)
}
func (m *LoadBalancingGatewayConfig) XXX_Size() int {
	return m.Size()
}
func (m *LoadBalancingGatewayConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadBalancingGatewayConfig.DiscardUnknown(m)
}

var xxx_messageInfo_LoadBalancingGatewayConfig proto.InternalMessageInfo

func (m *LoadBalancingGatewayConfig) GetGateway() *GatewayConfig {
	if m != nil {
		return m.Gateway
	}
	return nil
}

func (m *LoadBalancingGatewayConfig) GetLoadBalancerIp() string {
	if m != nil {
		return m.LoadBalancerIp
	}
	return ""
}

// Common config for all gateway types.
type GatewayConfig struct {
	Common *CommonComponentConfig `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	// NodePort, ClusterIP or LoadBalancer.
	Type                 string   `protobuf:"bytes,10,opt,name=type,proto3" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GatewayConfig) Reset()         { *m = GatewayConfig{} }
func (m *GatewayConfig) String() string { return proto.CompactTextString(m) }
func (*GatewayConfig) ProtoMessage()    {}
func (*GatewayConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{19}
}
func (m *GatewayConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GatewayConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GatewayConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GatewayConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GatewayConfig.Merge(m, src)
}
func (m *GatewayConfig) XXX_Size() int {
	return m.Size()
}
func (m *GatewayConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GatewayConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GatewayConfig proto.InternalMessageInfo

func (m *GatewayConfig) GetCommon() *CommonComponentConfig {
	if m != nil {
		return m.Common
	}
	return nil
}

func (m *GatewayConfig) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

// OperatorConfig defines a config used to install an external operator.
type OperatorConfig struct {
	// manifest_path is the URL for the operator install manifest.
	ManifestPath string `protobuf:"bytes,1,opt,name=manifest_path,json=manifestPath,proto3" json:"manifest_path,omitempty"`
	// namespace is the namespace the operator manifest and CR are installed into.
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// spec is the initial CR for the operator.
	Spec                 *K8SObjectOverlay `protobuf:"bytes,100,opt,name=spec,proto3" json:"spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *OperatorConfig) Reset()         { *m = OperatorConfig{} }
func (m *OperatorConfig) String() string { return proto.CompactTextString(m) }
func (*OperatorConfig) ProtoMessage()    {}
func (*OperatorConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{20}
}
func (m *OperatorConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperatorConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperatorConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperatorConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperatorConfig.Merge(m, src)
}
func (m *OperatorConfig) XXX_Size() int {
	return m.Size()
}
func (m *OperatorConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_OperatorConfig.DiscardUnknown(m)
}

var xxx_messageInfo_OperatorConfig proto.InternalMessageInfo

func (m *OperatorConfig) GetManifestPath() string {
	if m != nil {
		return m.ManifestPath
	}
	return ""
}

func (m *OperatorConfig) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *OperatorConfig) GetSpec() *K8SObjectOverlay {
	if m != nil {
		return m.Spec
	}
	return nil
}

// Patch for an existing k8s resource.
type K8SObjectOverlay struct {
	PatchType            K8SObjectOverlay_PatchType `protobuf:"varint,1,opt,name=patch_type,json=patchType,proto3,enum=v1alpha1.K8SObjectOverlay_PatchType" json:"patch_type,omitempty"`
	Op                   K8SObjectOverlay_Op        `protobuf:"varint,2,opt,name=op,proto3,enum=v1alpha1.K8SObjectOverlay_Op" json:"op,omitempty"`
	Data                 map[string]interface{}     `protobuf:"bytes,6,opt,name=data" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *K8SObjectOverlay) Reset()         { *m = K8SObjectOverlay{} }
func (m *K8SObjectOverlay) String() string { return proto.CompactTextString(m) }
func (*K8SObjectOverlay) ProtoMessage()    {}
func (*K8SObjectOverlay) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{21}
}
func (m *K8SObjectOverlay) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *K8SObjectOverlay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_K8SObjectOverlay.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *K8SObjectOverlay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_K8SObjectOverlay.Merge(m, src)
}
func (m *K8SObjectOverlay) XXX_Size() int {
	return m.Size()
}
func (m *K8SObjectOverlay) XXX_DiscardUnknown() {
	xxx_messageInfo_K8SObjectOverlay.DiscardUnknown(m)
}

var xxx_messageInfo_K8SObjectOverlay proto.InternalMessageInfo

func (m *K8SObjectOverlay) GetPatchType() K8SObjectOverlay_PatchType {
	if m != nil {
		return m.PatchType
	}
	return K8SObjectOverlay_STRATEGIC
}

func (m *K8SObjectOverlay) GetOp() K8SObjectOverlay_Op {
	if m != nil {
		return m.Op
	}
	return K8SObjectOverlay_ADD
}

// Observed state of IstioInstaller.
type InstallerStatus struct {
	TrafficManagement    *InstallerStatus_VersionStatus   `protobuf:"bytes,1,opt,name=traffic_management,json=trafficManagement,proto3" json:"traffic_management,omitempty"`
	PolicyTelemetry      *InstallerStatus_VersionStatus   `protobuf:"bytes,2,opt,name=policy_telemetry,json=policyTelemetry,proto3" json:"policy_telemetry,omitempty"`
	Security             *InstallerStatus_VersionStatus   `protobuf:"bytes,3,opt,name=security,proto3" json:"security,omitempty"`
	ConfigManagement     *InstallerStatus_VersionStatus   `protobuf:"bytes,4,opt,name=config_management,json=configManagement,proto3" json:"config_management,omitempty"`
	IngressGateway       []*InstallerStatus_VersionStatus `protobuf:"bytes,5,rep,name=ingress_gateway,json=ingressGateway,proto3" json:"ingress_gateway,omitempty"`
	EgressGateway        []*InstallerStatus_VersionStatus `protobuf:"bytes,6,rep,name=egress_gateway,json=egressGateway,proto3" json:"egress_gateway,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *InstallerStatus) Reset()         { *m = InstallerStatus{} }
func (m *InstallerStatus) String() string { return proto.CompactTextString(m) }
func (*InstallerStatus) ProtoMessage()    {}
func (*InstallerStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{22}
}
func (m *InstallerStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstallerStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstallerStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstallerStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallerStatus.Merge(m, src)
}
func (m *InstallerStatus) XXX_Size() int {
	return m.Size()
}
func (m *InstallerStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallerStatus.DiscardUnknown(m)
}

var xxx_messageInfo_InstallerStatus proto.InternalMessageInfo

func (m *InstallerStatus) GetTrafficManagement() *InstallerStatus_VersionStatus {
	if m != nil {
		return m.TrafficManagement
	}
	return nil
}

func (m *InstallerStatus) GetPolicyTelemetry() *InstallerStatus_VersionStatus {
	if m != nil {
		return m.PolicyTelemetry
	}
	return nil
}

func (m *InstallerStatus) GetSecurity() *InstallerStatus_VersionStatus {
	if m != nil {
		return m.Security
	}
	return nil
}

func (m *InstallerStatus) GetConfigManagement() *InstallerStatus_VersionStatus {
	if m != nil {
		return m.ConfigManagement
	}
	return nil
}

func (m *InstallerStatus) GetIngressGateway() []*InstallerStatus_VersionStatus {
	if m != nil {
		return m.IngressGateway
	}
	return nil
}

func (m *InstallerStatus) GetEgressGateway() []*InstallerStatus_VersionStatus {
	if m != nil {
		return m.EgressGateway
	}
	return nil
}

type InstallerStatus_VersionStatus struct {
	Version              string                 `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	Status               InstallerStatus_Status `protobuf:"varint,2,opt,name=status,proto3,enum=v1alpha1.InstallerStatus_Status" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *InstallerStatus_VersionStatus) Reset()         { *m = InstallerStatus_VersionStatus{} }
func (m *InstallerStatus_VersionStatus) String() string { return proto.CompactTextString(m) }
func (*InstallerStatus_VersionStatus) ProtoMessage()    {}
func (*InstallerStatus_VersionStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{22, 0}
}
func (m *InstallerStatus_VersionStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstallerStatus_VersionStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstallerStatus_VersionStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstallerStatus_VersionStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallerStatus_VersionStatus.Merge(m, src)
}
func (m *InstallerStatus_VersionStatus) XXX_Size() int {
	return m.Size()
}
func (m *InstallerStatus_VersionStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallerStatus_VersionStatus.DiscardUnknown(m)
}

var xxx_messageInfo_InstallerStatus_VersionStatus proto.InternalMessageInfo

func (m *InstallerStatus_VersionStatus) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *InstallerStatus_VersionStatus) GetStatus() InstallerStatus_Status {
	if m != nil {
		return m.Status
	}
	return InstallerStatus_NONE
}

// Mirrors k8s.io.api.core.v1.ResourceRequirements for unmarshaling.
type Resources struct {
	Limits               map[string]string `protobuf:"bytes,1,rep,name=limits,proto3" json:"limits,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Requests             map[string]string `protobuf:"bytes,2,rep,name=requests,proto3" json:"requests,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Resources) Reset()         { *m = Resources{} }
func (m *Resources) String() string { return proto.CompactTextString(m) }
func (*Resources) ProtoMessage()    {}
func (*Resources) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{23}
}
func (m *Resources) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Resources) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Resources.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Resources) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Resources.Merge(m, src)
}
func (m *Resources) XXX_Size() int {
	return m.Size()
}
func (m *Resources) XXX_DiscardUnknown() {
	xxx_messageInfo_Resources.DiscardUnknown(m)
}

var xxx_messageInfo_Resources proto.InternalMessageInfo

func (m *Resources) GetLimits() map[string]string {
	if m != nil {
		return m.Limits
	}
	return nil
}

func (m *Resources) GetRequests() map[string]string {
	if m != nil {
		return m.Requests
	}
	return nil
}

// Mirrors k8s.io.api.policy.v1beta1.PodDisruptionBudget for unmarshaling.
type PodDisruptionBudgetSpec struct {
	MinAvailable         uint32             `protobuf:"varint,1,opt,name=min_available,json=minAvailable,proto3" json:"min_available,omitempty"`
	Selector             *v12.LabelSelector `protobuf:"bytes,2,opt,name=selector,proto3" json:"selector,omitempty"`
	MaxUnavailable       uint32             `protobuf:"varint,3,opt,name=max_unavailable,json=maxUnavailable,proto3" json:"max_unavailable,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *PodDisruptionBudgetSpec) Reset()         { *m = PodDisruptionBudgetSpec{} }
func (m *PodDisruptionBudgetSpec) String() string { return proto.CompactTextString(m) }
func (*PodDisruptionBudgetSpec) ProtoMessage()    {}
func (*PodDisruptionBudgetSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{24}
}
func (m *PodDisruptionBudgetSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodDisruptionBudgetSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodDisruptionBudgetSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodDisruptionBudgetSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodDisruptionBudgetSpec.Merge(m, src)
}
func (m *PodDisruptionBudgetSpec) XXX_Size() int {
	return m.Size()
}
func (m *PodDisruptionBudgetSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PodDisruptionBudgetSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PodDisruptionBudgetSpec proto.InternalMessageInfo

func (m *PodDisruptionBudgetSpec) GetMinAvailable() uint32 {
	if m != nil {
		return m.MinAvailable
	}
	return 0
}

func (m *PodDisruptionBudgetSpec) GetSelector() *v12.LabelSelector {
	if m != nil {
		return m.Selector
	}
	return nil
}

func (m *PodDisruptionBudgetSpec) GetMaxUnavailable() uint32 {
	if m != nil {
		return m.MaxUnavailable
	}
	return 0
}

type ObjectMeta struct {
	// From k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta
	Name                 string   `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	Namespace            string   `protobuf:"bytes,6,opt,name=namespace,proto3" json:"namespace,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ObjectMeta) Reset()         { *m = ObjectMeta{} }
func (m *ObjectMeta) String() string { return proto.CompactTextString(m) }
func (*ObjectMeta) ProtoMessage()    {}
func (*ObjectMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{25}
}
func (m *ObjectMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectMeta.Merge(m, src)
}
func (m *ObjectMeta) XXX_Size() int {
	return m.Size()
}
func (m *ObjectMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectMeta.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectMeta proto.InternalMessageInfo

func (m *ObjectMeta) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ObjectMeta) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// TESTING ONLY
type TestKube struct {
	Env                 map[string]string                `protobuf:"bytes,60,rep,name=env,proto3" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Resources           *Resources                       `protobuf:"bytes,80,opt,name=resources,proto3" json:"resources,omitempty"`
	ReadinessProbe      *v1.Probe                        `protobuf:"bytes,81,opt,name=readiness_probe,json=readinessProbe,proto3" json:"readiness_probe,omitempty"`
	HpaSpec             *v11.HorizontalPodAutoscalerSpec `protobuf:"bytes,86,opt,name=hpa_spec,json=hpaSpec,proto3" json:"hpa_spec,omitempty"`
	PodDisruptionBudget *PodDisruptionBudgetSpec         `protobuf:"bytes,87,opt,name=pod_disruption_budget,json=podDisruptionBudget,proto3" json:"pod_disruption_budget,omitempty"`
	PodAnnotations      map[string]string                `protobuf:"bytes,90,rep,name=pod_annotations,json=podAnnotations,proto3" json:"pod_annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	NodeSelector        map[string]string                `protobuf:"bytes,92,rep,name=node_selector,json=nodeSelector,proto3" json:"node_selector,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Kustomize style overrides for k8s resources in rendered manifests.
	K8SObjectOverride    []*K8SObjectOverlay `protobuf:"bytes,100,rep,name=k8s_object_override,json=k8sObjectOverride,proto3" json:"k8s_object_override,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TestKube) Reset()         { *m = TestKube{} }
func (m *TestKube) String() string { return proto.CompactTextString(m) }
func (*TestKube) ProtoMessage()    {}
func (*TestKube) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{26}
}
func (m *TestKube) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestKube) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestKube.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestKube) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestKube.Merge(m, src)
}
func (m *TestKube) XXX_Size() int {
	return m.Size()
}
func (m *TestKube) XXX_DiscardUnknown() {
	xxx_messageInfo_TestKube.DiscardUnknown(m)
}

var xxx_messageInfo_TestKube proto.InternalMessageInfo

func (m *TestKube) GetEnv() map[string]string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *TestKube) GetResources() *Resources {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *TestKube) GetReadinessProbe() *v1.Probe {
	if m != nil {
		return m.ReadinessProbe
	}
	return nil
}

func (m *TestKube) GetHpaSpec() *v11.HorizontalPodAutoscalerSpec {
	if m != nil {
		return m.HpaSpec
	}
	return nil
}

func (m *TestKube) GetPodDisruptionBudget() *PodDisruptionBudgetSpec {
	if m != nil {
		return m.PodDisruptionBudget
	}
	return nil
}

func (m *TestKube) GetPodAnnotations() map[string]string {
	if m != nil {
		return m.PodAnnotations
	}
	return nil
}

func (m *TestKube) GetNodeSelector() map[string]string {
	if m != nil {
		return m.NodeSelector
	}
	return nil
}

func (m *TestKube) GetK8SObjectOverride() []*K8SObjectOverlay {
	if m != nil {
		return m.K8SObjectOverride
	}
	return nil
}

func init() {
	proto.RegisterEnum("v1alpha1.PolicyTelemetryConfig_OutboundPolicy", PolicyTelemetryConfig_OutboundPolicy_name, PolicyTelemetryConfig_OutboundPolicy_value)
	proto.RegisterEnum("v1alpha1.CommonComponentConfig_LogLevel", CommonComponentConfig_LogLevel_name, CommonComponentConfig_LogLevel_value)
	proto.RegisterEnum("v1alpha1.IngressGatewayConfig_IngressType", IngressGatewayConfig_IngressType_name, IngressGatewayConfig_IngressType_value)
	proto.RegisterEnum("v1alpha1.IngressGatewayConfig_ExternalTrafficPolicy", IngressGatewayConfig_ExternalTrafficPolicy_name, IngressGatewayConfig_ExternalTrafficPolicy_value)
	proto.RegisterEnum("v1alpha1.K8SObjectOverlay_PatchType", K8SObjectOverlay_PatchType_name, K8SObjectOverlay_PatchType_value)
	proto.RegisterEnum("v1alpha1.K8SObjectOverlay_Op", K8SObjectOverlay_Op_name, K8SObjectOverlay_Op_value)
	proto.RegisterEnum("v1alpha1.InstallerStatus_Status", InstallerStatus_Status_name, InstallerStatus_Status_value)
	proto.RegisterType((*IstioInstaller)(nil), "v1alpha1.IstioInstaller")
	proto.RegisterType((*InstallerSpec)(nil), "v1alpha1.InstallerSpec")
	proto.RegisterType((*TrafficManagementConfig)(nil), "v1alpha1.TrafficManagementConfig")
	proto.RegisterType((*PolicyTelemetryConfig)(nil), "v1alpha1.PolicyTelemetryConfig")
	proto.RegisterType((*SecurityConfig)(nil), "v1alpha1.SecurityConfig")
	proto.RegisterType((*PilotComponentConfig)(nil), "v1alpha1.PilotComponentConfig")
	proto.RegisterType((*ProxyComponentConfig)(nil), "v1alpha1.ProxyComponentConfig")
	proto.RegisterType((*SidecarInjectorComponentConfig)(nil), "v1alpha1.SidecarInjectorComponentConfig")
	proto.RegisterType((*PolicyComponentConfig)(nil), "v1alpha1.PolicyComponentConfig")
	proto.RegisterType((*TelemetryComponentConfig)(nil), "v1alpha1.TelemetryComponentConfig")
	proto.RegisterType((*CitadelComponentConfig)(nil), "v1alpha1.CitadelComponentConfig")
	proto.RegisterType((*CertManagerComponentConfig)(nil), "v1alpha1.CertManagerComponentConfig")
	proto.RegisterType((*NodeAgentComponentConfig)(nil), "v1alpha1.NodeAgentComponentConfig")
	proto.RegisterType((*ConfigManagementConfig)(nil), "v1alpha1.ConfigManagementConfig")
	proto.RegisterType((*CommonComponentConfig)(nil), "v1alpha1.CommonComponentConfig")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.CommonComponentConfig.ArgsEntry")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.CommonComponentConfig.EnvEntry")
	proto.RegisterType((*KubernetesResourcesConfig)(nil), "v1alpha1.KubernetesResourcesConfig")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.KubernetesResourcesConfig.NodeSelectorEntry")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.KubernetesResourcesConfig.PodAnnotationsEntry")
	proto.RegisterType((*KubernetesResourcesConfig_NodeAffinity)(nil), "v1alpha1.KubernetesResourcesConfig.NodeAffinity")
	proto.RegisterType((*IngressGatewayConfig)(nil), "v1alpha1.IngressGatewayConfig")
	proto.RegisterType((*EgressGatewayConfig)(nil), "v1alpha1.EgressGatewayConfig")
	proto.RegisterType((*LoadBalancingGatewayConfig)(nil), "v1alpha1.LoadBalancingGatewayConfig")
	proto.RegisterType((*GatewayConfig)(nil), "v1alpha1.GatewayConfig")
	proto.RegisterType((*OperatorConfig)(nil), "v1alpha1.OperatorConfig")
	proto.RegisterType((*K8SObjectOverlay)(nil), "v1alpha1.k8sObjectOverlay")
	proto.RegisterType((*InstallerStatus)(nil), "v1alpha1.InstallerStatus")
	proto.RegisterType((*InstallerStatus_VersionStatus)(nil), "v1alpha1.InstallerStatus.VersionStatus")
	proto.RegisterType((*Resources)(nil), "v1alpha1.Resources")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.Resources.LimitsEntry")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.Resources.RequestsEntry")
	proto.RegisterType((*PodDisruptionBudgetSpec)(nil), "v1alpha1.PodDisruptionBudgetSpec")
	proto.RegisterType((*ObjectMeta)(nil), "v1alpha1.ObjectMeta")
	proto.RegisterType((*TestKube)(nil), "v1alpha1.TestKube")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.TestKube.EnvEntry")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.TestKube.NodeSelectorEntry")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.TestKube.PodAnnotationsEntry")
}

func init() { proto.RegisterFile("istioinstaller_types.proto", fileDescriptor_d0a1188b3d395975) }

var fileDescriptor_d0a1188b3d395975 = []byte{
	// 2591 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x59, 0x4d, 0x73, 0xe3, 0xc6,
	0xd1, 0x5e, 0x8a, 0xfa, 0x62, 0x53, 0xa4, 0xa8, 0xd1, 0xee, 0x1a, 0x4b, 0xaf, 0x65, 0x19, 0xde,
	0xf7, 0xb5, 0xec, 0x94, 0x29, 0x4b, 0x2b, 0xaf, 0x65, 0x3b, 0x6b, 0x9b, 0x92, 0x68, 0xad, 0x6c,
	0x4a, 0xa4, 0x41, 0x6a, 0x5d, 0xeb, 0xb8, 0x0a, 0x19, 0x02, 0x23, 0x12, 0x16, 0x88, 0x41, 0x30,
	0x43, 0x59, 0xcc, 0x35, 0x95, 0xaa, 0x9c, 0x72, 0x4e, 0xfe, 0x48, 0x2a, 0x3f, 0x21, 0xc7, 0x5c,
	0x72, 0x4e, 0x6a, 0x93, 0x7f, 0x90, 0x63, 0xaa, 0x92, 0xd4, 0x0c, 0x06, 0x04, 0x3f, 0x20, 0xeb,
	0x63, 0xbd, 0x55, 0xb9, 0x81, 0xdd, 0x4f, 0x3f, 0x98, 0x19, 0x74, 0xf7, 0x74, 0x37, 0xa1, 0xe8,
	0x30, 0xee, 0x50, 0xc7, 0x63, 0x1c, 0xbb, 0x2e, 0x09, 0x4c, 0xde, 0xf7, 0x09, 0x2b, 0xf9, 0x01,
	0xe5, 0x14, 0xcd, 0x9f, 0x6d, 0x60, 0xd7, 0xef, 0xe0, 0x8d, 0xa2, 0x7e, 0xba, 0xcd, 0x4a, 0x0e,
	0x5d, 0xc7, 0xbe, 0xb3, 0x6e, 0xd1, 0x80, 0xac, 0x9f, 0x6d, 0xac, 0xb7, 0x89, 0x47, 0x02, 0xcc,
	0x89, 0x1d, 0xa2, 0x8b, 0x6f, 0x0f, 0x61, 0x70, 0x8f, 0x53, 0x66, 0x61, 0xd7, 0xf1, 0xda, 0x49,
	0xd0, 0xad, 0x18, 0xda, 0xc5, 0x56, 0xc7, 0xf1, 0x48, 0xd0, 0x5f, 0xf7, 0x4f, 0xdb, 0x42, 0xc0,
	0xd6, 0xbb, 0x84, 0xe3, 0x24, 0xab, 0xcf, 0xda, 0x0e, 0xef, 0xf4, 0x5a, 0x25, 0x8b, 0x76, 0xd7,
	0xdb, 0xb4, 0x4d, 0xd7, 0xa5, 0xb8, 0xd5, 0x3b, 0x89, 0x1f, 0xda, 0x94, 0xb6, 0x5d, 0x12, 0xff,
	0xfe, 0x3e, 0xc0, 0xbe, 0x4f, 0x02, 0xb5, 0x21, 0xdd, 0x87, 0xfc, 0x81, 0xd8, 0xee, 0x41, 0xb4,
	0x5d, 0xf4, 0x13, 0x98, 0x66, 0x3e, 0xb1, 0xb4, 0xf4, 0x6a, 0x6a, 0x2d, 0xbb, 0xf9, 0x4a, 0x29,
	0xda, 0x71, 0x69, 0x00, 0x69, 0xf8, 0xc4, 0x32, 0x24, 0x08, 0x6d, 0xc0, 0x2c, 0xe3, 0x98, 0xf7,
	0x98, 0x36, 0x2d, 0xe1, 0xf7, 0x92, 0xe0, 0x12, 0x60, 0x28, 0xa0, 0xfe, 0x7c, 0x06, 0x72, 0x23,
	0x54, 0xe8, 0x3d, 0xb8, 0xad, 0x4e, 0xdb, 0xf4, 0xb1, 0x75, 0x8a, 0xdb, 0xc4, 0xf4, 0x31, 0xef,
	0x68, 0xa9, 0xd5, 0xd4, 0x5a, 0xc6, 0x40, 0x4a, 0x57, 0x0f, 0x55, 0x75, 0xcc, 0x3b, 0xa8, 0x00,
	0xe9, 0x4e, 0xaf, 0x25, 0x97, 0x98, 0x31, 0xc4, 0xa3, 0x90, 0x70, 0xdc, 0x96, 0xab, 0xc8, 0x18,
	0xe2, 0x11, 0x6d, 0x83, 0x66, 0x93, 0x13, 0xdc, 0x73, 0xb9, 0xe9, 0xe1, 0x2e, 0x61, 0x3e, 0xb6,
	0x88, 0xe9, 0x07, 0xe4, 0xc4, 0x39, 0xd7, 0x66, 0x24, 0xec, 0xae, 0xd2, 0x1f, 0x45, 0xea, 0xba,
	0xd4, 0xa2, 0x3a, 0x20, 0x1e, 0xe0, 0x93, 0x13, 0xc7, 0x32, 0xbb, 0xd8, 0xc3, 0x6d, 0xd2, 0x25,
	0x1e, 0xd7, 0xee, 0xc9, 0x0d, 0xbe, 0x11, 0x6f, 0xb0, 0x19, 0x62, 0x0e, 0x07, 0x90, 0x5d, 0xea,
	0x9d, 0x38, 0x6d, 0x63, 0x89, 0x8f, 0x2b, 0xd0, 0x17, 0x50, 0xf0, 0xa9, 0xeb, 0x58, 0x7d, 0x93,
	0x13, 0x97, 0x74, 0x09, 0x0f, 0xfa, 0x5a, 0x51, 0xf2, 0xbd, 0x1e, 0xf3, 0xd5, 0x25, 0xa2, 0x19,
	0x01, 0x14, 0xdb, 0xa2, 0x3f, 0x2a, 0x46, 0x5b, 0x30, 0xcf, 0x88, 0xd5, 0x0b, 0x1c, 0xde, 0xd7,
	0xee, 0x4b, 0x0e, 0x2d, 0xe6, 0x68, 0x28, 0x8d, 0x32, 0x1e, 0x20, 0xd1, 0x21, 0x2c, 0x59, 0x52,
	0x36, 0xbc, 0xa5, 0xd7, 0xa4, 0xf9, 0x6a, 0x6c, 0x1e, 0x9a, 0x4d, 0xec, 0xa8, 0x60, 0x8d, 0xc9,
	0xd1, 0x3e, 0x2c, 0x3a, 0x5e, 0x3b, 0x20, 0x8c, 0x99, 0x6d, 0xcc, 0xc9, 0xf7, 0xb8, 0xaf, 0xad,
	0xac, 0xa6, 0xd7, 0xb2, 0x9b, 0x2b, 0xc3, 0x0e, 0x20, 0x01, 0xfb, 0xa1, 0x5e, 0x51, 0xe5, 0x9d,
	0x11, 0x29, 0xda, 0x83, 0x3c, 0x19, 0xe5, 0x79, 0x5d, 0xf2, 0xbc, 0x16, 0xf3, 0x54, 0x12, 0x68,
	0x72, 0x64, 0x84, 0x65, 0x1f, 0x10, 0x39, 0xe7, 0x24, 0xf0, 0xb0, 0x6b, 0x52, 0x5f, 0x84, 0x08,
	0x0d, 0x98, 0xb6, 0x29, 0x99, 0x86, 0x4e, 0xa7, 0xa6, 0x54, 0xd1, 0x87, 0x8a, 0x6c, 0x22, 0x39,
	0x43, 0x9f, 0xc3, 0xc2, 0xe9, 0x36, 0x33, 0x95, 0x63, 0x30, 0xad, 0x2e, 0x4f, 0xe8, 0xcd, 0x98,
	0xe2, 0xcb, 0x5e, 0x8b, 0x04, 0x1e, 0xe1, 0x84, 0x19, 0x84, 0xd1, 0x5e, 0x60, 0x11, 0xa6, 0xd8,
	0xb2, 0xa7, 0xdb, 0x6c, 0x4f, 0xd9, 0xe9, 0x7f, 0x99, 0x82, 0x57, 0x2e, 0xf0, 0x0f, 0xb4, 0x05,
	0x73, 0xc4, 0xc3, 0x2d, 0x97, 0xd8, 0xd2, 0xc3, 0xb3, 0x9b, 0xc5, 0x52, 0x18, 0xa4, 0xa5, 0x28,
	0x48, 0x4b, 0x3b, 0x94, 0xba, 0x4f, 0xb1, 0xdb, 0x23, 0x46, 0x04, 0x45, 0xf7, 0x21, 0x33, 0x70,
	0x63, 0x6d, 0x4a, 0xfa, 0x6f, 0x2c, 0x40, 0xff, 0x07, 0x79, 0xcb, 0xed, 0x31, 0x4e, 0x02, 0xd3,
	0xa6, 0x5d, 0xec, 0x78, 0x9a, 0x26, 0x21, 0x39, 0x25, 0xdd, 0x93, 0x42, 0xb4, 0x05, 0x33, 0xbe,
	0xe3, 0x52, 0xae, 0xad, 0xc8, 0x17, 0x0f, 0x7d, 0xac, 0xba, 0x10, 0xef, 0xd2, 0xae, 0x4f, 0xbd,
	0xf8, 0xbb, 0x87, 0x60, 0x69, 0x15, 0xd0, 0x73, 0xf1, 0x69, 0xc6, 0xad, 0x84, 0x78, 0xd2, 0x4a,
	0x48, 0x51, 0x03, 0x0a, 0xcc, 0xb1, 0x89, 0x85, 0x03, 0xd3, 0xf1, 0xbe, 0x23, 0x16, 0xa7, 0x81,
	0xb6, 0x2a, 0x09, 0xd6, 0x86, 0xfc, 0x35, 0x44, 0x1c, 0x28, 0xc0, 0x38, 0xd5, 0x22, 0x1b, 0xd5,
	0xeb, 0xbf, 0x49, 0xc3, 0x9d, 0xc4, 0x38, 0x41, 0x35, 0xb8, 0xab, 0x42, 0xcc, 0xea, 0x10, 0xeb,
	0xd4, 0x3c, 0xc1, 0x8e, 0xf4, 0x05, 0x4f, 0x83, 0x4b, 0x0f, 0x79, 0x39, 0xb4, 0xdc, 0x15, 0x86,
	0x9f, 0x63, 0x47, 0xf8, 0x83, 0x87, 0x28, 0xdc, 0xa7, 0x3d, 0xde, 0xa2, 0x3d, 0xcf, 0x36, 0xa3,
	0x74, 0xa0, 0xde, 0xd0, 0xa5, 0x36, 0xd1, 0xb2, 0xab, 0xa9, 0xb5, 0xfc, 0x66, 0xe9, 0x92, 0xf8,
	0x2d, 0xd5, 0x14, 0x47, 0xa8, 0x35, 0xee, 0x45, 0x9c, 0xca, 0x3b, 0x42, 0xf1, 0x21, 0xb5, 0x09,
	0xfa, 0x00, 0x66, 0x43, 0x7e, 0x6d, 0x33, 0x39, 0x35, 0x8c, 0x9f, 0x8e, 0x82, 0xa3, 0xcf, 0x20,
	0x13, 0xa7, 0x95, 0x87, 0xd2, 0x56, 0x1f, 0x4a, 0x53, 0xf1, 0x82, 0x46, 0xcd, 0x63, 0x23, 0x7d,
	0x13, 0xf2, 0xa3, 0xeb, 0x44, 0x39, 0xc8, 0x94, 0xab, 0xd5, 0xda, 0xd7, 0x66, 0xf9, 0xe8, 0x59,
	0xe1, 0x16, 0x5a, 0x82, 0x9c, 0x51, 0xd9, 0x3f, 0x68, 0x34, 0x8d, 0x67, 0x66, 0xed, 0xa8, 0xfa,
	0xac, 0x90, 0xd2, 0xff, 0x31, 0x0d, 0xf9, 0xd1, 0x74, 0xf3, 0x52, 0x3c, 0xfb, 0x09, 0x20, 0x8b,
	0x7a, 0x3c, 0xa0, 0xae, 0xe9, 0xbb, 0xd8, 0x23, 0x66, 0x97, 0xbb, 0x4c, 0xcb, 0x5d, 0x4a, 0x5f,
	0x50, 0x56, 0x75, 0x61, 0x74, 0xc8, 0x5d, 0x86, 0x76, 0x60, 0xd1, 0xc6, 0x1c, 0x0f, 0xd3, 0xe4,
	0x2f, 0xa5, 0xc9, 0x09, 0x93, 0x98, 0xe3, 0x0d, 0x58, 0xe0, 0x41, 0x8f, 0xf1, 0x28, 0xca, 0x16,
	0xe5, 0x72, 0xb3, 0x52, 0xa6, 0x62, 0xec, 0x63, 0xc8, 0x32, 0xe2, 0x9e, 0x98, 0xcc, 0x69, 0x7b,
	0xc4, 0xd6, 0x0a, 0x97, 0xbe, 0x02, 0x04, 0xbc, 0x21, 0xd1, 0x72, 0xb7, 0x01, 0xc1, 0x9c, 0x98,
	0x5d, 0xc2, 0x3a, 0xca, 0xdf, 0xb4, 0xa5, 0x2b, 0xec, 0x56, 0x5a, 0x1d, 0x12, 0xd6, 0x51, 0x1f,
	0xf0, 0x23, 0x98, 0xb3, 0x1c, 0x8e, 0x6d, 0xe2, 0x6a, 0xb7, 0x27, 0xd2, 0x7c, 0xa8, 0x18, 0x77,
	0x88, 0xc8, 0x00, 0xed, 0xc3, 0x82, 0x45, 0x02, 0xae, 0xae, 0x8a, 0x40, 0xbb, 0x23, 0x09, 0x1e,
	0x0c, 0x11, 0x90, 0x80, 0x87, 0x79, 0x6d, 0x22, 0x64, 0xb3, 0x56, 0xac, 0x43, 0x65, 0x00, 0x8f,
	0xda, 0xc4, 0xc4, 0x6d, 0x71, 0xdd, 0xdc, 0x1d, 0x77, 0xcd, 0x23, 0x6a, 0x93, 0x72, 0x5b, 0xda,
	0x8e, 0xb9, 0xa6, 0x17, 0x69, 0xf4, 0x5f, 0xa7, 0xe0, 0x76, 0x52, 0x72, 0x12, 0xe1, 0x62, 0xd1,
	0x6e, 0x97, 0x7a, 0xca, 0xd7, 0x5e, 0x1f, 0xbe, 0xc6, 0x84, 0x7c, 0x22, 0x5c, 0x42, 0xb8, 0xf0,
	0x52, 0x95, 0x56, 0xae, 0x90, 0x1a, 0x22, 0xa8, 0x5e, 0x83, 0xdb, 0x49, 0xd9, 0xee, 0xc6, 0xcb,
	0xd0, 0xff, 0x90, 0x82, 0x95, 0x1f, 0x4e, 0x7f, 0x37, 0xdf, 0xe2, 0xcf, 0xe0, 0x7e, 0x18, 0x5d,
	0x71, 0xe9, 0xc3, 0xcc, 0x56, 0x3f, 0xba, 0xd7, 0xae, 0xb0, 0xef, 0x7b, 0xa1, 0xfd, 0xa0, 0x34,
	0x62, 0x3b, 0x7d, 0x75, 0xb9, 0xe9, 0xf5, 0x28, 0x05, 0xff, 0x68, 0x47, 0xd1, 0x00, 0xed, 0xa2,
	0x2c, 0x75, 0x73, 0xd2, 0xaf, 0xe0, 0x6e, 0xb2, 0x9f, 0xdf, 0x9c, 0xf2, 0x18, 0x8a, 0x17, 0x7b,
	0xfe, 0x0b, 0x6d, 0xff, 0xa2, 0x48, 0x78, 0xb1, 0xed, 0x27, 0x56, 0x73, 0x37, 0xa7, 0xfc, 0xed,
	0x34, 0xdc, 0x49, 0x44, 0xbc, 0x94, 0xc4, 0xff, 0x09, 0xcc, 0xd8, 0xa4, 0xd5, 0x6b, 0xcb, 0x2a,
	0x3f, 0x3f, 0x5c, 0x34, 0x24, 0xae, 0xa1, 0x54, 0xa5, 0xed, 0x2a, 0x39, 0x23, 0xae, 0x11, 0x9a,
	0xa1, 0x8f, 0x20, 0x4d, 0xbc, 0x33, 0xed, 0xa7, 0xb2, 0x08, 0xbc, 0xd4, 0xba, 0xe2, 0x9d, 0x55,
	0x3c, 0x1e, 0xf4, 0x0d, 0x61, 0x84, 0x1e, 0xc3, 0x34, 0x0e, 0xda, 0x4c, 0x7b, 0x2c, 0x8d, 0xdf,
	0xbe, 0xcc, 0xb8, 0x1c, 0xb4, 0x59, 0x68, 0x2d, 0xcd, 0xd0, 0xfb, 0x90, 0x3e, 0xdd, 0xbe, 0x56,
	0xf1, 0x28, 0xf0, 0xc5, 0x47, 0x30, 0x1f, 0x2d, 0x43, 0xf4, 0x33, 0xa7, 0xa4, 0xaf, 0x5a, 0x20,
	0xf1, 0x88, 0x6e, 0xc3, 0xcc, 0x99, 0x38, 0x3f, 0x75, 0x52, 0xe1, 0x8f, 0x8f, 0xa6, 0xb6, 0x53,
	0xc5, 0x0f, 0x20, 0x33, 0x58, 0xc1, 0x75, 0x0c, 0xf5, 0x4f, 0x60, 0x3e, 0x3a, 0x35, 0x34, 0x0f,
	0xd3, 0x47, 0xb5, 0xa3, 0x4a, 0xe1, 0x16, 0xca, 0xc0, 0x4c, 0xc5, 0x30, 0x6a, 0x46, 0x21, 0x25,
	0x84, 0x5f, 0x97, 0x8d, 0xa3, 0xc2, 0x94, 0x10, 0xee, 0x55, 0x76, 0x8e, 0xf7, 0x0b, 0x69, 0x21,
	0x3c, 0x38, 0xfa, 0xbc, 0x56, 0x98, 0xd6, 0xff, 0x33, 0x07, 0xf7, 0x2e, 0xdc, 0x13, 0xda, 0x80,
	0x4c, 0x10, 0x89, 0x94, 0x5b, 0x2c, 0xc7, 0x67, 0x31, 0x40, 0x1b, 0x31, 0x4a, 0x5c, 0xd1, 0x01,
	0xc1, 0xb6, 0xe3, 0x89, 0x86, 0xc0, 0x0f, 0x68, 0x2b, 0x5c, 0xb4, 0xe8, 0x2b, 0xc3, 0xfe, 0xb8,
	0x84, 0x7d, 0xa7, 0x24, 0xda, 0xed, 0xd2, 0x99, 0xac, 0x3e, 0x5b, 0xc4, 0xc8, 0x0f, 0x2c, 0xe4,
	0x6f, 0xf4, 0x26, 0xe4, 0x02, 0xe2, 0xbb, 0x8e, 0x85, 0x4d, 0x8b, 0xf6, 0x3c, 0x2e, 0xfd, 0x27,
	0x67, 0x2c, 0x28, 0xe1, 0xae, 0x90, 0xa1, 0xaf, 0x60, 0xbe, 0xe3, 0x63, 0x53, 0x36, 0xba, 0x61,
	0xe7, 0xfa, 0x68, 0xf8, 0x0d, 0x43, 0xcd, 0xba, 0x78, 0xd1, 0x13, 0x1a, 0x38, 0xbf, 0xa4, 0x1e,
	0xc7, 0x6e, 0x9d, 0xda, 0x65, 0xa5, 0x53, 0x7d, 0xf0, 0x5c, 0xc7, 0xc7, 0xb2, 0x8b, 0x3d, 0x86,
	0x3b, 0x3e, 0xb5, 0x4d, 0xdb, 0x61, 0x41, 0xcf, 0xe7, 0x0e, 0xf5, 0xcc, 0x56, 0xcf, 0x6e, 0x13,
	0x2e, 0x9b, 0xcd, 0x91, 0xc6, 0xb1, 0x4e, 0xed, 0xbd, 0x01, 0x6a, 0x47, 0x82, 0x24, 0xd5, 0xb2,
	0x3f, 0xa9, 0x40, 0x3f, 0x87, 0x45, 0x41, 0x8b, 0x3d, 0x8f, 0x72, 0x2c, 0xe4, 0x4c, 0x9b, 0x95,
	0x5e, 0xf9, 0xc1, 0x15, 0xfc, 0x4a, 0xbc, 0xaa, 0x1c, 0x5b, 0x86, 0x3e, 0x9a, 0xf7, 0x47, 0x84,
	0xe8, 0x1b, 0xc8, 0xc9, 0x4b, 0x9a, 0x11, 0x37, 0xac, 0xd2, 0xe7, 0x24, 0xff, 0xfb, 0x57, 0xe1,
	0x17, 0x79, 0xab, 0xa1, 0xec, 0x42, 0xf6, 0x05, 0x6f, 0x48, 0x84, 0x8e, 0x15, 0xb7, 0xa8, 0x75,
	0x3d, 0xd1, 0xb1, 0xce, 0xcb, 0xc3, 0x78, 0xef, 0xaa, 0xdc, 0x65, 0x65, 0x17, 0xd2, 0x46, 0xbf,
	0xd0, 0x3b, 0xb0, 0xe4, 0x74, 0xe5, 0x9c, 0xa0, 0xe7, 0xba, 0x51, 0x95, 0x94, 0x91, 0xee, 0xbd,
	0x28, 0x15, 0xf5, 0x9e, 0xeb, 0xaa, 0x42, 0xa8, 0x04, 0xcb, 0x7e, 0xe0, 0x50, 0x51, 0xa6, 0x9a,
	0x96, 0x8b, 0x19, 0x93, 0x77, 0xa2, 0xbc, 0x02, 0x33, 0xc6, 0x52, 0xa4, 0xda, 0x15, 0x1a, 0x71,
	0xdb, 0xa1, 0x47, 0x30, 0x4f, 0xcf, 0x48, 0xe0, 0xe2, 0x3e, 0xd3, 0x6c, 0x79, 0x12, 0xc5, 0x78,
	0xb5, 0xa7, 0xdb, 0xac, 0xd6, 0x12, 0x97, 0x75, 0x2d, 0x84, 0x18, 0x03, 0x6c, 0xb1, 0x0c, 0xcb,
	0x09, 0xa7, 0x7d, 0xad, 0x40, 0xfe, 0x14, 0x96, 0x26, 0x0e, 0xf4, 0x5a, 0x04, 0x14, 0x16, 0x86,
	0x4f, 0x0d, 0xbd, 0x06, 0x80, 0x03, 0xab, 0x63, 0xe2, 0xae, 0xfd, 0x68, 0x4b, 0x52, 0xe4, 0x8c,
	0x8c, 0x90, 0x94, 0x85, 0x60, 0xa0, 0x66, 0x0f, 0x3f, 0x7c, 0xef, 0x5c, 0xb2, 0x29, 0x75, 0x43,
	0x08, 0x44, 0xb1, 0x2b, 0xd5, 0xbe, 0x6f, 0x3d, 0xda, 0x72, 0x89, 0x0a, 0xa4, 0xac, 0x90, 0xd5,
	0x43, 0x91, 0xfe, 0xcf, 0x69, 0xb8, 0x9d, 0xd4, 0xe7, 0xa3, 0x0d, 0x98, 0x8b, 0x1a, 0x7a, 0x18,
	0x1f, 0x24, 0x8d, 0xb6, 0xf2, 0x11, 0x0e, 0x1d, 0xc2, 0x42, 0x34, 0x53, 0xe0, 0x7d, 0x3f, 0x6a,
	0xb0, 0xde, 0xf9, 0xe1, 0x81, 0x42, 0x24, 0x6c, 0xf6, 0x7d, 0x62, 0x64, 0x9d, 0xf8, 0x07, 0xfa,
	0x14, 0x72, 0x1d, 0xce, 0x7d, 0x66, 0x46, 0x37, 0xd3, 0xc2, 0xa5, 0x37, 0xd3, 0x82, 0x34, 0xa8,
	0xa8, 0xeb, 0x69, 0x0d, 0x0a, 0x2e, 0xc5, 0xb6, 0xd9, 0xc2, 0x2e, 0xf6, 0x2c, 0x12, 0x98, 0x8e,
	0x2f, 0xfb, 0x8e, 0x8c, 0x91, 0x17, 0xf2, 0x1d, 0x25, 0x3e, 0xf0, 0xd1, 0x63, 0x78, 0x75, 0x14,
	0x19, 0x3a, 0xb2, 0x19, 0x60, 0xaf, 0x4d, 0x44, 0x97, 0x91, 0x5e, 0xcb, 0x18, 0xda, 0xb0, 0x51,
	0x43, 0x02, 0x0c, 0xa9, 0x17, 0xe7, 0x3c, 0x98, 0x5e, 0x38, 0x3e, 0xd3, 0x16, 0x25, 0x3e, 0x1b,
	0xc9, 0x0e, 0x7c, 0x26, 0x9b, 0x0a, 0x3b, 0xde, 0xca, 0x55, 0x9a, 0x0a, 0x7b, 0xb0, 0x91, 0xef,
	0xe0, 0x4e, 0xc4, 0x35, 0xd2, 0x75, 0xca, 0xbe, 0x22, 0xbf, 0xb9, 0x75, 0xc9, 0x09, 0x57, 0x92,
	0x6c, 0x8d, 0x64, 0x4a, 0x7d, 0x0d, 0xb2, 0x43, 0x5f, 0x44, 0x5c, 0x1b, 0x07, 0x8d, 0xe6, 0x41,
	0xad, 0x70, 0x0b, 0xe5, 0x01, 0xbe, 0x3c, 0xde, 0xa9, 0x18, 0x47, 0x95, 0x66, 0xa5, 0x51, 0x48,
	0xe9, 0x1f, 0xc2, 0x9d, 0x44, 0xe6, 0xd1, 0x9b, 0xa8, 0x5a, 0xdb, 0x2d, 0x57, 0x0b, 0x29, 0x94,
	0x85, 0xb9, 0xdd, 0xea, 0x71, 0xa3, 0x59, 0x31, 0x0a, 0x53, 0xfa, 0x13, 0x58, 0xae, 0xfc, 0x28,
	0x3e, 0xa7, 0xf7, 0xa1, 0x58, 0x1d, 0x7c, 0x16, 0xc7, 0x6b, 0xbf, 0xb0, 0x13, 0x27, 0x39, 0x4d,
	0x36, 0xc9, 0x69, 0xf4, 0x6f, 0x21, 0x37, 0xfa, 0xb6, 0x1b, 0x57, 0xfb, 0x08, 0xa6, 0x65, 0xc0,
	0x84, 0x29, 0x4d, 0x3e, 0xeb, 0xbf, 0x4a, 0x41, 0x7e, 0x74, 0xdc, 0x25, 0x2e, 0xc6, 0x2e, 0xf6,
	0x9c, 0x13, 0xc2, 0xf8, 0xf0, 0x7c, 0x75, 0x21, 0x12, 0xca, 0xc9, 0xea, 0x0f, 0xd7, 0x64, 0x25,
	0x35, 0x1b, 0xb6, 0x95, 0xff, 0x5d, 0x9c, 0x17, 0x25, 0x4e, 0xff, 0x6b, 0x0a, 0x0a, 0xe3, 0x2a,
	0xb4, 0x0b, 0xe0, 0x63, 0x6e, 0x75, 0xc2, 0x28, 0x4f, 0x49, 0x1f, 0x7c, 0x70, 0x31, 0x55, 0xa9,
	0x2e, 0xc0, 0x32, 0xbe, 0x33, 0x7e, 0xf4, 0x88, 0xde, 0x85, 0x29, 0xea, 0xcb, 0x05, 0xe6, 0x87,
	0x67, 0x85, 0x13, 0xc6, 0x35, 0xdf, 0x98, 0xa2, 0xbe, 0xfe, 0x00, 0x32, 0x03, 0x1a, 0x94, 0x83,
	0x4c, 0xa3, 0x69, 0x94, 0x9b, 0x95, 0xfd, 0x83, 0xdd, 0xc2, 0x2d, 0xe1, 0x6f, 0x5f, 0x34, 0x6a,
	0x47, 0x85, 0x94, 0xbe, 0x01, 0x53, 0x35, 0x1f, 0xcd, 0x41, 0xba, 0xbc, 0xb7, 0x57, 0xb8, 0x85,
	0x00, 0x66, 0x8d, 0xca, 0x61, 0xed, 0x69, 0x25, 0xf4, 0x3f, 0xa3, 0x52, 0xaf, 0x96, 0x77, 0x2b,
	0x61, 0x31, 0x74, 0x58, 0x31, 0xf6, 0x2b, 0x85, 0xb4, 0xfe, 0xfb, 0x19, 0x58, 0x1c, 0x9b, 0x74,
	0xa3, 0xa7, 0x89, 0xf3, 0xe3, 0xf0, 0xa3, 0xbe, 0x75, 0xe1, 0x80, 0xbc, 0xf4, 0x94, 0x04, 0xcc,
	0xa1, 0x9e, 0x1a, 0x97, 0x27, 0x4c, 0x91, 0x8d, 0x84, 0x29, 0xf2, 0xd4, 0xf5, 0x58, 0x27, 0xa6,
	0xc9, 0xbb, 0x43, 0xd3, 0xe4, 0xf4, 0xf5, 0xb8, 0xe2, 0xe1, 0x72, 0x33, 0x69, 0xb8, 0x3c, 0x7d,
	0x3d, 0xb6, 0xc9, 0x19, 0x73, 0x7d, 0x72, 0xc6, 0x3c, 0x23, 0xef, 0xe3, 0x2b, 0x73, 0x8e, 0x0f,
	0x9b, 0x8f, 0x26, 0x86, 0xcd, 0xb3, 0xd7, 0x23, 0x1c, 0x1d, 0x3b, 0x17, 0x2d, 0xc8, 0x8d, 0xe8,
	0x91, 0x06, 0x73, 0x67, 0xa1, 0x40, 0x05, 0x57, 0xf4, 0x13, 0x6d, 0x0f, 0xfe, 0x28, 0x09, 0x7d,
	0x76, 0xf5, 0xe2, 0x57, 0x8e, 0xfd, 0x5f, 0xb2, 0x0d, 0xb3, 0x8a, 0x3d, 0x4e, 0x8c, 0x0b, 0x30,
	0x7f, 0x5c, 0xdf, 0x2b, 0x37, 0x0f, 0x8e, 0xf6, 0x43, 0xdf, 0x7c, 0x52, 0x29, 0x57, 0x9b, 0x4f,
	0x9e, 0x85, 0xbe, 0x19, 0x56, 0xef, 0x69, 0xfd, 0x5f, 0x29, 0xc8, 0x0c, 0x8a, 0x2a, 0x91, 0x5e,
	0x5c, 0xa7, 0xeb, 0x70, 0x51, 0x8b, 0xa7, 0x47, 0xd3, 0xcb, 0x00, 0x54, 0xaa, 0x4a, 0x44, 0x58,
	0xc9, 0x29, 0x38, 0x7a, 0x0c, 0xf3, 0x01, 0xf9, 0x45, 0x8f, 0x30, 0x2e, 0x16, 0x9f, 0x1e, 0xad,
	0x65, 0x63, 0x53, 0x43, 0x61, 0x42, 0xe3, 0x81, 0x49, 0xf1, 0x43, 0xc8, 0x0e, 0xb1, 0x5e, 0xab,
	0x9c, 0xf9, 0x18, 0x72, 0x23, 0xac, 0xd7, 0x6a, 0x6e, 0xfe, 0x98, 0x82, 0x57, 0x2e, 0xa8, 0xb4,
	0x65, 0x2a, 0x74, 0x3c, 0x13, 0x9f, 0x61, 0xc7, 0x15, 0x77, 0xa4, 0x2a, 0x8d, 0x16, 0xba, 0x8e,
	0x57, 0x8e, 0x64, 0xa8, 0x26, 0x42, 0x43, 0x95, 0xc4, 0x61, 0x98, 0x3d, 0x1c, 0xea, 0x11, 0x06,
	0xff, 0xd2, 0x95, 0xfc, 0xd3, 0xb6, 0x10, 0xb0, 0x52, 0x97, 0x70, 0x2c, 0xda, 0x85, 0x2a, 0x6e,
	0x11, 0x37, 0x2a, 0xe2, 0x8c, 0x01, 0x09, 0x7a, 0x0b, 0x16, 0xbb, 0xf8, 0xdc, 0xec, 0x79, 0xf1,
	0x7b, 0xc3, 0x92, 0x2a, 0xdf, 0xc5, 0xe7, 0xc7, 0xb1, 0x54, 0xff, 0x04, 0x20, 0xcc, 0x62, 0x87,
	0x84, 0x63, 0x91, 0xde, 0x65, 0xc5, 0x1a, 0xfe, 0x69, 0x25, 0x9f, 0x47, 0xd3, 0xf4, 0xec, 0x58,
	0x9a, 0xd6, 0xff, 0x3d, 0x03, 0xf3, 0x4d, 0xc2, 0xb8, 0xa8, 0xad, 0xd1, 0xbb, 0xc3, 0x7d, 0xf0,
	0xab, 0xc3, 0x73, 0xe1, 0x10, 0x30, 0xd6, 0xfa, 0x8e, 0x74, 0x6d, 0xf5, 0x9b, 0x76, 0x6d, 0x5f,
	0x5d, 0xb7, 0x6b, 0x1b, 0x6e, 0xc8, 0x9e, 0xbe, 0xe4, 0x86, 0xec, 0xeb, 0x17, 0x6a, 0xc8, 0x6a,
	0x93, 0x0d, 0xd9, 0x37, 0xf2, 0x6c, 0xff, 0x3f, 0xe1, 0x6c, 0xaf, 0xd2, 0x7f, 0x1d, 0x8c, 0xf7,
	0x5f, 0xdf, 0x4a, 0xba, 0x07, 0x09, 0x74, 0x97, 0xb5, 0x5b, 0x5f, 0xc0, 0xf2, 0xe9, 0x36, 0x33,
	0xa9, 0x74, 0x1e, 0x53, 0xb4, 0x26, 0x81, 0x63, 0x93, 0x2b, 0xb4, 0x31, 0x4b, 0x23, 0x12, 0x61,
	0x74, 0xe3, 0x69, 0xc4, 0xff, 0x40, 0x1f, 0xb4, 0x53, 0xf8, 0xd3, 0xf3, 0x95, 0xd4, 0x9f, 0x9f,
	0xaf, 0xa4, 0xfe, 0xf6, 0x7c, 0x25, 0xf5, 0xbb, 0xbf, 0xaf, 0xdc, 0x6a, 0xcd, 0xca, 0x1a, 0xf9,
	0xe1, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x62, 0x6d, 0x0d, 0xe7, 0xdd, 0x1f, 0x00, 0x00,
}

func (m *IstioInstaller) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IstioInstaller) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Spec.Size()))
		n1, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Status != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Status.Size()))
		n2, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InstallerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstallerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.InstallPackagePath) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.InstallPackagePath)))
		i += copy(dAtA[i:], m.InstallPackagePath)
	}
	if len(m.Hub) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Hub)))
		i += copy(dAtA[i:], m.Hub)
	}
	if len(m.Tag) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Tag)))
		i += copy(dAtA[i:], m.Tag)
	}
	if len(m.DefaultNamespacePrefix) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.DefaultNamespacePrefix)))
		i += copy(dAtA[i:], m.DefaultNamespacePrefix)
	}
	if m.TrafficManagement != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.TrafficManagement.Size()))
		n3, err := m.TrafficManagement.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.PolicyTelemetry != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.PolicyTelemetry.Size()))
		n4, err := m.PolicyTelemetry.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Security != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Security.Size()))
		n5, err := m.Security.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.ConfigManagement != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ConfigManagement.Size()))
		n6, err := m.ConfigManagement.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.IngressGateway) > 0 {
		for _, msg := range m.IngressGateway {
			dAtA[i] = 0xf2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EgressGateway) > 0 {
		for _, msg := range m.EgressGateway {
			dAtA[i] = 0xfa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ExternalOperators) > 0 {
		for _, msg := range m.ExternalOperators {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.K8SDefaults != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.K8SDefaults.Size()))
		n7, err := m.K8SDefaults.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TrafficManagementConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrafficManagementConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Enabled.Size()))
		n8, err := m.Enabled.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.ClusterDomain) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.ClusterDomain)))
		i += copy(dAtA[i:], m.ClusterDomain)
	}
	if m.Pilot != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Pilot.Size()))
		n9, err := m.Pilot.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Proxy != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Proxy.Size()))
		n10, err := m.Proxy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.SidecarInjector != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.SidecarInjector.Size()))
		n11, err := m.SidecarInjector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PolicyTelemetryConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyTelemetryConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PolicyCheckFailOpen != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.PolicyCheckFailOpen.Size()))
		n12, err := m.PolicyCheckFailOpen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.OutboundTrafficPolicyMode != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.OutboundTrafficPolicyMode))
	}
	if m.Policy != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Policy.Size()))
		n13, err := m.Policy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Telemetry != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Telemetry.Size()))
		n14, err := m.Telemetry.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SecurityConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Enabled.Size()))
		n15, err := m.Enabled.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if m.ControlPlaneMtls != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ControlPlaneMtls.Size()))
		n16, err := m.ControlPlaneMtls.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.DataPlaneMtls != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.DataPlaneMtls.Size()))
		n17, err := m.DataPlaneMtls.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.TrustDomain) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.TrustDomain)))
		i += copy(dAtA[i:], m.TrustDomain)
	}
	if m.SelfSigned != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.SelfSigned.Size()))
		n18, err := m.SelfSigned.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.CreateMeshPolicy != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.CreateMeshPolicy.Size()))
		n19, err := m.CreateMeshPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.Citadel != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Citadel.Size()))
		n20, err := m.Citadel.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.CertManager != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.CertManager.Size()))
		n21, err := m.CertManager.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.NodeAgent != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.NodeAgent.Size()))
		n22, err := m.NodeAgent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PilotComponentConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PilotComponentConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n23, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.Sidecar != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Sidecar.Size()))
		n24, err := m.Sidecar.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProxyComponentConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProxyComponentConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n25, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SidecarInjectorComponentConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SidecarInjectorComponentConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n26, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.EnableNamespacesByDefault != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.EnableNamespacesByDefault.Size()))
		n27, err := m.EnableNamespacesByDefault.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PolicyComponentConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyComponentConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n28, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TelemetryComponentConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TelemetryComponentConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n29, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CitadelComponentConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CitadelComponentConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n30, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CertManagerComponentConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertManagerComponentConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n31, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NodeAgentComponentConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeAgentComponentConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n32, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConfigManagementConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigManagementConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n33, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommonComponentConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommonComponentConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Enabled.Size()))
		n34, err := m.Enabled.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if m.Debug != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Debug))
	}
	if len(m.Env) > 0 {
		for k, _ := range m.Env {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x3
			i++
			v := m.Env[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Args) > 0 {
		for k, _ := range m.Args {
			dAtA[i] = 0xea
			i++
			dAtA[i] = 0x3
			i++
			v := m.Args[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.K8S != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.K8S.Size()))
		n35, err := m.K8S.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KubernetesResourcesConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesResourcesConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Resources != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Resources.Size()))
		n36, err := m.Resources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.ReadinessProbe != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ReadinessProbe.Size()))
		n37, err := m.ReadinessProbe.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.ReplicaCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ReplicaCount))
	}
	if m.HpaSpec != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.HpaSpec.Size()))
		n38, err := m.HpaSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.PodDisruptionBudget != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.PodDisruptionBudget.Size()))
		n39, err := m.PodDisruptionBudget.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if len(m.PodAnnotations) > 0 {
		for k, _ := range m.PodAnnotations {
			dAtA[i] = 0x32
			i++
			v := m.PodAnnotations[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.NodeSelector) > 0 {
		for k, _ := range m.NodeSelector {
			dAtA[i] = 0x3a
			i++
			v := m.NodeSelector[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.NodeAffinity != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.NodeAffinity.Size()))
		n40, err := m.NodeAffinity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if len(m.ImagePullPolicy) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.ImagePullPolicy)))
		i += copy(dAtA[i:], m.ImagePullPolicy)
	}
	if len(m.PriorityClassName) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.PriorityClassName)))
		i += copy(dAtA[i:], m.PriorityClassName)
	}
	if len(m.Overlays) > 0 {
		for _, msg := range m.Overlays {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KubernetesResourcesConfig_NodeAffinity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesResourcesConfig_NodeAffinity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ArchAmd64 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ArchAmd64))
	}
	if m.ArchS390X != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ArchS390X))
	}
	if m.ArchPpc64Le != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ArchPpc64Le))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *IngressGatewayConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngressGatewayConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Gateway != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Gateway.Size()))
		n41, err := m.Gateway.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.IngressType != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.IngressType))
	}
	if m.HttpsEnabled != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.HttpsEnabled.Size()))
		n42, err := m.HttpsEnabled.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if len(m.LoadBalancerIp) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.LoadBalancerIp)))
		i += copy(dAtA[i:], m.LoadBalancerIp)
	}
	if len(m.LoadBalancerSourceRanges) > 0 {
		for _, s := range m.LoadBalancerSourceRanges {
			dAtA[i] = 0x72
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ExternalIps) > 0 {
		for _, s := range m.ExternalIps {
			dAtA[i] = 0x7a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.SdsEnabled != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.SdsEnabled.Size()))
		n43, err := m.SdsEnabled.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.ExternalTrafficPolicy != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ExternalTrafficPolicy))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EgressGatewayConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EgressGatewayConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Gateway != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Gateway.Size()))
		n44, err := m.Gateway.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LoadBalancingGatewayConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadBalancingGatewayConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Gateway != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Gateway.Size()))
		n45, err := m.Gateway.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if len(m.LoadBalancerIp) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.LoadBalancerIp)))
		i += copy(dAtA[i:], m.LoadBalancerIp)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GatewayConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GatewayConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n46, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OperatorConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperatorConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ManifestPath) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.ManifestPath)))
		i += copy(dAtA[i:], m.ManifestPath)
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if m.Spec != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Spec.Size()))
		n47, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *K8SObjectOverlay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SObjectOverlay) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PatchType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.PatchType))
	}
	if m.Op != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Op))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InstallerStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstallerStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TrafficManagement != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.TrafficManagement.Size()))
		n48, err := m.TrafficManagement.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	if m.PolicyTelemetry != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.PolicyTelemetry.Size()))
		n49, err := m.PolicyTelemetry.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if m.Security != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Security.Size()))
		n50, err := m.Security.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.ConfigManagement != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ConfigManagement.Size()))
		n51, err := m.ConfigManagement.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if len(m.IngressGateway) > 0 {
		for _, msg := range m.IngressGateway {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EgressGateway) > 0 {
		for _, msg := range m.EgressGateway {
			dAtA[i] = 0x32
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InstallerStatus_VersionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstallerStatus_VersionStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Resources) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resources) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Limits) > 0 {
		for k, _ := range m.Limits {
			dAtA[i] = 0xa
			i++
			v := m.Limits[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Requests) > 0 {
		for k, _ := range m.Requests {
			dAtA[i] = 0x12
			i++
			v := m.Requests[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PodDisruptionBudgetSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodDisruptionBudgetSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MinAvailable != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.MinAvailable))
	}
	if m.Selector != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Selector.Size()))
		n52, err := m.Selector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if m.MaxUnavailable != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.MaxUnavailable))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ObjectMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TestKube) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestKube) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Env) > 0 {
		for k, _ := range m.Env {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x3
			i++
			v := m.Env[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Resources != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Resources.Size()))
		n53, err := m.Resources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if m.ReadinessProbe != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ReadinessProbe.Size()))
		n54, err := m.ReadinessProbe.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if m.HpaSpec != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.HpaSpec.Size()))
		n55, err := m.HpaSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	if m.PodDisruptionBudget != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.PodDisruptionBudget.Size()))
		n56, err := m.PodDisruptionBudget.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if len(m.PodAnnotations) > 0 {
		for k, _ := range m.PodAnnotations {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x5
			i++
			v := m.PodAnnotations[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.NodeSelector) > 0 {
		for k, _ := range m.NodeSelector {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x5
			i++
			v := m.NodeSelector[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.K8SObjectOverride) > 0 {
		for _, msg := range m.K8SObjectOverride {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintIstioinstallerTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *IstioInstaller) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InstallerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InstallPackagePath)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.Hub)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.DefaultNamespacePrefix)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.TrafficManagement != nil {
		l = m.TrafficManagement.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.PolicyTelemetry != nil {
		l = m.PolicyTelemetry.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Security != nil {
		l = m.Security.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ConfigManagement != nil {
		l = m.ConfigManagement.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.IngressGateway) > 0 {
		for _, e := range m.IngressGateway {
			l = e.Size()
			n += 2 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if len(m.EgressGateway) > 0 {
		for _, e := range m.EgressGateway {
			l = e.Size()
			n += 2 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if len(m.ExternalOperators) > 0 {
		for _, e := range m.ExternalOperators {
			l = e.Size()
			n += 2 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if m.K8SDefaults != nil {
		l = m.K8SDefaults.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TrafficManagementConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.ClusterDomain)
	if l > 0 {
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Pilot != nil {
		l = m.Pilot.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Proxy != nil {
		l = m.Proxy.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.SidecarInjector != nil {
		l = m.SidecarInjector.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PolicyTelemetryConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PolicyCheckFailOpen != nil {
		l = m.PolicyCheckFailOpen.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.OutboundTrafficPolicyMode != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.OutboundTrafficPolicyMode))
	}
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Telemetry != nil {
		l = m.Telemetry.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ControlPlaneMtls != nil {
		l = m.ControlPlaneMtls.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.DataPlaneMtls != nil {
		l = m.DataPlaneMtls.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.TrustDomain)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.SelfSigned != nil {
		l = m.SelfSigned.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.CreateMeshPolicy != nil {
		l = m.CreateMeshPolicy.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Citadel != nil {
		l = m.Citadel.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.CertManager != nil {
		l = m.CertManager.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.NodeAgent != nil {
		l = m.NodeAgent.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PilotComponentConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Sidecar != nil {
		l = m.Sidecar.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProxyComponentConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SidecarInjectorComponentConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.EnableNamespacesByDefault != nil {
		l = m.EnableNamespacesByDefault.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PolicyComponentConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TelemetryComponentConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CitadelComponentConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CertManagerComponentConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeAgentComponentConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigManagementConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommonComponentConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Debug != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.Debug))
	}
	if len(m.Env) > 0 {
		for k, v := range m.Env {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Args) > 0 {
		for k, v := range m.Args {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if m.K8S != nil {
		l = m.K8S.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KubernetesResourcesConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ReadinessProbe != nil {
		l = m.ReadinessProbe.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ReplicaCount != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.ReplicaCount))
	}
	if m.HpaSpec != nil {
		l = m.HpaSpec.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.PodDisruptionBudget != nil {
		l = m.PodDisruptionBudget.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.PodAnnotations) > 0 {
		for k, v := range m.PodAnnotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if len(m.NodeSelector) > 0 {
		for k, v := range m.NodeSelector {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if m.NodeAffinity != nil {
		l = m.NodeAffinity.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.ImagePullPolicy)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.PriorityClassName)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.Overlays) > 0 {
		for _, e := range m.Overlays {
			l = e.Size()
			n += 2 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KubernetesResourcesConfig_NodeAffinity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ArchAmd64 != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.ArchAmd64))
	}
	if m.ArchS390X != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.ArchS390X))
	}
	if m.ArchPpc64Le != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.ArchPpc64Le))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IngressGatewayConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gateway != nil {
		l = m.Gateway.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.IngressType != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.IngressType))
	}
	if m.HttpsEnabled != nil {
		l = m.HttpsEnabled.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.LoadBalancerIp)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.LoadBalancerSourceRanges) > 0 {
		for _, s := range m.LoadBalancerSourceRanges {
			l = len(s)
			n += 1 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if len(m.ExternalIps) > 0 {
		for _, s := range m.ExternalIps {
			l = len(s)
			n += 1 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if m.SdsEnabled != nil {
		l = m.SdsEnabled.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ExternalTrafficPolicy != 0 {
		n += 2 + sovIstioinstallerTypes(uint64(m.ExternalTrafficPolicy))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EgressGatewayConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gateway != nil {
		l = m.Gateway.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoadBalancingGatewayConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gateway != nil {
		l = m.Gateway.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.LoadBalancerIp)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GatewayConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OperatorConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ManifestPath)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *K8SObjectOverlay) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PatchType != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.PatchType))
	}
	if m.Op != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.Op))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InstallerStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TrafficManagement != nil {
		l = m.TrafficManagement.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.PolicyTelemetry != nil {
		l = m.PolicyTelemetry.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Security != nil {
		l = m.Security.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ConfigManagement != nil {
		l = m.ConfigManagement.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.IngressGateway) > 0 {
		for _, e := range m.IngressGateway {
			l = e.Size()
			n += 1 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if len(m.EgressGateway) > 0 {
		for _, e := range m.EgressGateway {
			l = e.Size()
			n += 1 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InstallerStatus_VersionStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Resources) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Limits) > 0 {
		for k, v := range m.Limits {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Requests) > 0 {
		for k, v := range m.Requests {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PodDisruptionBudgetSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinAvailable != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.MinAvailable))
	}
	if m.Selector != nil {
		l = m.Selector.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.MaxUnavailable != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.MaxUnavailable))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestKube) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Env) > 0 {
		for k, v := range m.Env {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ReadinessProbe != nil {
		l = m.ReadinessProbe.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.HpaSpec != nil {
		l = m.HpaSpec.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.PodDisruptionBudget != nil {
		l = m.PodDisruptionBudget.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.PodAnnotations) > 0 {
		for k, v := range m.PodAnnotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if len(m.NodeSelector) > 0 {
		for k, v := range m.NodeSelector {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if len(m.K8SObjectOverride) > 0 {
		for _, e := range m.K8SObjectOverride {
			l = e.Size()
			n += 2 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovIstioinstallerTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozIstioinstallerTypes(x uint64) (n int) {
	return sovIstioinstallerTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *IstioInstaller) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IstioInstaller: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IstioInstaller: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &InstallerSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &InstallerStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstallerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstallerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstallerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstallPackagePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstallPackagePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hub", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hub = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultNamespacePrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultNamespacePrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficManagement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrafficManagement == nil {
				m.TrafficManagement = &TrafficManagementConfig{}
			}
			if err := m.TrafficManagement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyTelemetry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PolicyTelemetry == nil {
				m.PolicyTelemetry = &PolicyTelemetryConfig{}
			}
			if err := m.PolicyTelemetry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Security", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Security == nil {
				m.Security = &SecurityConfig{}
			}
			if err := m.Security.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigManagement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigManagement == nil {
				m.ConfigManagement = &ConfigManagementConfig{}
			}
			if err := m.ConfigManagement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngressGateway = append(m.IngressGateway, &IngressGatewayConfig{})
			if err := m.IngressGateway[len(m.IngressGateway)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgressGateway = append(m.EgressGateway, &EgressGatewayConfig{})
			if err := m.EgressGateway[len(m.EgressGateway)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalOperators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalOperators = append(m.ExternalOperators, &OperatorConfig{})
			if err := m.ExternalOperators[len(m.ExternalOperators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 80:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8SDefaults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.K8SDefaults == nil {
				m.K8SDefaults = &KubernetesResourcesConfig{}
			}
			if err := m.K8SDefaults.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrafficManagementConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrafficManagementConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrafficManagementConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &protobuf.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pilot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pilot == nil {
				m.Pilot = &PilotComponentConfig{}
			}
			if err := m.Pilot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proxy == nil {
				m.Proxy = &ProxyComponentConfig{}
			}
			if err := m.Proxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SidecarInjector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SidecarInjector == nil {
				m.SidecarInjector = &SidecarInjectorComponentConfig{}
			}
			if err := m.SidecarInjector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyTelemetryConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyTelemetryConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyTelemetryConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyCheckFailOpen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PolicyCheckFailOpen == nil {
				m.PolicyCheckFailOpen = &protobuf.BoolValue{}
			}
			if err := m.PolicyCheckFailOpen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutboundTrafficPolicyMode", wireType)
			}
			m.OutboundTrafficPolicyMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutboundTrafficPolicyMode |= PolicyTelemetryConfig_OutboundPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &PolicyComponentConfig{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Telemetry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Telemetry == nil {
				m.Telemetry = &TelemetryComponentConfig{}
			}
			if err := m.Telemetry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &protobuf.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlPlaneMtls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ControlPlaneMtls == nil {
				m.ControlPlaneMtls = &protobuf.BoolValue{}
			}
			if err := m.ControlPlaneMtls.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataPlaneMtls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataPlaneMtls == nil {
				m.DataPlaneMtls = &protobuf.BoolValue{}
			}
			if err := m.DataPlaneMtls.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfSigned", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SelfSigned == nil {
				m.SelfSigned = &protobuf.BoolValue{}
			}
			if err := m.SelfSigned.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateMeshPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateMeshPolicy == nil {
				m.CreateMeshPolicy = &protobuf.BoolValue{}
			}
			if err := m.CreateMeshPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Citadel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Citadel == nil {
				m.Citadel = &CitadelComponentConfig{}
			}
			if err := m.Citadel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertManager", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CertManager == nil {
				m.CertManager = &CertManagerComponentConfig{}
			}
			if err := m.CertManager.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAgent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeAgent == nil {
				m.NodeAgent = &NodeAgentComponentConfig{}
			}
			if err := m.NodeAgent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PilotComponentConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PilotComponentConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PilotComponentConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentConfig{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sidecar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sidecar == nil {
				m.Sidecar = &protobuf.BoolValue{}
			}
			if err := m.Sidecar.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProxyComponentConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProxyComponentConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProxyComponentConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentConfig{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SidecarInjectorComponentConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SidecarInjectorComponentConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SidecarInjectorComponentConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentConfig{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableNamespacesByDefault", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnableNamespacesByDefault == nil {
				m.EnableNamespacesByDefault = &protobuf.BoolValue{}
			}
			if err := m.EnableNamespacesByDefault.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyComponentConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyComponentConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyComponentConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentConfig{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TelemetryComponentConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TelemetryComponentConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TelemetryComponentConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentConfig{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CitadelComponentConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CitadelComponentConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CitadelComponentConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentConfig{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertManagerComponentConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertManagerComponentConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertManagerComponentConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentConfig{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeAgentComponentConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeAgentComponentConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeAgentComponentConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentConfig{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigManagementConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigManagementConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigManagementConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentConfig{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommonComponentConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommonComponentConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommonComponentConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &protobuf.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			m.Debug = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Debug |= CommonComponentConfig_LogLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Env == nil {
				m.Env = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Env[mapkey] = mapvalue
			iNdEx = postIndex
		case 61:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Args == nil {
				m.Args = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Args[mapkey] = mapvalue
			iNdEx = postIndex
		case 80:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8S", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.K8S == nil {
				m.K8S = &KubernetesResourcesConfig{}
			}
			if err := m.K8S.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesResourcesConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubernetesResourcesConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubernetesResourcesConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &Resources{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadinessProbe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadinessProbe == nil {
				m.ReadinessProbe = &v1.Probe{}
			}
			if err := m.ReadinessProbe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaCount", wireType)
			}
			m.ReplicaCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HpaSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HpaSpec == nil {
				m.HpaSpec = &v11.HorizontalPodAutoscalerSpec{}
			}
			if err := m.HpaSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodDisruptionBudget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodDisruptionBudget == nil {
				m.PodDisruptionBudget = &PodDisruptionBudgetSpec{}
			}
			if err := m.PodDisruptionBudget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodAnnotations == nil {
				m.PodAnnotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PodAnnotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeSelector == nil {
				m.NodeSelector = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeSelector[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAffinity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeAffinity == nil {
				m.NodeAffinity = &KubernetesResourcesConfig_NodeAffinity{}
			}
			if err := m.NodeAffinity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePullPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImagePullPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriorityClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriorityClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Overlays", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Overlays = append(m.Overlays, &K8SObjectOverlay{})
			if err := m.Overlays[len(m.Overlays)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesResourcesConfig_NodeAffinity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeAffinity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeAffinity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArchAmd64", wireType)
			}
			m.ArchAmd64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArchAmd64 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArchS390X", wireType)
			}
			m.ArchS390X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArchS390X |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArchPpc64Le", wireType)
			}
			m.ArchPpc64Le = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArchPpc64Le |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngressGatewayConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngressGatewayConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngressGatewayConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gateway == nil {
				m.Gateway = &GatewayConfig{}
			}
			if err := m.Gateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressType", wireType)
			}
			m.IngressType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IngressType |= IngressGatewayConfig_IngressType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpsEnabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpsEnabled == nil {
				m.HttpsEnabled = &protobuf.BoolValue{}
			}
			if err := m.HttpsEnabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancerIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadBalancerIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancerSourceRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadBalancerSourceRanges = append(m.LoadBalancerSourceRanges, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalIps", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalIps = append(m.ExternalIps, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SdsEnabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SdsEnabled == nil {
				m.SdsEnabled = &protobuf.BoolValue{}
			}
			if err := m.SdsEnabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalTrafficPolicy", wireType)
			}
			m.ExternalTrafficPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalTrafficPolicy |= IngressGatewayConfig_ExternalTrafficPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EgressGatewayConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EgressGatewayConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EgressGatewayConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gateway == nil {
				m.Gateway = &GatewayConfig{}
			}
			if err := m.Gateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadBalancingGatewayConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadBalancingGatewayConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadBalancingGatewayConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gateway == nil {
				m.Gateway = &GatewayConfig{}
			}
			if err := m.Gateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancerIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadBalancerIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GatewayConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GatewayConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GatewayConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentConfig{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperatorConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperatorConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperatorConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManifestPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManifestPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &K8SObjectOverlay{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SObjectOverlay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: k8sObjectOverlay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: k8sObjectOverlay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatchType", wireType)
			}
			m.PatchType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PatchType |= K8SObjectOverlay_PatchType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= K8SObjectOverlay_Op(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstallerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstallerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstallerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficManagement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrafficManagement == nil {
				m.TrafficManagement = &InstallerStatus_VersionStatus{}
			}
			if err := m.TrafficManagement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyTelemetry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PolicyTelemetry == nil {
				m.PolicyTelemetry = &InstallerStatus_VersionStatus{}
			}
			if err := m.PolicyTelemetry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Security", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Security == nil {
				m.Security = &InstallerStatus_VersionStatus{}
			}
			if err := m.Security.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigManagement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigManagement == nil {
				m.ConfigManagement = &InstallerStatus_VersionStatus{}
			}
			if err := m.ConfigManagement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngressGateway = append(m.IngressGateway, &InstallerStatus_VersionStatus{})
			if err := m.IngressGateway[len(m.IngressGateway)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgressGateway = append(m.EgressGateway, &InstallerStatus_VersionStatus{})
			if err := m.EgressGateway[len(m.EgressGateway)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstallerStatus_VersionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= InstallerStatus_Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resources) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Resources: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Resources: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limits == nil {
				m.Limits = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Limits[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Requests == nil {
				m.Requests = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Requests[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodDisruptionBudgetSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodDisruptionBudgetSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodDisruptionBudgetSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAvailable", wireType)
			}
			m.MinAvailable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinAvailable |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Selector == nil {
				m.Selector = &v12.LabelSelector{}
			}
			if err := m.Selector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUnavailable", wireType)
			}
			m.MaxUnavailable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxUnavailable |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestKube) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestKube: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestKube: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Env == nil {
				m.Env = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Env[mapkey] = mapvalue
			iNdEx = postIndex
		case 80:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &Resources{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 81:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadinessProbe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadinessProbe == nil {
				m.ReadinessProbe = &v1.Probe{}
			}
			if err := m.ReadinessProbe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 86:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HpaSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HpaSpec == nil {
				m.HpaSpec = &v11.HorizontalPodAutoscalerSpec{}
			}
			if err := m.HpaSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 87:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodDisruptionBudget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodDisruptionBudget == nil {
				m.PodDisruptionBudget = &PodDisruptionBudgetSpec{}
			}
			if err := m.PodDisruptionBudget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 90:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodAnnotations == nil {
				m.PodAnnotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PodAnnotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 92:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeSelector == nil {
				m.NodeSelector = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeSelector[mapkey] = mapvalue
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8SObjectOverride", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.K8SObjectOverride = append(m.K8SObjectOverride, &K8SObjectOverlay{})
			if err := m.K8SObjectOverride[len(m.K8SObjectOverride)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipIstioinstallerTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthIstioinstallerTypes
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthIstioinstallerTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipIstioinstallerTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthIstioinstallerTypes
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthIstioinstallerTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowIstioinstallerTypes   = fmt.Errorf("proto: integer overflow")
)
