// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: istioinstaller_types.proto

package v1alpha1

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	v1 "k8s.io/api/autoscaling/v1"
	v11 "k8s.io/api/core/v1"
	v12 "k8s.io/apimachinery/pkg/apis/meta/v1"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ProxyConfig_InterceptionMode int32

const (
	ProxyConfig_REDIRECT ProxyConfig_InterceptionMode = 0
	ProxyConfig_TPROXY   ProxyConfig_InterceptionMode = 1
)

var ProxyConfig_InterceptionMode_name = map[int32]string{
	0: "REDIRECT",
	1: "TPROXY",
}

var ProxyConfig_InterceptionMode_value = map[string]int32{
	"REDIRECT": 0,
	"TPROXY":   1,
}

func (x ProxyConfig_InterceptionMode) Enum() *ProxyConfig_InterceptionMode {
	p := new(ProxyConfig_InterceptionMode)
	*p = x
	return p
}

func (x ProxyConfig_InterceptionMode) String() string {
	return proto.EnumName(ProxyConfig_InterceptionMode_name, int32(x))
}

func (x *ProxyConfig_InterceptionMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ProxyConfig_InterceptionMode_value, data, "ProxyConfig_InterceptionMode")
	if err != nil {
		return err
	}
	*x = ProxyConfig_InterceptionMode(value)
	return nil
}

func (ProxyConfig_InterceptionMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{5, 0}
}

type TelemetryConfig_LoadSheddingMode int32

const (
	TelemetryConfig_ENFORCE  TelemetryConfig_LoadSheddingMode = 0
	TelemetryConfig_LOGONLY  TelemetryConfig_LoadSheddingMode = 1
	TelemetryConfig_DISABLED TelemetryConfig_LoadSheddingMode = 2
)

var TelemetryConfig_LoadSheddingMode_name = map[int32]string{
	0: "ENFORCE",
	1: "LOGONLY",
	2: "DISABLED",
}

var TelemetryConfig_LoadSheddingMode_value = map[string]int32{
	"ENFORCE":  0,
	"LOGONLY":  1,
	"DISABLED": 2,
}

func (x TelemetryConfig_LoadSheddingMode) Enum() *TelemetryConfig_LoadSheddingMode {
	p := new(TelemetryConfig_LoadSheddingMode)
	*p = x
	return p
}

func (x TelemetryConfig_LoadSheddingMode) String() string {
	return proto.EnumName(TelemetryConfig_LoadSheddingMode_name, int32(x))
}

func (x *TelemetryConfig_LoadSheddingMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TelemetryConfig_LoadSheddingMode_value, data, "TelemetryConfig_LoadSheddingMode")
	if err != nil {
		return err
	}
	*x = TelemetryConfig_LoadSheddingMode(value)
	return nil
}

func (TelemetryConfig_LoadSheddingMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{7, 0}
}

type ResourceOverride_PatchType int32

const (
	ResourceOverride_STRATEGIC ResourceOverride_PatchType = 0
	ResourceOverride_JSON      ResourceOverride_PatchType = 1
)

var ResourceOverride_PatchType_name = map[int32]string{
	0: "STRATEGIC",
	1: "JSON",
}

var ResourceOverride_PatchType_value = map[string]int32{
	"STRATEGIC": 0,
	"JSON":      1,
}

func (x ResourceOverride_PatchType) Enum() *ResourceOverride_PatchType {
	p := new(ResourceOverride_PatchType)
	*p = x
	return p
}

func (x ResourceOverride_PatchType) String() string {
	return proto.EnumName(ResourceOverride_PatchType_name, int32(x))
}

func (x *ResourceOverride_PatchType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ResourceOverride_PatchType_value, data, "ResourceOverride_PatchType")
	if err != nil {
		return err
	}
	*x = ResourceOverride_PatchType(value)
	return nil
}

func (ResourceOverride_PatchType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{18, 0}
}

type ResourceOverride_Op int32

const (
	ResourceOverride_ADD    ResourceOverride_Op = 0
	ResourceOverride_DELETE ResourceOverride_Op = 1
	ResourceOverride_PATCH  ResourceOverride_Op = 2
)

var ResourceOverride_Op_name = map[int32]string{
	0: "ADD",
	1: "DELETE",
	2: "PATCH",
}

var ResourceOverride_Op_value = map[string]int32{
	"ADD":    0,
	"DELETE": 1,
	"PATCH":  2,
}

func (x ResourceOverride_Op) Enum() *ResourceOverride_Op {
	p := new(ResourceOverride_Op)
	*p = x
	return p
}

func (x ResourceOverride_Op) String() string {
	return proto.EnumName(ResourceOverride_Op_name, int32(x))
}

func (x *ResourceOverride_Op) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ResourceOverride_Op_value, data, "ResourceOverride_Op")
	if err != nil {
		return err
	}
	*x = ResourceOverride_Op(value)
	return nil
}

func (ResourceOverride_Op) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{18, 1}
}

// InstallerSpec defines the desired state of IstioInstaller.
type InstallerSpec struct {
	// install_package_path is the URL for the install package to install e.g.
	//   http://github.com/istio/istio/releases/install/1.1.2
	//   http://github.com/istio/istio/releases/install/lts
	//   file://tmp/istio-installer/nightly
	// Optional. Uses compiled in install package by default.
	InstallPackagePath *string `protobuf:"bytes,1,opt,name=install_package_path,json=installPackagePath" json:"install_package_path,omitempty"`
	// controller_name binds the CR to the install controller
	// that should listen to it. Used when multiple versions of controllers
	// coexist in a cluster and to prevent old versions of controller from
	// consuming new version of config.
	ControllerName *string `protobuf:"bytes,2,opt,name=controller_name,json=controllerName" json:"controller_name,omitempty"`
	// hub is the root for docker images e.g. docker.io/istio-release.
	Hub *string `protobuf:"bytes,3,opt,name=hub" json:"hub,omitempty"`
	// tag is the version tag for docker images e.g. 1.0.6
	Tag *string `protobuf:"bytes,4,opt,name=tag" json:"tag,omitempty"`
	// default_namespace_prefix is the prefix added to all namespaces for any installed component. Required.
	DefaultNamespacePrefix *string `protobuf:"bytes,5,opt,name=default_namespace_prefix,json=defaultNamespacePrefix" json:"default_namespace_prefix,omitempty"`
	// remote_cluster_config configures the cluster as a remote cluster.
	RemoteClusterConfig *RemoteClusterConfig `protobuf:"bytes,10,opt,name=remote_cluster_config,json=remoteClusterConfig" json:"remote_cluster_config,omitempty"`
	// Selection and configuration of core Istio features.
	TrafficManagement *TrafficManagementConfig `protobuf:"bytes,20,opt,name=traffic_management,json=trafficManagement" json:"traffic_management,omitempty"`
	Policy            *PolicyConfig            `protobuf:"bytes,21,opt,name=policy" json:"policy,omitempty"`
	Telemetry         *TelemetryConfig         `protobuf:"bytes,22,opt,name=telemetry" json:"telemetry,omitempty"`
	Security          *SecurityConfig          `protobuf:"bytes,23,opt,name=security" json:"security,omitempty"`
	ConfigManagement  *ConfigManagementConfig  `protobuf:"bytes,24,opt,name=config_management,json=configManagement" json:"config_management,omitempty"`
	// Ingress/egress gateway installation and configuration.
	IngressGateway []*IngressGatewayConfig `protobuf:"bytes,30,rep,name=ingress_gateway,json=ingressGateway" json:"ingress_gateway,omitempty"`
	EgressGateway  []*EgressGatewayConfig  `protobuf:"bytes,31,rep,name=egress_gateway,json=egressGateway" json:"egress_gateway,omitempty"`
	// List of external operators that will be installed (but not managed by)
	// IstioInstaller e.g. prometheus, grafana, kiali.
	ExternalOperators    []*OperatorConfig `protobuf:"bytes,50,rep,name=external_operators,json=externalOperators" json:"external_operators,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *InstallerSpec) Reset()         { *m = InstallerSpec{} }
func (m *InstallerSpec) String() string { return proto.CompactTextString(m) }
func (*InstallerSpec) ProtoMessage()    {}
func (*InstallerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{0}
}
func (m *InstallerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstallerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstallerSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstallerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallerSpec.Merge(m, src)
}
func (m *InstallerSpec) XXX_Size() int {
	return m.Size()
}
func (m *InstallerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_InstallerSpec proto.InternalMessageInfo

func (m *InstallerSpec) GetInstallPackagePath() string {
	if m != nil && m.InstallPackagePath != nil {
		return *m.InstallPackagePath
	}
	return ""
}

func (m *InstallerSpec) GetControllerName() string {
	if m != nil && m.ControllerName != nil {
		return *m.ControllerName
	}
	return ""
}

func (m *InstallerSpec) GetHub() string {
	if m != nil && m.Hub != nil {
		return *m.Hub
	}
	return ""
}

func (m *InstallerSpec) GetTag() string {
	if m != nil && m.Tag != nil {
		return *m.Tag
	}
	return ""
}

func (m *InstallerSpec) GetDefaultNamespacePrefix() string {
	if m != nil && m.DefaultNamespacePrefix != nil {
		return *m.DefaultNamespacePrefix
	}
	return ""
}

func (m *InstallerSpec) GetRemoteClusterConfig() *RemoteClusterConfig {
	if m != nil {
		return m.RemoteClusterConfig
	}
	return nil
}

func (m *InstallerSpec) GetTrafficManagement() *TrafficManagementConfig {
	if m != nil {
		return m.TrafficManagement
	}
	return nil
}

func (m *InstallerSpec) GetPolicy() *PolicyConfig {
	if m != nil {
		return m.Policy
	}
	return nil
}

func (m *InstallerSpec) GetTelemetry() *TelemetryConfig {
	if m != nil {
		return m.Telemetry
	}
	return nil
}

func (m *InstallerSpec) GetSecurity() *SecurityConfig {
	if m != nil {
		return m.Security
	}
	return nil
}

func (m *InstallerSpec) GetConfigManagement() *ConfigManagementConfig {
	if m != nil {
		return m.ConfigManagement
	}
	return nil
}

func (m *InstallerSpec) GetIngressGateway() []*IngressGatewayConfig {
	if m != nil {
		return m.IngressGateway
	}
	return nil
}

func (m *InstallerSpec) GetEgressGateway() []*EgressGatewayConfig {
	if m != nil {
		return m.EgressGateway
	}
	return nil
}

func (m *InstallerSpec) GetExternalOperators() []*OperatorConfig {
	if m != nil {
		return m.ExternalOperators
	}
	return nil
}

// InstallerStatus defines the observed state of IstioInstaller.
// TODO: this needs more work. What do we want to observe?
type InstallerStatus struct {
	ProxyControl         *string  `protobuf:"bytes,1,opt,name=proxy_control,json=proxyControl" json:"proxy_control,omitempty"`
	SidecarInjector      *string  `protobuf:"bytes,2,opt,name=sidecar_injector,json=sidecarInjector" json:"sidecar_injector,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InstallerStatus) Reset()         { *m = InstallerStatus{} }
func (m *InstallerStatus) String() string { return proto.CompactTextString(m) }
func (*InstallerStatus) ProtoMessage()    {}
func (*InstallerStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{1}
}
func (m *InstallerStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstallerStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstallerStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstallerStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallerStatus.Merge(m, src)
}
func (m *InstallerStatus) XXX_Size() int {
	return m.Size()
}
func (m *InstallerStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallerStatus.DiscardUnknown(m)
}

var xxx_messageInfo_InstallerStatus proto.InternalMessageInfo

func (m *InstallerStatus) GetProxyControl() string {
	if m != nil && m.ProxyControl != nil {
		return *m.ProxyControl
	}
	return ""
}

func (m *InstallerStatus) GetSidecarInjector() string {
	if m != nil && m.SidecarInjector != nil {
		return *m.SidecarInjector
	}
	return ""
}

// RemoteClusterConfig defines configuration options for remote clusters.
type RemoteClusterConfig struct {
	// Enabled selects whether the cluster is configured as remote.
	Enabled              *bool    `protobuf:"varint,1,opt,name=enabled" json:"enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoteClusterConfig) Reset()         { *m = RemoteClusterConfig{} }
func (m *RemoteClusterConfig) String() string { return proto.CompactTextString(m) }
func (*RemoteClusterConfig) ProtoMessage()    {}
func (*RemoteClusterConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{2}
}
func (m *RemoteClusterConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteClusterConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoteClusterConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoteClusterConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteClusterConfig.Merge(m, src)
}
func (m *RemoteClusterConfig) XXX_Size() int {
	return m.Size()
}
func (m *RemoteClusterConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteClusterConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteClusterConfig proto.InternalMessageInfo

func (m *RemoteClusterConfig) GetEnabled() bool {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return false
}

// TrafficManagementConfig defines configuration options for proxy control and injection.
type TrafficManagementConfig struct {
	// Selects whether traffic management is installed.
	Enabled *bool `protobuf:"varint,1,opt,name=enabled" json:"enabled,omitempty"`
	// Namespace that all components for this feature are installed into.
	Namespace *string `protobuf:"bytes,2,opt,name=namespace" json:"namespace,omitempty"`
	// When set to true, auto injection is controlled by namespace label and pod annotation.
	// When set to false, auto injection is completely disabled.
	AutoInjection *bool `protobuf:"varint,3,opt,name=auto_injection,json=autoInjection" json:"auto_injection,omitempty"`
	// Component specific config.
	PilotConfig          *PilotConfig `protobuf:"bytes,4,opt,name=pilot_config,json=pilotConfig" json:"pilot_config,omitempty"`
	ProxyConfig          *ProxyConfig `protobuf:"bytes,5,opt,name=proxy_config,json=proxyConfig" json:"proxy_config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *TrafficManagementConfig) Reset()         { *m = TrafficManagementConfig{} }
func (m *TrafficManagementConfig) String() string { return proto.CompactTextString(m) }
func (*TrafficManagementConfig) ProtoMessage()    {}
func (*TrafficManagementConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{3}
}
func (m *TrafficManagementConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrafficManagementConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrafficManagementConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrafficManagementConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrafficManagementConfig.Merge(m, src)
}
func (m *TrafficManagementConfig) XXX_Size() int {
	return m.Size()
}
func (m *TrafficManagementConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TrafficManagementConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TrafficManagementConfig proto.InternalMessageInfo

func (m *TrafficManagementConfig) GetEnabled() bool {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return false
}

func (m *TrafficManagementConfig) GetNamespace() string {
	if m != nil && m.Namespace != nil {
		return *m.Namespace
	}
	return ""
}

func (m *TrafficManagementConfig) GetAutoInjection() bool {
	if m != nil && m.AutoInjection != nil {
		return *m.AutoInjection
	}
	return false
}

func (m *TrafficManagementConfig) GetPilotConfig() *PilotConfig {
	if m != nil {
		return m.PilotConfig
	}
	return nil
}

func (m *TrafficManagementConfig) GetProxyConfig() *ProxyConfig {
	if m != nil {
		return m.ProxyConfig
	}
	return nil
}

// PilotConfig defines the configuration options for pilot.
type PilotConfig struct {
	// Enables debug in pilot.
	Debug *bool `protobuf:"varint,1,opt,name=debug" json:"debug,omitempty"`
	// Enables sidecar in the pilot pod.
	Sidecar *bool `protobuf:"varint,10,opt,name=sidecar" json:"sidecar,omitempty"`
	// Trace sampling percentage.
	TraceSampling                   *float32 `protobuf:"fixed32,11,opt,name=trace_sampling,json=traceSampling" json:"trace_sampling,omitempty"`
	KeepaliveMaxServerConnectionAge *string  `protobuf:"bytes,12,opt,name=keepaliveMaxServerConnectionAge" json:"keepaliveMaxServerConnectionAge,omitempty"`
	// Additional arguments passed to pilot discovery.
	AdditionalArgs map[string]string `protobuf:"bytes,50,rep,name=additional_args,json=additionalArgs" json:"additional_args,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Additional environment variables for the discovery container.
	Env map[string]string `protobuf:"bytes,60,rep,name=env" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Passthrough to corresponding k8s settings.
	Resources *ResourceRequirements `protobuf:"bytes,80,opt,name=resources" json:"resources,omitempty"`
	// k8s scaling settings.
	ReplicaCount        *uint32                         `protobuf:"varint,85,opt,name=replica_count,json=replicaCount" json:"replica_count,omitempty"`
	HpaSpec             *v1.HorizontalPodAutoscalerSpec `protobuf:"bytes,86,opt,name=hpa_spec,json=hpaSpec" json:"hpa_spec,omitempty"`
	PodDisruptionBudget *PodDisruptionBudgetSpec        `protobuf:"bytes,87,opt,name=pod_disruption_budget,json=podDisruptionBudget" json:"pod_disruption_budget,omitempty"`
	// Annotations and selectors.
	NodeSelector map[string]string `protobuf:"bytes,92,rep,name=node_selector,json=nodeSelector" json:"node_selector,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Kustomize style overrides for k8s resources in rendered manifests.
	ResourceOverride     []*ResourceOverride `protobuf:"bytes,100,rep,name=resource_override,json=resourceOverride" json:"resource_override,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *PilotConfig) Reset()         { *m = PilotConfig{} }
func (m *PilotConfig) String() string { return proto.CompactTextString(m) }
func (*PilotConfig) ProtoMessage()    {}
func (*PilotConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{4}
}
func (m *PilotConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PilotConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PilotConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PilotConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PilotConfig.Merge(m, src)
}
func (m *PilotConfig) XXX_Size() int {
	return m.Size()
}
func (m *PilotConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PilotConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PilotConfig proto.InternalMessageInfo

func (m *PilotConfig) GetDebug() bool {
	if m != nil && m.Debug != nil {
		return *m.Debug
	}
	return false
}

func (m *PilotConfig) GetSidecar() bool {
	if m != nil && m.Sidecar != nil {
		return *m.Sidecar
	}
	return false
}

func (m *PilotConfig) GetTraceSampling() float32 {
	if m != nil && m.TraceSampling != nil {
		return *m.TraceSampling
	}
	return 0
}

func (m *PilotConfig) GetKeepaliveMaxServerConnectionAge() string {
	if m != nil && m.KeepaliveMaxServerConnectionAge != nil {
		return *m.KeepaliveMaxServerConnectionAge
	}
	return ""
}

func (m *PilotConfig) GetAdditionalArgs() map[string]string {
	if m != nil {
		return m.AdditionalArgs
	}
	return nil
}

func (m *PilotConfig) GetEnv() map[string]string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *PilotConfig) GetResources() *ResourceRequirements {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *PilotConfig) GetReplicaCount() uint32 {
	if m != nil && m.ReplicaCount != nil {
		return *m.ReplicaCount
	}
	return 0
}

func (m *PilotConfig) GetHpaSpec() *v1.HorizontalPodAutoscalerSpec {
	if m != nil {
		return m.HpaSpec
	}
	return nil
}

func (m *PilotConfig) GetPodDisruptionBudget() *PodDisruptionBudgetSpec {
	if m != nil {
		return m.PodDisruptionBudget
	}
	return nil
}

func (m *PilotConfig) GetNodeSelector() map[string]string {
	if m != nil {
		return m.NodeSelector
	}
	return nil
}

func (m *PilotConfig) GetResourceOverride() []*ResourceOverride {
	if m != nil {
		return m.ResourceOverride
	}
	return nil
}

// ProxyConfig defines the configuration options for the injected Envoy proxy.
type ProxyConfig struct {
	// Enables debug in the proxy.
	Debug *bool `protobuf:"varint,1,opt,name=debug" json:"debug,omitempty"`
	// TBD: is privileged ever set in isolation?
	Privileged *bool `protobuf:"varint,10,opt,name=privileged" json:"privileged,omitempty"`
	// Enables coredump in proxy container.
	EnableCoredump   *bool                         `protobuf:"varint,11,opt,name=enable_coredump,json=enableCoredump" json:"enable_coredump,omitempty"`
	InterceptionMode *ProxyConfig_InterceptionMode `protobuf:"varint,12,opt,name=interception_mode,json=interceptionMode,enum=v1alpha1.ProxyConfig_InterceptionMode" json:"interception_mode,omitempty"`
	// Below settings would otherwise be implemented as a k8s overlay but because the proxy resources are defined
	// as a ConfigMap containing a second template, it's probably too difficult to override fields in the k8s
	// ConfigMap.
	StatusPort      *uint32 `protobuf:"varint,13,opt,name=status_port,json=statusPort" json:"status_port,omitempty"`
	ImagePullPolicy *string `protobuf:"bytes,14,opt,name=image_pull_policy,json=imagePullPolicy" json:"image_pull_policy,omitempty"`
	ProxyInitImage  *string `protobuf:"bytes,15,opt,name=proxy_init_image,json=proxyInitImage" json:"proxy_init_image,omitempty"`
	// Address and port filtering.
	IncludeIpRanges     *string `protobuf:"bytes,16,opt,name=include_ip_ranges,json=includeIpRanges" json:"include_ip_ranges,omitempty"`
	ExcludeIpRanges     *string `protobuf:"bytes,17,opt,name=exclude_ip_ranges,json=excludeIpRanges" json:"exclude_ip_ranges,omitempty"`
	IncludeInboundPorts *string `protobuf:"bytes,18,opt,name=include_inbound_ports,json=includeInboundPorts" json:"include_inbound_ports,omitempty"`
	ExcludeInboundPorts *string `protobuf:"bytes,19,opt,name=exclude_inbound_ports,json=excludeInboundPorts" json:"exclude_inbound_ports,omitempty"`
	// Envoy specific timer settings.
	ConnectTimeout         *string `protobuf:"bytes,20,opt,name=connect_timeout,json=connectTimeout" json:"connect_timeout,omitempty"`
	DrainDuration          *string `protobuf:"bytes,21,opt,name=drain_duration,json=drainDuration" json:"drain_duration,omitempty"`
	ParentShutdownDuration *string `protobuf:"bytes,22,opt,name=parent_shutdown_duration,json=parentShutdownDuration" json:"parent_shutdown_duration,omitempty"`
	Concurrency            *uint32 `protobuf:"varint,23,opt,name=concurrency" json:"concurrency,omitempty"`
	ClusterDomain          *string `protobuf:"bytes,24,opt,name=cluster_domain,json=clusterDomain" json:"cluster_domain,omitempty"`
	PodDnsSearchNamespaces *string `protobuf:"bytes,25,opt,name=pod_dns_search_namespaces,json=podDnsSearchNamespaces" json:"pod_dns_search_namespaces,omitempty"`
	// Tracer options
	Lightstep *ProxyConfig_LightstepConfig `protobuf:"bytes,30,opt,name=lightstep" json:"lightstep,omitempty"`
	Zipkin    *ProxyConfig_ZipkinConfig    `protobuf:"bytes,31,opt,name=zipkin" json:"zipkin,omitempty"`
	// SDS settings
	Sds *SdsConfig `protobuf:"bytes,40,opt,name=sds" json:"sds,omitempty"`
	// Additional arguments passed to Envoy.
	AdditionalArgs map[string]string `protobuf:"bytes,50,rep,name=additional_args,json=additionalArgs" json:"additional_args,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Additional environment variables for the container.
	Env map[string]string `protobuf:"bytes,60,rep,name=env" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Passthrough to k8s resources.
	Resources      *ResourceRequirements `protobuf:"bytes,80,opt,name=resources" json:"resources,omitempty"`
	ReadinessProbe *v11.Probe            `protobuf:"bytes,81,opt,name=readiness_probe,json=readinessProbe" json:"readiness_probe,omitempty"`
	// Kustomize style overrides for k8s resources in rendered manifests.
	ResourceOverride     []*ResourceOverride `protobuf:"bytes,100,rep,name=resource_override,json=resourceOverride" json:"resource_override,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ProxyConfig) Reset()         { *m = ProxyConfig{} }
func (m *ProxyConfig) String() string { return proto.CompactTextString(m) }
func (*ProxyConfig) ProtoMessage()    {}
func (*ProxyConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{5}
}
func (m *ProxyConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProxyConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProxyConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProxyConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProxyConfig.Merge(m, src)
}
func (m *ProxyConfig) XXX_Size() int {
	return m.Size()
}
func (m *ProxyConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ProxyConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ProxyConfig proto.InternalMessageInfo

func (m *ProxyConfig) GetDebug() bool {
	if m != nil && m.Debug != nil {
		return *m.Debug
	}
	return false
}

func (m *ProxyConfig) GetPrivileged() bool {
	if m != nil && m.Privileged != nil {
		return *m.Privileged
	}
	return false
}

func (m *ProxyConfig) GetEnableCoredump() bool {
	if m != nil && m.EnableCoredump != nil {
		return *m.EnableCoredump
	}
	return false
}

func (m *ProxyConfig) GetInterceptionMode() ProxyConfig_InterceptionMode {
	if m != nil && m.InterceptionMode != nil {
		return *m.InterceptionMode
	}
	return ProxyConfig_REDIRECT
}

func (m *ProxyConfig) GetStatusPort() uint32 {
	if m != nil && m.StatusPort != nil {
		return *m.StatusPort
	}
	return 0
}

func (m *ProxyConfig) GetImagePullPolicy() string {
	if m != nil && m.ImagePullPolicy != nil {
		return *m.ImagePullPolicy
	}
	return ""
}

func (m *ProxyConfig) GetProxyInitImage() string {
	if m != nil && m.ProxyInitImage != nil {
		return *m.ProxyInitImage
	}
	return ""
}

func (m *ProxyConfig) GetIncludeIpRanges() string {
	if m != nil && m.IncludeIpRanges != nil {
		return *m.IncludeIpRanges
	}
	return ""
}

func (m *ProxyConfig) GetExcludeIpRanges() string {
	if m != nil && m.ExcludeIpRanges != nil {
		return *m.ExcludeIpRanges
	}
	return ""
}

func (m *ProxyConfig) GetIncludeInboundPorts() string {
	if m != nil && m.IncludeInboundPorts != nil {
		return *m.IncludeInboundPorts
	}
	return ""
}

func (m *ProxyConfig) GetExcludeInboundPorts() string {
	if m != nil && m.ExcludeInboundPorts != nil {
		return *m.ExcludeInboundPorts
	}
	return ""
}

func (m *ProxyConfig) GetConnectTimeout() string {
	if m != nil && m.ConnectTimeout != nil {
		return *m.ConnectTimeout
	}
	return ""
}

func (m *ProxyConfig) GetDrainDuration() string {
	if m != nil && m.DrainDuration != nil {
		return *m.DrainDuration
	}
	return ""
}

func (m *ProxyConfig) GetParentShutdownDuration() string {
	if m != nil && m.ParentShutdownDuration != nil {
		return *m.ParentShutdownDuration
	}
	return ""
}

func (m *ProxyConfig) GetConcurrency() uint32 {
	if m != nil && m.Concurrency != nil {
		return *m.Concurrency
	}
	return 0
}

func (m *ProxyConfig) GetClusterDomain() string {
	if m != nil && m.ClusterDomain != nil {
		return *m.ClusterDomain
	}
	return ""
}

func (m *ProxyConfig) GetPodDnsSearchNamespaces() string {
	if m != nil && m.PodDnsSearchNamespaces != nil {
		return *m.PodDnsSearchNamespaces
	}
	return ""
}

func (m *ProxyConfig) GetLightstep() *ProxyConfig_LightstepConfig {
	if m != nil {
		return m.Lightstep
	}
	return nil
}

func (m *ProxyConfig) GetZipkin() *ProxyConfig_ZipkinConfig {
	if m != nil {
		return m.Zipkin
	}
	return nil
}

func (m *ProxyConfig) GetSds() *SdsConfig {
	if m != nil {
		return m.Sds
	}
	return nil
}

func (m *ProxyConfig) GetAdditionalArgs() map[string]string {
	if m != nil {
		return m.AdditionalArgs
	}
	return nil
}

func (m *ProxyConfig) GetEnv() map[string]string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *ProxyConfig) GetResources() *ResourceRequirements {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *ProxyConfig) GetReadinessProbe() *v11.Probe {
	if m != nil {
		return m.ReadinessProbe
	}
	return nil
}

func (m *ProxyConfig) GetResourceOverride() []*ResourceOverride {
	if m != nil {
		return m.ResourceOverride
	}
	return nil
}

// Tracer config options.
type ProxyConfig_LightstepConfig struct {
	Address              *string  `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	AccessToken          *string  `protobuf:"bytes,2,opt,name=access_token,json=accessToken" json:"access_token,omitempty"`
	CaCertPath           *string  `protobuf:"bytes,3,opt,name=ca_cert_path,json=caCertPath" json:"ca_cert_path,omitempty"`
	Secure               *bool    `protobuf:"varint,4,opt,name=secure" json:"secure,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProxyConfig_LightstepConfig) Reset()         { *m = ProxyConfig_LightstepConfig{} }
func (m *ProxyConfig_LightstepConfig) String() string { return proto.CompactTextString(m) }
func (*ProxyConfig_LightstepConfig) ProtoMessage()    {}
func (*ProxyConfig_LightstepConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{5, 0}
}
func (m *ProxyConfig_LightstepConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProxyConfig_LightstepConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProxyConfig_LightstepConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProxyConfig_LightstepConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProxyConfig_LightstepConfig.Merge(m, src)
}
func (m *ProxyConfig_LightstepConfig) XXX_Size() int {
	return m.Size()
}
func (m *ProxyConfig_LightstepConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ProxyConfig_LightstepConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ProxyConfig_LightstepConfig proto.InternalMessageInfo

func (m *ProxyConfig_LightstepConfig) GetAddress() string {
	if m != nil && m.Address != nil {
		return *m.Address
	}
	return ""
}

func (m *ProxyConfig_LightstepConfig) GetAccessToken() string {
	if m != nil && m.AccessToken != nil {
		return *m.AccessToken
	}
	return ""
}

func (m *ProxyConfig_LightstepConfig) GetCaCertPath() string {
	if m != nil && m.CaCertPath != nil {
		return *m.CaCertPath
	}
	return ""
}

func (m *ProxyConfig_LightstepConfig) GetSecure() bool {
	if m != nil && m.Secure != nil {
		return *m.Secure
	}
	return false
}

type ProxyConfig_ZipkinConfig struct {
	Address              *string  `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProxyConfig_ZipkinConfig) Reset()         { *m = ProxyConfig_ZipkinConfig{} }
func (m *ProxyConfig_ZipkinConfig) String() string { return proto.CompactTextString(m) }
func (*ProxyConfig_ZipkinConfig) ProtoMessage()    {}
func (*ProxyConfig_ZipkinConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{5, 1}
}
func (m *ProxyConfig_ZipkinConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProxyConfig_ZipkinConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProxyConfig_ZipkinConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProxyConfig_ZipkinConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProxyConfig_ZipkinConfig.Merge(m, src)
}
func (m *ProxyConfig_ZipkinConfig) XXX_Size() int {
	return m.Size()
}
func (m *ProxyConfig_ZipkinConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ProxyConfig_ZipkinConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ProxyConfig_ZipkinConfig proto.InternalMessageInfo

func (m *ProxyConfig_ZipkinConfig) GetAddress() string {
	if m != nil && m.Address != nil {
		return *m.Address
	}
	return ""
}

type PolicyConfig struct {
	// Selects whether policy enforcement is installed.
	Enabled *bool `protobuf:"varint,1,opt,name=enabled" json:"enabled,omitempty"`
	// Namespace that all components for this feature are installed into.
	Namespace *string `protobuf:"bytes,2,opt,name=namespace" json:"namespace,omitempty"`
	// Additional environment variables for the container.
	Env map[string]string `protobuf:"bytes,60,rep,name=env" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Passthrough to k8s resources.
	Resources *ResourceRequirements `protobuf:"bytes,80,opt,name=resources" json:"resources,omitempty"`
	// k8s scaling settings.
	ReplicaCount        *uint32                         `protobuf:"varint,85,opt,name=replica_count,json=replicaCount" json:"replica_count,omitempty"`
	HpaSpec             *v1.HorizontalPodAutoscalerSpec `protobuf:"bytes,86,opt,name=hpa_spec,json=hpaSpec" json:"hpa_spec,omitempty"`
	PodDisruptionBudget *PodDisruptionBudgetSpec        `protobuf:"bytes,87,opt,name=pod_disruption_budget,json=podDisruptionBudget" json:"pod_disruption_budget,omitempty"`
	// Kustomize style overrides for k8s resources in rendered manifests.
	ResourceOverride     []*ResourceOverride `protobuf:"bytes,100,rep,name=resource_override,json=resourceOverride" json:"resource_override,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *PolicyConfig) Reset()         { *m = PolicyConfig{} }
func (m *PolicyConfig) String() string { return proto.CompactTextString(m) }
func (*PolicyConfig) ProtoMessage()    {}
func (*PolicyConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{6}
}
func (m *PolicyConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicyConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PolicyConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PolicyConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyConfig.Merge(m, src)
}
func (m *PolicyConfig) XXX_Size() int {
	return m.Size()
}
func (m *PolicyConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyConfig proto.InternalMessageInfo

func (m *PolicyConfig) GetEnabled() bool {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return false
}

func (m *PolicyConfig) GetNamespace() string {
	if m != nil && m.Namespace != nil {
		return *m.Namespace
	}
	return ""
}

func (m *PolicyConfig) GetEnv() map[string]string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *PolicyConfig) GetResources() *ResourceRequirements {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *PolicyConfig) GetReplicaCount() uint32 {
	if m != nil && m.ReplicaCount != nil {
		return *m.ReplicaCount
	}
	return 0
}

func (m *PolicyConfig) GetHpaSpec() *v1.HorizontalPodAutoscalerSpec {
	if m != nil {
		return m.HpaSpec
	}
	return nil
}

func (m *PolicyConfig) GetPodDisruptionBudget() *PodDisruptionBudgetSpec {
	if m != nil {
		return m.PodDisruptionBudget
	}
	return nil
}

func (m *PolicyConfig) GetResourceOverride() []*ResourceOverride {
	if m != nil {
		return m.ResourceOverride
	}
	return nil
}

type TelemetryConfig struct {
	// Selects whether policy enforcement is installed.
	Enabled *bool `protobuf:"varint,1,opt,name=enabled" json:"enabled,omitempty"`
	// Namespace that all components for this feature are installed into.
	Namespace              *string `protobuf:"bytes,2,opt,name=namespace" json:"namespace,omitempty"`
	SessionAffinityEnabled *bool   `protobuf:"varint,10,opt,name=session_affinity_enabled,json=sessionAffinityEnabled" json:"session_affinity_enabled,omitempty"`
	// Load shedding mode defines mixer behavior under load. If response time threshold is exceeded, the chosen
	// load shedding behavior will occur.
	LoadSheddingMode *TelemetryConfig_LoadSheddingMode `protobuf:"varint,11,opt,name=load_shedding_mode,json=loadSheddingMode,enum=v1alpha1.TelemetryConfig_LoadSheddingMode" json:"load_shedding_mode,omitempty"`
	// If the response time exceeds the threshold, the chosen load shedding behavior will take effect.
	LoadSheddingLatencyThreshold *string `protobuf:"bytes,12,opt,name=load_shedding_latency_threshold,json=loadSheddingLatencyThreshold" json:"load_shedding_latency_threshold,omitempty"`
	// k8s scaling settings.
	ReplicaCount *uint32 `protobuf:"varint,80,opt,name=replica_count,json=replicaCount" json:"replica_count,omitempty"`
	// Annotations and selectors.
	PodAnnotations map[string]string `protobuf:"bytes,90,rep,name=pod_annotations,json=podAnnotations" json:"pod_annotations,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	NodeSelector   map[string]string `protobuf:"bytes,92,rep,name=node_selector,json=nodeSelector" json:"node_selector,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Kustomize style overrides for k8s resources in rendered manifests.
	ResourceOverride     []*ResourceOverride `protobuf:"bytes,100,rep,name=resource_override,json=resourceOverride" json:"resource_override,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TelemetryConfig) Reset()         { *m = TelemetryConfig{} }
func (m *TelemetryConfig) String() string { return proto.CompactTextString(m) }
func (*TelemetryConfig) ProtoMessage()    {}
func (*TelemetryConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{7}
}
func (m *TelemetryConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TelemetryConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TelemetryConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TelemetryConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TelemetryConfig.Merge(m, src)
}
func (m *TelemetryConfig) XXX_Size() int {
	return m.Size()
}
func (m *TelemetryConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TelemetryConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TelemetryConfig proto.InternalMessageInfo

func (m *TelemetryConfig) GetEnabled() bool {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return false
}

func (m *TelemetryConfig) GetNamespace() string {
	if m != nil && m.Namespace != nil {
		return *m.Namespace
	}
	return ""
}

func (m *TelemetryConfig) GetSessionAffinityEnabled() bool {
	if m != nil && m.SessionAffinityEnabled != nil {
		return *m.SessionAffinityEnabled
	}
	return false
}

func (m *TelemetryConfig) GetLoadSheddingMode() TelemetryConfig_LoadSheddingMode {
	if m != nil && m.LoadSheddingMode != nil {
		return *m.LoadSheddingMode
	}
	return TelemetryConfig_ENFORCE
}

func (m *TelemetryConfig) GetLoadSheddingLatencyThreshold() string {
	if m != nil && m.LoadSheddingLatencyThreshold != nil {
		return *m.LoadSheddingLatencyThreshold
	}
	return ""
}

func (m *TelemetryConfig) GetReplicaCount() uint32 {
	if m != nil && m.ReplicaCount != nil {
		return *m.ReplicaCount
	}
	return 0
}

func (m *TelemetryConfig) GetPodAnnotations() map[string]string {
	if m != nil {
		return m.PodAnnotations
	}
	return nil
}

func (m *TelemetryConfig) GetNodeSelector() map[string]string {
	if m != nil {
		return m.NodeSelector
	}
	return nil
}

func (m *TelemetryConfig) GetResourceOverride() []*ResourceOverride {
	if m != nil {
		return m.ResourceOverride
	}
	return nil
}

type TelemetryConfig_Adapters struct {
	UseAdapter_CRDs      *bool                                   `protobuf:"varint,1,opt,name=use_adapter_CRDs,json=useAdapterCRDs" json:"use_adapter_CRDs,omitempty"`
	KubernetesEnvConfig  *TelemetryConfig_Adapters_KubernetesEnv `protobuf:"bytes,2,opt,name=kubernetes_env_config,json=kubernetesEnvConfig" json:"kubernetes_env_config,omitempty"`
	Stdio                *TelemetryConfig_Adapters_Stdio         `protobuf:"bytes,3,opt,name=stdio" json:"stdio,omitempty"`
	Prometheus           *TelemetryConfig_Adapters_Prometheus    `protobuf:"bytes,4,opt,name=prometheus" json:"prometheus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                `json:"-"`
	XXX_unrecognized     []byte                                  `json:"-"`
	XXX_sizecache        int32                                   `json:"-"`
}

func (m *TelemetryConfig_Adapters) Reset()         { *m = TelemetryConfig_Adapters{} }
func (m *TelemetryConfig_Adapters) String() string { return proto.CompactTextString(m) }
func (*TelemetryConfig_Adapters) ProtoMessage()    {}
func (*TelemetryConfig_Adapters) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{7, 0}
}
func (m *TelemetryConfig_Adapters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TelemetryConfig_Adapters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TelemetryConfig_Adapters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TelemetryConfig_Adapters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TelemetryConfig_Adapters.Merge(m, src)
}
func (m *TelemetryConfig_Adapters) XXX_Size() int {
	return m.Size()
}
func (m *TelemetryConfig_Adapters) XXX_DiscardUnknown() {
	xxx_messageInfo_TelemetryConfig_Adapters.DiscardUnknown(m)
}

var xxx_messageInfo_TelemetryConfig_Adapters proto.InternalMessageInfo

func (m *TelemetryConfig_Adapters) GetUseAdapter_CRDs() bool {
	if m != nil && m.UseAdapter_CRDs != nil {
		return *m.UseAdapter_CRDs
	}
	return false
}

func (m *TelemetryConfig_Adapters) GetKubernetesEnvConfig() *TelemetryConfig_Adapters_KubernetesEnv {
	if m != nil {
		return m.KubernetesEnvConfig
	}
	return nil
}

func (m *TelemetryConfig_Adapters) GetStdio() *TelemetryConfig_Adapters_Stdio {
	if m != nil {
		return m.Stdio
	}
	return nil
}

func (m *TelemetryConfig_Adapters) GetPrometheus() *TelemetryConfig_Adapters_Prometheus {
	if m != nil {
		return m.Prometheus
	}
	return nil
}

type TelemetryConfig_Adapters_KubernetesEnv struct {
	Enabled              *bool    `protobuf:"varint,1,opt,name=enabled" json:"enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TelemetryConfig_Adapters_KubernetesEnv) Reset() {
	*m = TelemetryConfig_Adapters_KubernetesEnv{}
}
func (m *TelemetryConfig_Adapters_KubernetesEnv) String() string { return proto.CompactTextString(m) }
func (*TelemetryConfig_Adapters_KubernetesEnv) ProtoMessage()    {}
func (*TelemetryConfig_Adapters_KubernetesEnv) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{7, 0, 0}
}
func (m *TelemetryConfig_Adapters_KubernetesEnv) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TelemetryConfig_Adapters_KubernetesEnv) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TelemetryConfig_Adapters_KubernetesEnv.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TelemetryConfig_Adapters_KubernetesEnv) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TelemetryConfig_Adapters_KubernetesEnv.Merge(m, src)
}
func (m *TelemetryConfig_Adapters_KubernetesEnv) XXX_Size() int {
	return m.Size()
}
func (m *TelemetryConfig_Adapters_KubernetesEnv) XXX_DiscardUnknown() {
	xxx_messageInfo_TelemetryConfig_Adapters_KubernetesEnv.DiscardUnknown(m)
}

var xxx_messageInfo_TelemetryConfig_Adapters_KubernetesEnv proto.InternalMessageInfo

func (m *TelemetryConfig_Adapters_KubernetesEnv) GetEnabled() bool {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return false
}

type TelemetryConfig_Adapters_Stdio struct {
	Enabled              *bool    `protobuf:"varint,1,opt,name=enabled" json:"enabled,omitempty"`
	OutputAsJson         *bool    `protobuf:"varint,2,opt,name=output_as_json,json=outputAsJson" json:"output_as_json,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TelemetryConfig_Adapters_Stdio) Reset()         { *m = TelemetryConfig_Adapters_Stdio{} }
func (m *TelemetryConfig_Adapters_Stdio) String() string { return proto.CompactTextString(m) }
func (*TelemetryConfig_Adapters_Stdio) ProtoMessage()    {}
func (*TelemetryConfig_Adapters_Stdio) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{7, 0, 1}
}
func (m *TelemetryConfig_Adapters_Stdio) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TelemetryConfig_Adapters_Stdio) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TelemetryConfig_Adapters_Stdio.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TelemetryConfig_Adapters_Stdio) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TelemetryConfig_Adapters_Stdio.Merge(m, src)
}
func (m *TelemetryConfig_Adapters_Stdio) XXX_Size() int {
	return m.Size()
}
func (m *TelemetryConfig_Adapters_Stdio) XXX_DiscardUnknown() {
	xxx_messageInfo_TelemetryConfig_Adapters_Stdio.DiscardUnknown(m)
}

var xxx_messageInfo_TelemetryConfig_Adapters_Stdio proto.InternalMessageInfo

func (m *TelemetryConfig_Adapters_Stdio) GetEnabled() bool {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return false
}

func (m *TelemetryConfig_Adapters_Stdio) GetOutputAsJson() bool {
	if m != nil && m.OutputAsJson != nil {
		return *m.OutputAsJson
	}
	return false
}

type TelemetryConfig_Adapters_Prometheus struct {
	Enabled               *bool    `protobuf:"varint,1,opt,name=enabled" json:"enabled,omitempty"`
	MetricsExpiryDuration *string  `protobuf:"bytes,2,opt,name=metrics_expiry_duration,json=metricsExpiryDuration" json:"metrics_expiry_duration,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *TelemetryConfig_Adapters_Prometheus) Reset()         { *m = TelemetryConfig_Adapters_Prometheus{} }
func (m *TelemetryConfig_Adapters_Prometheus) String() string { return proto.CompactTextString(m) }
func (*TelemetryConfig_Adapters_Prometheus) ProtoMessage()    {}
func (*TelemetryConfig_Adapters_Prometheus) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{7, 0, 2}
}
func (m *TelemetryConfig_Adapters_Prometheus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TelemetryConfig_Adapters_Prometheus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TelemetryConfig_Adapters_Prometheus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TelemetryConfig_Adapters_Prometheus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TelemetryConfig_Adapters_Prometheus.Merge(m, src)
}
func (m *TelemetryConfig_Adapters_Prometheus) XXX_Size() int {
	return m.Size()
}
func (m *TelemetryConfig_Adapters_Prometheus) XXX_DiscardUnknown() {
	xxx_messageInfo_TelemetryConfig_Adapters_Prometheus.DiscardUnknown(m)
}

var xxx_messageInfo_TelemetryConfig_Adapters_Prometheus proto.InternalMessageInfo

func (m *TelemetryConfig_Adapters_Prometheus) GetEnabled() bool {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return false
}

func (m *TelemetryConfig_Adapters_Prometheus) GetMetricsExpiryDuration() string {
	if m != nil && m.MetricsExpiryDuration != nil {
		return *m.MetricsExpiryDuration
	}
	return ""
}

type SecurityConfig struct {
	// Selects whether policy enforcement is installed.
	Enabled *bool `protobuf:"varint,1,opt,name=enabled" json:"enabled,omitempty"`
	// Namespace that all components for this feature are installed into.
	Namespace        *string `protobuf:"bytes,2,opt,name=namespace" json:"namespace,omitempty"`
	Image            *string `protobuf:"bytes,10,opt,name=image" json:"image,omitempty"`
	SelfSigned       *bool   `protobuf:"varint,11,opt,name=self_signed,json=selfSigned" json:"self_signed,omitempty"`
	CreateMeshPolicy *bool   `protobuf:"varint,12,opt,name=create_mesh_policy,json=createMeshPolicy" json:"create_mesh_policy,omitempty"`
	// k8s scaling settings.
	ReplicaCount *uint32 `protobuf:"varint,80,opt,name=replica_count,json=replicaCount" json:"replica_count,omitempty"`
	// Annotations and selectors.
	NodeSelector map[string]string `protobuf:"bytes,92,rep,name=node_selector,json=nodeSelector" json:"node_selector,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Kustomize style overrides for k8s resources in rendered manifests.
	ResourceOverride     []*ResourceOverride `protobuf:"bytes,100,rep,name=resource_override,json=resourceOverride" json:"resource_override,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *SecurityConfig) Reset()         { *m = SecurityConfig{} }
func (m *SecurityConfig) String() string { return proto.CompactTextString(m) }
func (*SecurityConfig) ProtoMessage()    {}
func (*SecurityConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{8}
}
func (m *SecurityConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityConfig.Merge(m, src)
}
func (m *SecurityConfig) XXX_Size() int {
	return m.Size()
}
func (m *SecurityConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityConfig proto.InternalMessageInfo

func (m *SecurityConfig) GetEnabled() bool {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return false
}

func (m *SecurityConfig) GetNamespace() string {
	if m != nil && m.Namespace != nil {
		return *m.Namespace
	}
	return ""
}

func (m *SecurityConfig) GetImage() string {
	if m != nil && m.Image != nil {
		return *m.Image
	}
	return ""
}

func (m *SecurityConfig) GetSelfSigned() bool {
	if m != nil && m.SelfSigned != nil {
		return *m.SelfSigned
	}
	return false
}

func (m *SecurityConfig) GetCreateMeshPolicy() bool {
	if m != nil && m.CreateMeshPolicy != nil {
		return *m.CreateMeshPolicy
	}
	return false
}

func (m *SecurityConfig) GetReplicaCount() uint32 {
	if m != nil && m.ReplicaCount != nil {
		return *m.ReplicaCount
	}
	return 0
}

func (m *SecurityConfig) GetNodeSelector() map[string]string {
	if m != nil {
		return m.NodeSelector
	}
	return nil
}

func (m *SecurityConfig) GetResourceOverride() []*ResourceOverride {
	if m != nil {
		return m.ResourceOverride
	}
	return nil
}

type SecurityConfig_CertManager struct {
	// Selects whether cert manager is installed.
	Enabled *bool `protobuf:"varint,1,opt,name=enabled" json:"enabled,omitempty"`
	// Namespace that all components for this feature are installed into.
	Namespace *string `protobuf:"bytes,2,opt,name=namespace" json:"namespace,omitempty"`
	// hub is the path for docker images e.g. quay.io/jetstack
	// TODO: clarify if image name default exists.
	Hub *string `protobuf:"bytes,3,opt,name=hub" json:"hub,omitempty"`
	// tag is the version tag for docker images e.g. 1.0.6
	Tag *string `protobuf:"bytes,4,opt,name=tag" json:"tag,omitempty"`
	// Passthrough to k8s resources.
	Resources            *ResourceRequirements `protobuf:"bytes,82,opt,name=resources" json:"resources,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *SecurityConfig_CertManager) Reset()         { *m = SecurityConfig_CertManager{} }
func (m *SecurityConfig_CertManager) String() string { return proto.CompactTextString(m) }
func (*SecurityConfig_CertManager) ProtoMessage()    {}
func (*SecurityConfig_CertManager) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{8, 0}
}
func (m *SecurityConfig_CertManager) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityConfig_CertManager) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityConfig_CertManager.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityConfig_CertManager) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityConfig_CertManager.Merge(m, src)
}
func (m *SecurityConfig_CertManager) XXX_Size() int {
	return m.Size()
}
func (m *SecurityConfig_CertManager) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityConfig_CertManager.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityConfig_CertManager proto.InternalMessageInfo

func (m *SecurityConfig_CertManager) GetEnabled() bool {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return false
}

func (m *SecurityConfig_CertManager) GetNamespace() string {
	if m != nil && m.Namespace != nil {
		return *m.Namespace
	}
	return ""
}

func (m *SecurityConfig_CertManager) GetHub() string {
	if m != nil && m.Hub != nil {
		return *m.Hub
	}
	return ""
}

func (m *SecurityConfig_CertManager) GetTag() string {
	if m != nil && m.Tag != nil {
		return *m.Tag
	}
	return ""
}

func (m *SecurityConfig_CertManager) GetResources() *ResourceRequirements {
	if m != nil {
		return m.Resources
	}
	return nil
}

type ConfigManagementConfig struct {
	// Selects whether config management is installed.
	Enabled *bool `protobuf:"varint,1,opt,name=enabled" json:"enabled,omitempty"`
	// Namespace that all components for this feature are installed into.
	Namespace *string `protobuf:"bytes,2,opt,name=namespace" json:"namespace,omitempty"`
	Image     *string `protobuf:"bytes,10,opt,name=image" json:"image,omitempty"`
	// k8s scaling settings.
	ReplicaCount *uint32 `protobuf:"varint,80,opt,name=replica_count,json=replicaCount" json:"replica_count,omitempty"`
	// Kustomize style overrides for k8s resources in rendered manifests.
	ResourceOverride     []*ResourceOverride `protobuf:"bytes,100,rep,name=resource_override,json=resourceOverride" json:"resource_override,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ConfigManagementConfig) Reset()         { *m = ConfigManagementConfig{} }
func (m *ConfigManagementConfig) String() string { return proto.CompactTextString(m) }
func (*ConfigManagementConfig) ProtoMessage()    {}
func (*ConfigManagementConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{9}
}
func (m *ConfigManagementConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigManagementConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigManagementConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigManagementConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigManagementConfig.Merge(m, src)
}
func (m *ConfigManagementConfig) XXX_Size() int {
	return m.Size()
}
func (m *ConfigManagementConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigManagementConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigManagementConfig proto.InternalMessageInfo

func (m *ConfigManagementConfig) GetEnabled() bool {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return false
}

func (m *ConfigManagementConfig) GetNamespace() string {
	if m != nil && m.Namespace != nil {
		return *m.Namespace
	}
	return ""
}

func (m *ConfigManagementConfig) GetImage() string {
	if m != nil && m.Image != nil {
		return *m.Image
	}
	return ""
}

func (m *ConfigManagementConfig) GetReplicaCount() uint32 {
	if m != nil && m.ReplicaCount != nil {
		return *m.ReplicaCount
	}
	return 0
}

func (m *ConfigManagementConfig) GetResourceOverride() []*ResourceOverride {
	if m != nil {
		return m.ResourceOverride
	}
	return nil
}

type IngressGatewayConfig struct {
	LoadBalancerIP           *string  `protobuf:"bytes,11,opt,name=load_balancer_iP,json=loadBalancerIP" json:"load_balancer_iP,omitempty"`
	LoadBalancerSourceRanges []string `protobuf:"bytes,12,rep,name=load_balancer_source_ranges,json=loadBalancerSourceRanges" json:"load_balancer_source_ranges,omitempty"`
	ExternalIPs              []string `protobuf:"bytes,13,rep,name=external_iPs,json=externalIPs" json:"external_iPs,omitempty"`
	XXX_NoUnkeyedLiteral     struct{} `json:"-"`
	XXX_unrecognized         []byte   `json:"-"`
	XXX_sizecache            int32    `json:"-"`
}

func (m *IngressGatewayConfig) Reset()         { *m = IngressGatewayConfig{} }
func (m *IngressGatewayConfig) String() string { return proto.CompactTextString(m) }
func (*IngressGatewayConfig) ProtoMessage()    {}
func (*IngressGatewayConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{10}
}
func (m *IngressGatewayConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngressGatewayConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngressGatewayConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IngressGatewayConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngressGatewayConfig.Merge(m, src)
}
func (m *IngressGatewayConfig) XXX_Size() int {
	return m.Size()
}
func (m *IngressGatewayConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_IngressGatewayConfig.DiscardUnknown(m)
}

var xxx_messageInfo_IngressGatewayConfig proto.InternalMessageInfo

func (m *IngressGatewayConfig) GetLoadBalancerIP() string {
	if m != nil && m.LoadBalancerIP != nil {
		return *m.LoadBalancerIP
	}
	return ""
}

func (m *IngressGatewayConfig) GetLoadBalancerSourceRanges() []string {
	if m != nil {
		return m.LoadBalancerSourceRanges
	}
	return nil
}

func (m *IngressGatewayConfig) GetExternalIPs() []string {
	if m != nil {
		return m.ExternalIPs
	}
	return nil
}

type IngressGatewayConfig_Sds struct {
	// Selects whether config management is installed.
	Enabled              *bool    `protobuf:"varint,1,opt,name=enabled" json:"enabled,omitempty"`
	Image                *string  `protobuf:"bytes,10,opt,name=image" json:"image,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IngressGatewayConfig_Sds) Reset()         { *m = IngressGatewayConfig_Sds{} }
func (m *IngressGatewayConfig_Sds) String() string { return proto.CompactTextString(m) }
func (*IngressGatewayConfig_Sds) ProtoMessage()    {}
func (*IngressGatewayConfig_Sds) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{10, 0}
}
func (m *IngressGatewayConfig_Sds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngressGatewayConfig_Sds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngressGatewayConfig_Sds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IngressGatewayConfig_Sds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngressGatewayConfig_Sds.Merge(m, src)
}
func (m *IngressGatewayConfig_Sds) XXX_Size() int {
	return m.Size()
}
func (m *IngressGatewayConfig_Sds) XXX_DiscardUnknown() {
	xxx_messageInfo_IngressGatewayConfig_Sds.DiscardUnknown(m)
}

var xxx_messageInfo_IngressGatewayConfig_Sds proto.InternalMessageInfo

func (m *IngressGatewayConfig_Sds) GetEnabled() bool {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return false
}

func (m *IngressGatewayConfig_Sds) GetImage() string {
	if m != nil && m.Image != nil {
		return *m.Image
	}
	return ""
}

type EgressGatewayConfig struct {
	Gateway              *GatewayConfig `protobuf:"bytes,10,opt,name=gateway" json:"gateway,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *EgressGatewayConfig) Reset()         { *m = EgressGatewayConfig{} }
func (m *EgressGatewayConfig) String() string { return proto.CompactTextString(m) }
func (*EgressGatewayConfig) ProtoMessage()    {}
func (*EgressGatewayConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{11}
}
func (m *EgressGatewayConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EgressGatewayConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EgressGatewayConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EgressGatewayConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EgressGatewayConfig.Merge(m, src)
}
func (m *EgressGatewayConfig) XXX_Size() int {
	return m.Size()
}
func (m *EgressGatewayConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_EgressGatewayConfig.DiscardUnknown(m)
}

var xxx_messageInfo_EgressGatewayConfig proto.InternalMessageInfo

func (m *EgressGatewayConfig) GetGateway() *GatewayConfig {
	if m != nil {
		return m.Gateway
	}
	return nil
}

type IlbGatewayConfig struct {
	Gateway              *GatewayConfig `protobuf:"bytes,10,opt,name=gateway" json:"gateway,omitempty"`
	LoadBalancerIP       *string        `protobuf:"bytes,11,opt,name=load_balancer_iP,json=loadBalancerIP" json:"load_balancer_iP,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *IlbGatewayConfig) Reset()         { *m = IlbGatewayConfig{} }
func (m *IlbGatewayConfig) String() string { return proto.CompactTextString(m) }
func (*IlbGatewayConfig) ProtoMessage()    {}
func (*IlbGatewayConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{12}
}
func (m *IlbGatewayConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IlbGatewayConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IlbGatewayConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IlbGatewayConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IlbGatewayConfig.Merge(m, src)
}
func (m *IlbGatewayConfig) XXX_Size() int {
	return m.Size()
}
func (m *IlbGatewayConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_IlbGatewayConfig.DiscardUnknown(m)
}

var xxx_messageInfo_IlbGatewayConfig proto.InternalMessageInfo

func (m *IlbGatewayConfig) GetGateway() *GatewayConfig {
	if m != nil {
		return m.Gateway
	}
	return nil
}

func (m *IlbGatewayConfig) GetLoadBalancerIP() string {
	if m != nil && m.LoadBalancerIP != nil {
		return *m.LoadBalancerIP
	}
	return ""
}

type GatewayConfig struct {
	// NodePort, ClusterIP or LoadBalancer.
	Type *string `protobuf:"bytes,10,opt,name=type" json:"type,omitempty"`
	// Additional environment variables for the container.
	Env map[string]string `protobuf:"bytes,60,rep,name=env" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// k8s scaling settings.
	HpaSpec *v1.HorizontalPodAutoscalerSpec `protobuf:"bytes,86,opt,name=hpa_spec,json=hpaSpec" json:"hpa_spec,omitempty"`
	// Annotations and selectors.
	PodAnnotations     map[string]string `protobuf:"bytes,90,rep,name=pod_annotations,json=podAnnotations" json:"pod_annotations,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	ServiceAnnotations map[string]string `protobuf:"bytes,91,rep,name=service_annotations,json=serviceAnnotations" json:"service_annotations,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	NodeSelector       map[string]string `protobuf:"bytes,92,rep,name=node_selector,json=nodeSelector" json:"node_selector,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Kustomize style overrides for k8s resources in rendered manifests.
	ResourceOverride     []*ResourceOverride `protobuf:"bytes,100,rep,name=resource_override,json=resourceOverride" json:"resource_override,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *GatewayConfig) Reset()         { *m = GatewayConfig{} }
func (m *GatewayConfig) String() string { return proto.CompactTextString(m) }
func (*GatewayConfig) ProtoMessage()    {}
func (*GatewayConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{13}
}
func (m *GatewayConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GatewayConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GatewayConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GatewayConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GatewayConfig.Merge(m, src)
}
func (m *GatewayConfig) XXX_Size() int {
	return m.Size()
}
func (m *GatewayConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GatewayConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GatewayConfig proto.InternalMessageInfo

func (m *GatewayConfig) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

func (m *GatewayConfig) GetEnv() map[string]string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *GatewayConfig) GetHpaSpec() *v1.HorizontalPodAutoscalerSpec {
	if m != nil {
		return m.HpaSpec
	}
	return nil
}

func (m *GatewayConfig) GetPodAnnotations() map[string]string {
	if m != nil {
		return m.PodAnnotations
	}
	return nil
}

func (m *GatewayConfig) GetServiceAnnotations() map[string]string {
	if m != nil {
		return m.ServiceAnnotations
	}
	return nil
}

func (m *GatewayConfig) GetNodeSelector() map[string]string {
	if m != nil {
		return m.NodeSelector
	}
	return nil
}

func (m *GatewayConfig) GetResourceOverride() []*ResourceOverride {
	if m != nil {
		return m.ResourceOverride
	}
	return nil
}

type GatewayConfig_Labels struct {
	App                  *string  `protobuf:"bytes,1,opt,name=app" json:"app,omitempty"`
	Istio                *string  `protobuf:"bytes,2,opt,name=istio" json:"istio,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GatewayConfig_Labels) Reset()         { *m = GatewayConfig_Labels{} }
func (m *GatewayConfig_Labels) String() string { return proto.CompactTextString(m) }
func (*GatewayConfig_Labels) ProtoMessage()    {}
func (*GatewayConfig_Labels) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{13, 0}
}
func (m *GatewayConfig_Labels) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GatewayConfig_Labels) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GatewayConfig_Labels.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GatewayConfig_Labels) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GatewayConfig_Labels.Merge(m, src)
}
func (m *GatewayConfig_Labels) XXX_Size() int {
	return m.Size()
}
func (m *GatewayConfig_Labels) XXX_DiscardUnknown() {
	xxx_messageInfo_GatewayConfig_Labels.DiscardUnknown(m)
}

var xxx_messageInfo_GatewayConfig_Labels proto.InternalMessageInfo

func (m *GatewayConfig_Labels) GetApp() string {
	if m != nil && m.App != nil {
		return *m.App
	}
	return ""
}

func (m *GatewayConfig_Labels) GetIstio() string {
	if m != nil && m.Istio != nil {
		return *m.Istio
	}
	return ""
}

// OperatorConfig defines a config used to install an external operator.
type OperatorConfig struct {
	// manifest_path is the URL for the operator install manifest.
	ManifestPath *string `protobuf:"bytes,1,opt,name=manifest_path,json=manifestPath" json:"manifest_path,omitempty"`
	// namespace is the namespace the operator manifest and CR are installed into.
	Namespace *string `protobuf:"bytes,2,opt,name=namespace" json:"namespace,omitempty"`
	// spec is the initial CR for the operator.
	Spec                 *ResourceOverride `protobuf:"bytes,100,opt,name=spec" json:"spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *OperatorConfig) Reset()         { *m = OperatorConfig{} }
func (m *OperatorConfig) String() string { return proto.CompactTextString(m) }
func (*OperatorConfig) ProtoMessage()    {}
func (*OperatorConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{14}
}
func (m *OperatorConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperatorConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperatorConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperatorConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperatorConfig.Merge(m, src)
}
func (m *OperatorConfig) XXX_Size() int {
	return m.Size()
}
func (m *OperatorConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_OperatorConfig.DiscardUnknown(m)
}

var xxx_messageInfo_OperatorConfig proto.InternalMessageInfo

func (m *OperatorConfig) GetManifestPath() string {
	if m != nil && m.ManifestPath != nil {
		return *m.ManifestPath
	}
	return ""
}

func (m *OperatorConfig) GetNamespace() string {
	if m != nil && m.Namespace != nil {
		return *m.Namespace
	}
	return ""
}

func (m *OperatorConfig) GetSpec() *ResourceOverride {
	if m != nil {
		return m.Spec
	}
	return nil
}

type IstioInstaller struct {
	Spec                 *InstallerSpec   `protobuf:"bytes,3,opt,name=spec" json:"spec,omitempty"`
	Status               *InstallerStatus `protobuf:"bytes,4,opt,name=status" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *IstioInstaller) Reset()         { *m = IstioInstaller{} }
func (m *IstioInstaller) String() string { return proto.CompactTextString(m) }
func (*IstioInstaller) ProtoMessage()    {}
func (*IstioInstaller) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{15}
}
func (m *IstioInstaller) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IstioInstaller) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IstioInstaller.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IstioInstaller) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IstioInstaller.Merge(m, src)
}
func (m *IstioInstaller) XXX_Size() int {
	return m.Size()
}
func (m *IstioInstaller) XXX_DiscardUnknown() {
	xxx_messageInfo_IstioInstaller.DiscardUnknown(m)
}

var xxx_messageInfo_IstioInstaller proto.InternalMessageInfo

func (m *IstioInstaller) GetSpec() *InstallerSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *IstioInstaller) GetStatus() *InstallerStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// ResourceRequirements describes the compute resource requirements.
// Mirrors k8s.io.api.core.v1.ResourceRequirements for Unmarshaling.
type ResourceRequirements struct {
	Limits               map[string]string `protobuf:"bytes,1,rep,name=limits" json:"limits,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Requests             map[string]string `protobuf:"bytes,2,rep,name=requests" json:"requests,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ResourceRequirements) Reset()         { *m = ResourceRequirements{} }
func (m *ResourceRequirements) String() string { return proto.CompactTextString(m) }
func (*ResourceRequirements) ProtoMessage()    {}
func (*ResourceRequirements) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{16}
}
func (m *ResourceRequirements) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceRequirements) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceRequirements.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceRequirements) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceRequirements.Merge(m, src)
}
func (m *ResourceRequirements) XXX_Size() int {
	return m.Size()
}
func (m *ResourceRequirements) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceRequirements.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceRequirements proto.InternalMessageInfo

func (m *ResourceRequirements) GetLimits() map[string]string {
	if m != nil {
		return m.Limits
	}
	return nil
}

func (m *ResourceRequirements) GetRequests() map[string]string {
	if m != nil {
		return m.Requests
	}
	return nil
}

// PodDisruptionBudgetSpec is a description of a PodDisruptionBudget.
// Mirrors k8s.io.api.policy.v1beta1.PodDisruptionBudget for Unmarshaling.
type PodDisruptionBudgetSpec struct {
	MinAvailable         *uint32            `protobuf:"varint,1,opt,name=min_available,json=minAvailable" json:"min_available,omitempty"`
	Selector             *v12.LabelSelector `protobuf:"bytes,2,opt,name=selector" json:"selector,omitempty"`
	MaxUnavailable       *uint32            `protobuf:"varint,3,opt,name=max_unavailable,json=maxUnavailable" json:"max_unavailable,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *PodDisruptionBudgetSpec) Reset()         { *m = PodDisruptionBudgetSpec{} }
func (m *PodDisruptionBudgetSpec) String() string { return proto.CompactTextString(m) }
func (*PodDisruptionBudgetSpec) ProtoMessage()    {}
func (*PodDisruptionBudgetSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{17}
}
func (m *PodDisruptionBudgetSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodDisruptionBudgetSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodDisruptionBudgetSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodDisruptionBudgetSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodDisruptionBudgetSpec.Merge(m, src)
}
func (m *PodDisruptionBudgetSpec) XXX_Size() int {
	return m.Size()
}
func (m *PodDisruptionBudgetSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PodDisruptionBudgetSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PodDisruptionBudgetSpec proto.InternalMessageInfo

func (m *PodDisruptionBudgetSpec) GetMinAvailable() uint32 {
	if m != nil && m.MinAvailable != nil {
		return *m.MinAvailable
	}
	return 0
}

func (m *PodDisruptionBudgetSpec) GetSelector() *v12.LabelSelector {
	if m != nil {
		return m.Selector
	}
	return nil
}

func (m *PodDisruptionBudgetSpec) GetMaxUnavailable() uint32 {
	if m != nil && m.MaxUnavailable != nil {
		return *m.MaxUnavailable
	}
	return 0
}

// ResourceOverride specifies a patch for an existing k8s resource.
type ResourceOverride struct {
	PatchType *ResourceOverride_PatchType `protobuf:"varint,1,opt,name=patch_type,json=patchType,enum=v1alpha1.ResourceOverride_PatchType" json:"patch_type,omitempty"`
	Op        *ResourceOverride_Op        `protobuf:"varint,2,opt,name=op,enum=v1alpha1.ResourceOverride_Op" json:"op,omitempty"`
	// From k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.TypeMeta
	Kind                 *string     `protobuf:"bytes,3,opt,name=kind" json:"kind,omitempty"`
	ApiVersion           *string     `protobuf:"bytes,4,opt,name=api_version,json=apiVersion" json:"api_version,omitempty"`
	Metadata             *ObjectMeta `protobuf:"bytes,5,opt,name=metadata" json:"metadata,omitempty"`
    Data map[string]interface{}      `protobuf:"bytes,6,opt,name=data" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ResourceOverride) Reset()         { *m = ResourceOverride{} }
func (m *ResourceOverride) String() string { return proto.CompactTextString(m) }
func (*ResourceOverride) ProtoMessage()    {}
func (*ResourceOverride) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{18}
}
func (m *ResourceOverride) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceOverride) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceOverride.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceOverride) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceOverride.Merge(m, src)
}
func (m *ResourceOverride) XXX_Size() int {
	return m.Size()
}
func (m *ResourceOverride) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceOverride.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceOverride proto.InternalMessageInfo

func (m *ResourceOverride) GetPatchType() ResourceOverride_PatchType {
	if m != nil && m.PatchType != nil {
		return *m.PatchType
	}
	return ResourceOverride_STRATEGIC
}

func (m *ResourceOverride) GetOp() ResourceOverride_Op {
	if m != nil && m.Op != nil {
		return *m.Op
	}
	return ResourceOverride_ADD
}

func (m *ResourceOverride) GetKind() string {
	if m != nil && m.Kind != nil {
		return *m.Kind
	}
	return ""
}

func (m *ResourceOverride) GetApiVersion() string {
	if m != nil && m.ApiVersion != nil {
		return *m.ApiVersion
	}
	return ""
}

func (m *ResourceOverride) GetMetadata() *ObjectMeta {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type ObjectMeta struct {
	// From k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta
	Name                 *string  `protobuf:"bytes,5,opt,name=name" json:"name,omitempty"`
	Namespace            *string  `protobuf:"bytes,6,opt,name=namespace" json:"namespace,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ObjectMeta) Reset()         { *m = ObjectMeta{} }
func (m *ObjectMeta) String() string { return proto.CompactTextString(m) }
func (*ObjectMeta) ProtoMessage()    {}
func (*ObjectMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{19}
}
func (m *ObjectMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectMeta.Merge(m, src)
}
func (m *ObjectMeta) XXX_Size() int {
	return m.Size()
}
func (m *ObjectMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectMeta.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectMeta proto.InternalMessageInfo

func (m *ObjectMeta) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ObjectMeta) GetNamespace() string {
	if m != nil && m.Namespace != nil {
		return *m.Namespace
	}
	return ""
}

// FIXME: this should be moved out
type SdsConfig struct {
	Enabled              *bool    `protobuf:"varint,1,opt,name=enabled" json:"enabled,omitempty"`
	UdsPath              *string  `protobuf:"bytes,2,opt,name=uds_path,json=udsPath" json:"uds_path,omitempty"`
	UseTrustworthyJwt    *bool    `protobuf:"varint,3,opt,name=use_trustworthy_jwt,json=useTrustworthyJwt" json:"use_trustworthy_jwt,omitempty"`
	UseNormalJwt         *bool    `protobuf:"varint,4,opt,name=use_normal_jwt,json=useNormalJwt" json:"use_normal_jwt,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SdsConfig) Reset()         { *m = SdsConfig{} }
func (m *SdsConfig) String() string { return proto.CompactTextString(m) }
func (*SdsConfig) ProtoMessage()    {}
func (*SdsConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{20}
}
func (m *SdsConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SdsConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SdsConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SdsConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SdsConfig.Merge(m, src)
}
func (m *SdsConfig) XXX_Size() int {
	return m.Size()
}
func (m *SdsConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SdsConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SdsConfig proto.InternalMessageInfo

func (m *SdsConfig) GetEnabled() bool {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return false
}

func (m *SdsConfig) GetUdsPath() string {
	if m != nil && m.UdsPath != nil {
		return *m.UdsPath
	}
	return ""
}

func (m *SdsConfig) GetUseTrustworthyJwt() bool {
	if m != nil && m.UseTrustworthyJwt != nil {
		return *m.UseTrustworthyJwt
	}
	return false
}

func (m *SdsConfig) GetUseNormalJwt() bool {
	if m != nil && m.UseNormalJwt != nil {
		return *m.UseNormalJwt
	}
	return false
}

// TestKube are for testing that k8s resources unmarshal correctly.
type TestKube struct {
	Resources           *ResourceRequirements           `protobuf:"bytes,80,opt,name=resources" json:"resources,omitempty"`
	ReadinessProbe      *v11.Probe                      `protobuf:"bytes,81,opt,name=readiness_probe,json=readinessProbe" json:"readiness_probe,omitempty"`
	HpaSpec             *v1.HorizontalPodAutoscalerSpec `protobuf:"bytes,51,opt,name=hpa_spec,json=hpaSpec" json:"hpa_spec,omitempty"`
	PodDisruptionBudget *PodDisruptionBudgetSpec        `protobuf:"bytes,52,opt,name=pod_disruption_budget,json=podDisruptionBudget" json:"pod_disruption_budget,omitempty"`
	// Kustomize style overrides for k8s resources in rendered manifests.
	ResourceOverride     []*ResourceOverride `protobuf:"bytes,100,rep,name=resource_override,json=resourceOverride" json:"resource_override,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TestKube) Reset()         { *m = TestKube{} }
func (m *TestKube) String() string { return proto.CompactTextString(m) }
func (*TestKube) ProtoMessage()    {}
func (*TestKube) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{21}
}
func (m *TestKube) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestKube) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestKube.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestKube) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestKube.Merge(m, src)
}
func (m *TestKube) XXX_Size() int {
	return m.Size()
}
func (m *TestKube) XXX_DiscardUnknown() {
	xxx_messageInfo_TestKube.DiscardUnknown(m)
}

var xxx_messageInfo_TestKube proto.InternalMessageInfo

func (m *TestKube) GetResources() *ResourceRequirements {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *TestKube) GetReadinessProbe() *v11.Probe {
	if m != nil {
		return m.ReadinessProbe
	}
	return nil
}

func (m *TestKube) GetHpaSpec() *v1.HorizontalPodAutoscalerSpec {
	if m != nil {
		return m.HpaSpec
	}
	return nil
}

func (m *TestKube) GetPodDisruptionBudget() *PodDisruptionBudgetSpec {
	if m != nil {
		return m.PodDisruptionBudget
	}
	return nil
}

func (m *TestKube) GetResourceOverride() []*ResourceOverride {
	if m != nil {
		return m.ResourceOverride
	}
	return nil
}

func init() {
	proto.RegisterEnum("v1alpha1.ProxyConfig_InterceptionMode", ProxyConfig_InterceptionMode_name, ProxyConfig_InterceptionMode_value)
	proto.RegisterEnum("v1alpha1.TelemetryConfig_LoadSheddingMode", TelemetryConfig_LoadSheddingMode_name, TelemetryConfig_LoadSheddingMode_value)
	proto.RegisterEnum("v1alpha1.ResourceOverride_PatchType", ResourceOverride_PatchType_name, ResourceOverride_PatchType_value)
	proto.RegisterEnum("v1alpha1.ResourceOverride_Op", ResourceOverride_Op_name, ResourceOverride_Op_value)
	proto.RegisterType((*InstallerSpec)(nil), "v1alpha1.InstallerSpec")
	proto.RegisterType((*InstallerStatus)(nil), "v1alpha1.InstallerStatus")
	proto.RegisterType((*RemoteClusterConfig)(nil), "v1alpha1.RemoteClusterConfig")
	proto.RegisterType((*TrafficManagementConfig)(nil), "v1alpha1.TrafficManagementConfig")
	proto.RegisterType((*PilotConfig)(nil), "v1alpha1.PilotConfig")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.PilotConfig.AdditionalArgsEntry")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.PilotConfig.EnvEntry")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.PilotConfig.NodeSelectorEntry")
	proto.RegisterType((*ProxyConfig)(nil), "v1alpha1.ProxyConfig")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.ProxyConfig.AdditionalArgsEntry")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.ProxyConfig.EnvEntry")
	proto.RegisterType((*ProxyConfig_LightstepConfig)(nil), "v1alpha1.ProxyConfig.LightstepConfig")
	proto.RegisterType((*ProxyConfig_ZipkinConfig)(nil), "v1alpha1.ProxyConfig.ZipkinConfig")
	proto.RegisterType((*PolicyConfig)(nil), "v1alpha1.PolicyConfig")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.PolicyConfig.EnvEntry")
	proto.RegisterType((*TelemetryConfig)(nil), "v1alpha1.TelemetryConfig")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.TelemetryConfig.NodeSelectorEntry")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.TelemetryConfig.PodAnnotationsEntry")
	proto.RegisterType((*TelemetryConfig_Adapters)(nil), "v1alpha1.TelemetryConfig.Adapters")
	proto.RegisterType((*TelemetryConfig_Adapters_KubernetesEnv)(nil), "v1alpha1.TelemetryConfig.Adapters.KubernetesEnv")
	proto.RegisterType((*TelemetryConfig_Adapters_Stdio)(nil), "v1alpha1.TelemetryConfig.Adapters.Stdio")
	proto.RegisterType((*TelemetryConfig_Adapters_Prometheus)(nil), "v1alpha1.TelemetryConfig.Adapters.Prometheus")
	proto.RegisterType((*SecurityConfig)(nil), "v1alpha1.SecurityConfig")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.SecurityConfig.NodeSelectorEntry")
	proto.RegisterType((*SecurityConfig_CertManager)(nil), "v1alpha1.SecurityConfig.CertManager")
	proto.RegisterType((*ConfigManagementConfig)(nil), "v1alpha1.ConfigManagementConfig")
	proto.RegisterType((*IngressGatewayConfig)(nil), "v1alpha1.IngressGatewayConfig")
	proto.RegisterType((*IngressGatewayConfig_Sds)(nil), "v1alpha1.IngressGatewayConfig.Sds")
	proto.RegisterType((*EgressGatewayConfig)(nil), "v1alpha1.EgressGatewayConfig")
	proto.RegisterType((*IlbGatewayConfig)(nil), "v1alpha1.IlbGatewayConfig")
	proto.RegisterType((*GatewayConfig)(nil), "v1alpha1.GatewayConfig")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.GatewayConfig.EnvEntry")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.GatewayConfig.NodeSelectorEntry")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.GatewayConfig.PodAnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.GatewayConfig.ServiceAnnotationsEntry")
	proto.RegisterType((*GatewayConfig_Labels)(nil), "v1alpha1.GatewayConfig.Labels")
	proto.RegisterType((*OperatorConfig)(nil), "v1alpha1.OperatorConfig")
	proto.RegisterType((*IstioInstaller)(nil), "v1alpha1.IstioInstaller")
	proto.RegisterType((*ResourceRequirements)(nil), "v1alpha1.ResourceRequirements")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.ResourceRequirements.LimitsEntry")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.ResourceRequirements.RequestsEntry")
	proto.RegisterType((*PodDisruptionBudgetSpec)(nil), "v1alpha1.PodDisruptionBudgetSpec")
	proto.RegisterType((*ResourceOverride)(nil), "v1alpha1.ResourceOverride")
	proto.RegisterType((*ObjectMeta)(nil), "v1alpha1.ObjectMeta")
	proto.RegisterType((*SdsConfig)(nil), "v1alpha1.SdsConfig")
	proto.RegisterType((*TestKube)(nil), "v1alpha1.TestKube")
}

func init() { proto.RegisterFile("istioinstaller_types.proto", fileDescriptor_d0a1188b3d395975) }

var fileDescriptor_d0a1188b3d395975 = []byte{
	// 2874 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0x4b, 0x73, 0x1b, 0xc7,
	0xb5, 0x16, 0x48, 0x89, 0x02, 0x0e, 0x1e, 0x04, 0x9b, 0x22, 0x35, 0xe2, 0xf5, 0xa5, 0x68, 0x5c,
	0xf9, 0x9a, 0xf2, 0x03, 0x14, 0x69, 0x5f, 0x5f, 0xd9, 0x71, 0x9c, 0xa2, 0x48, 0x84, 0x82, 0xc2,
	0x07, 0x3c, 0x80, 0x1d, 0xdb, 0x49, 0x65, 0xd2, 0x9c, 0x69, 0x02, 0x2d, 0x0e, 0x66, 0xc6, 0xdd,
	0x3d, 0x10, 0xe1, 0x6d, 0x16, 0xc9, 0x0f, 0x48, 0xa5, 0xb2, 0xc8, 0x3e, 0xdb, 0x54, 0x65, 0x93,
	0xfc, 0x83, 0x2c, 0xb3, 0x48, 0x55, 0x2a, 0x8b, 0x54, 0xa5, 0x9c, 0x6d, 0x7e, 0x42, 0x52, 0x49,
	0xf5, 0x63, 0x80, 0x01, 0x08, 0xc8, 0x94, 0x2c, 0x2b, 0x5e, 0x64, 0x87, 0xfe, 0xce, 0x77, 0xce,
	0x74, 0xf7, 0x9c, 0x3e, 0xfd, 0x75, 0x0f, 0x60, 0x85, 0x72, 0x41, 0x43, 0x1a, 0x70, 0x81, 0x7d,
	0x9f, 0x30, 0x47, 0xf4, 0x23, 0xc2, 0xab, 0x11, 0x0b, 0x45, 0x88, 0xb2, 0xbd, 0x4d, 0xec, 0x47,
	0x1d, 0xbc, 0xb9, 0x52, 0x39, 0xbd, 0xcb, 0xab, 0x34, 0xdc, 0xc0, 0x11, 0xdd, 0x70, 0x43, 0x46,
	0x36, 0x7a, 0x9b, 0x1b, 0x6d, 0x12, 0x10, 0x86, 0x05, 0xf1, 0x34, 0x7b, 0xe5, 0x76, 0x8a, 0x83,
	0x63, 0x11, 0x72, 0x17, 0xfb, 0x34, 0x68, 0x4f, 0xa2, 0xbe, 0x39, 0xa4, 0x76, 0xb1, 0xdb, 0xa1,
	0x01, 0x61, 0xfd, 0x8d, 0xe8, 0xb4, 0x2d, 0x01, 0xbe, 0xd1, 0x25, 0x02, 0x4f, 0xf0, 0xaa, 0xfc,
	0x7a, 0x0e, 0x8a, 0xf5, 0xa4, 0xa3, 0xcd, 0x88, 0xb8, 0xe8, 0x0e, 0x5c, 0x33, 0x3d, 0x77, 0x22,
	0xec, 0x9e, 0xe2, 0x36, 0x71, 0x22, 0x2c, 0x3a, 0x56, 0x66, 0x2d, 0xb3, 0x9e, 0xb3, 0x91, 0xb1,
	0x35, 0xb4, 0xa9, 0x81, 0x45, 0x07, 0xbd, 0x0c, 0xf3, 0x6e, 0x18, 0x08, 0x16, 0xaa, 0xc1, 0x06,
	0xb8, 0x4b, 0xac, 0x19, 0x45, 0x2e, 0x0d, 0xe1, 0x43, 0xdc, 0x25, 0xa8, 0x0c, 0xb3, 0x9d, 0xf8,
	0xd8, 0x9a, 0x55, 0x46, 0xf9, 0x53, 0x22, 0x02, 0xb7, 0xad, 0xcb, 0x1a, 0x11, 0xb8, 0x8d, 0xee,
	0x82, 0xe5, 0x91, 0x13, 0x1c, 0xfb, 0x42, 0x45, 0xe2, 0x11, 0x76, 0x89, 0x13, 0x31, 0x72, 0x42,
	0xcf, 0xac, 0x2b, 0x8a, 0xb6, 0x6c, 0xec, 0x87, 0x89, 0xb9, 0xa1, 0xac, 0xe8, 0x7d, 0x58, 0x62,
	0xa4, 0x1b, 0x0a, 0xe2, 0xb8, 0x7e, 0xcc, 0x05, 0x61, 0x8e, 0x1b, 0x06, 0x27, 0xb4, 0x6d, 0xc1,
	0x5a, 0x66, 0x3d, 0xbf, 0xf5, 0xdf, 0xd5, 0x64, 0xe6, 0xab, 0xb6, 0xa2, 0xed, 0x68, 0xd6, 0x8e,
	0x22, 0xd9, 0x8b, 0xec, 0x3c, 0x88, 0x1a, 0x80, 0x04, 0xc3, 0x27, 0x27, 0xd4, 0x75, 0xba, 0x38,
	0xc0, 0x6d, 0xd2, 0x25, 0x81, 0xb0, 0xae, 0xa9, 0x78, 0x2f, 0x0e, 0xe3, 0xb5, 0x34, 0xe7, 0x60,
	0x40, 0x31, 0x31, 0x17, 0xc4, 0xb8, 0x01, 0x55, 0x61, 0x2e, 0x0a, 0x7d, 0xea, 0xf6, 0xad, 0x25,
	0x15, 0x65, 0x79, 0x18, 0xa5, 0xa1, 0x70, 0xe3, 0x6a, 0x58, 0xe8, 0xff, 0x21, 0x27, 0x88, 0x4f,
	0xba, 0x44, 0xb0, 0xbe, 0xb5, 0xac, 0x5c, 0x6e, 0xa4, 0x1e, 0x9c, 0x98, 0x8c, 0xd7, 0x90, 0x8b,
	0xde, 0x84, 0x2c, 0x27, 0x6e, 0xcc, 0xa8, 0xe8, 0x5b, 0xd7, 0x95, 0x9f, 0x35, 0xf4, 0x6b, 0x1a,
	0x8b, 0x71, 0x1b, 0x30, 0xd1, 0x01, 0x2c, 0xe8, 0x49, 0x4b, 0x8f, 0xd7, 0x52, 0xee, 0x6b, 0x43,
	0x77, 0xed, 0x76, 0x6e, 0xb8, 0x65, 0x77, 0x0c, 0x47, 0x7b, 0x30, 0x4f, 0x83, 0x36, 0x23, 0x9c,
	0x3b, 0x6d, 0x2c, 0xc8, 0x23, 0xdc, 0xb7, 0x56, 0xd7, 0x66, 0xd7, 0xf3, 0x5b, 0xab, 0xc3, 0x60,
	0x75, 0x4d, 0xd8, 0xd3, 0x76, 0x13, 0xaa, 0x44, 0x47, 0x50, 0xb4, 0x0b, 0x25, 0x32, 0x1a, 0xe7,
	0xa6, 0x8a, 0x93, 0x7a, 0xa9, 0xb5, 0x09, 0x61, 0x8a, 0x64, 0x24, 0xca, 0x1e, 0x20, 0x72, 0x26,
	0x08, 0x0b, 0xb0, 0xef, 0x84, 0x91, 0x5c, 0x07, 0x21, 0xe3, 0xd6, 0x96, 0x8a, 0x94, 0x9a, 0x9d,
	0x23, 0x63, 0x4a, 0xde, 0x62, 0xe2, 0x93, 0xe0, 0xbc, 0x82, 0x61, 0x7e, 0xb8, 0x68, 0x04, 0x16,
	0x31, 0x47, 0xff, 0x03, 0xc5, 0x88, 0x85, 0x67, 0x7d, 0xc7, 0xe4, 0xbc, 0x59, 0x2f, 0x05, 0x05,
	0xee, 0x68, 0x0c, 0xdd, 0x86, 0x32, 0xa7, 0x1e, 0x71, 0x31, 0x73, 0x68, 0xf0, 0x90, 0xb8, 0x22,
	0x64, 0x66, 0xa9, 0xcc, 0x1b, 0xbc, 0x6e, 0xe0, 0xca, 0x06, 0x2c, 0x4e, 0x48, 0x53, 0x64, 0xc1,
	0x55, 0x12, 0xe0, 0x63, 0x9f, 0x78, 0xea, 0x01, 0x59, 0x3b, 0x69, 0x56, 0xfe, 0x96, 0x81, 0xeb,
	0x53, 0x12, 0x71, 0xba, 0x17, 0x7a, 0x01, 0x72, 0x83, 0x65, 0x66, 0xba, 0x32, 0x04, 0xd0, 0x4b,
	0x50, 0x92, 0x55, 0xc7, 0x74, 0x96, 0x86, 0x81, 0x5a, 0xbb, 0x59, 0xbb, 0x28, 0xd1, 0x7a, 0x02,
	0xa2, 0xbb, 0x50, 0x88, 0xa8, 0x1f, 0x8a, 0x64, 0xc1, 0x5d, 0x56, 0x09, 0xb3, 0x94, 0x4a, 0x6d,
	0x69, 0x35, 0xd3, 0x99, 0x8f, 0x86, 0x0d, 0xe5, 0x99, 0xcc, 0x9a, 0xf4, 0xbc, 0x72, 0xce, 0xd3,
	0x4c, 0x9f, 0xf6, 0x1c, 0x36, 0x2a, 0x3f, 0xbd, 0x0a, 0xf9, 0x54, 0x58, 0x74, 0x0d, 0xae, 0x78,
	0xe4, 0x38, 0x6e, 0x9b, 0x01, 0xea, 0x86, 0x1c, 0xb8, 0x99, 0x58, 0x55, 0x05, 0xb2, 0x76, 0xd2,
	0x94, 0x43, 0x13, 0x4c, 0xd6, 0x16, 0x8e, 0xbb, 0x91, 0xac, 0xa9, 0x56, 0x7e, 0x2d, 0xb3, 0x3e,
	0x63, 0x17, 0x15, 0xda, 0x34, 0x20, 0xba, 0x0f, 0x37, 0x4f, 0x09, 0x89, 0xb0, 0x4f, 0x7b, 0xe4,
	0x00, 0x9f, 0x35, 0x09, 0xeb, 0xa9, 0x77, 0x11, 0xe8, 0xa1, 0x6f, 0xb7, 0x89, 0x55, 0x50, 0xb3,
	0xf6, 0x45, 0x34, 0x64, 0xc3, 0x3c, 0xf6, 0x3c, 0x2a, 0x9b, 0xd8, 0x77, 0x30, 0x6b, 0x27, 0x99,
	0x77, 0x7b, 0xe2, 0x3c, 0x55, 0xb7, 0x07, 0xe4, 0x6d, 0xd6, 0xe6, 0xb5, 0x40, 0xb0, 0xbe, 0x5d,
	0xc2, 0x23, 0x20, 0xba, 0x03, 0xb3, 0x24, 0xe8, 0x59, 0xef, 0x8e, 0xaf, 0xa9, 0x74, 0x9c, 0x5a,
	0xd0, 0xd3, 0xce, 0x92, 0x8a, 0xde, 0x85, 0x1c, 0x23, 0x3c, 0x8c, 0x99, 0x4b, 0xb8, 0xd5, 0x50,
	0xb3, 0xbd, 0x9a, 0x2e, 0x8c, 0xda, 0x64, 0x93, 0x4f, 0x63, 0xca, 0x54, 0x06, 0x71, 0x7b, 0xe8,
	0x20, 0x93, 0x9c, 0x91, 0xc8, 0xa7, 0x2e, 0x76, 0xdc, 0x30, 0x0e, 0x84, 0xf5, 0xc1, 0x5a, 0x66,
	0xbd, 0x68, 0x17, 0x0c, 0xb8, 0x23, 0x31, 0xf4, 0x3e, 0x64, 0x3b, 0x11, 0x76, 0x78, 0x44, 0x5c,
	0xeb, 0x43, 0xf5, 0x84, 0xb7, 0xaa, 0x7a, 0x6f, 0xaa, 0xe2, 0x88, 0x56, 0x53, 0xdb, 0x58, 0xb5,
	0xb7, 0x59, 0xbd, 0x1f, 0x32, 0xfa, 0x59, 0x18, 0x08, 0xec, 0x37, 0x42, 0x6f, 0xdb, 0xd8, 0xf4,
	0x56, 0x64, 0x5f, 0xed, 0x44, 0x58, 0xed, 0x49, 0x1f, 0xc0, 0x52, 0x14, 0x7a, 0x8e, 0x47, 0x39,
	0x8b, 0x23, 0x39, 0x7e, 0xe7, 0x38, 0xf6, 0xda, 0x44, 0x58, 0xdf, 0x1d, 0x2f, 0xc5, 0x8d, 0xd0,
	0xdb, 0x1d, 0xb0, 0xee, 0x29, 0x92, 0x0a, 0xb5, 0x18, 0x9d, 0x37, 0xa0, 0x7d, 0x28, 0x06, 0xa1,
	0x47, 0x1c, 0x4e, 0x7c, 0xbd, 0x16, 0xbf, 0xaf, 0x26, 0xf2, 0xe5, 0xc9, 0x13, 0x79, 0x18, 0x7a,
	0xa4, 0x69, 0x98, 0x7a, 0x46, 0x0b, 0x41, 0x0a, 0x42, 0x7b, 0xb0, 0x90, 0xcc, 0x94, 0x13, 0xf6,
	0x08, 0x63, 0xd4, 0x23, 0x96, 0xa7, 0x22, 0xae, 0x9c, 0x9f, 0xe2, 0x23, 0xc3, 0xb0, 0xcb, 0x6c,
	0x0c, 0x59, 0xd9, 0x86, 0xc5, 0x09, 0x2f, 0x5f, 0xee, 0x95, 0xa7, 0xa4, 0x6f, 0xea, 0x8a, 0xfc,
	0x29, 0x73, 0xbe, 0x87, 0xfd, 0x38, 0x59, 0xb8, 0xba, 0xf1, 0xce, 0xcc, 0xdd, 0xcc, 0xca, 0x5b,
	0x90, 0x4d, 0xde, 0xfb, 0x13, 0xf9, 0x7d, 0x0b, 0x16, 0xce, 0x0d, 0xf3, 0x49, 0x02, 0x54, 0xfe,
	0x5c, 0x80, 0x7c, 0x6a, 0xcd, 0x4e, 0x59, 0x96, 0xab, 0x00, 0x11, 0xa3, 0x3d, 0xea, 0x93, 0x36,
	0xf1, 0xcc, 0xca, 0x4c, 0x21, 0x52, 0x51, 0xe8, 0x02, 0xe5, 0x48, 0x61, 0xe4, 0xc5, 0xdd, 0x48,
	0xad, 0xce, 0xac, 0x5d, 0xd2, 0xf0, 0x8e, 0x41, 0x51, 0x13, 0x16, 0x68, 0x20, 0x08, 0x73, 0x89,
	0x4e, 0x8b, 0x6e, 0xe8, 0xe9, 0x05, 0x59, 0xda, 0xfa, 0xdf, 0x89, 0x45, 0xa4, 0x5a, 0x4f, 0xd1,
	0x0f, 0x42, 0x39, 0xff, 0x74, 0x0c, 0x41, 0x37, 0x21, 0xcf, 0x55, 0x51, 0x77, 0xa2, 0x90, 0x09,
	0xab, 0xa8, 0x72, 0x1c, 0x34, 0xd4, 0x08, 0x99, 0x40, 0xaf, 0xc0, 0x02, 0xed, 0x2a, 0x61, 0x14,
	0x4b, 0x95, 0xa4, 0xf7, 0xf3, 0x92, 0xae, 0xe3, 0xca, 0xd0, 0x88, 0x7d, 0x5f, 0x6f, 0xe7, 0x68,
	0x1d, 0xca, 0xba, 0xc2, 0xd1, 0x80, 0x0a, 0x47, 0x59, 0xad, 0x79, 0xad, 0x8e, 0x14, 0x5e, 0x0f,
	0xa8, 0xa8, 0x4b, 0x54, 0x45, 0x0d, 0x5c, 0x3f, 0xf6, 0x88, 0x43, 0x23, 0x87, 0xe1, 0xa0, 0x4d,
	0xb8, 0x55, 0x36, 0x51, 0xb5, 0xa1, 0x1e, 0xd9, 0x0a, 0x96, 0x5c, 0x72, 0x36, 0xce, 0x5d, 0xd0,
	0x5c, 0x63, 0x18, 0x70, 0xb7, 0x60, 0x69, 0x10, 0x37, 0x38, 0x0e, 0xe3, 0xc0, 0x53, 0xe3, 0xe2,
	0x16, 0x52, 0xfc, 0xc5, 0x24, 0xb6, 0xb6, 0xc9, 0x01, 0x2a, 0x9f, 0x41, 0xfc, 0x11, 0x9f, 0x45,
	0xed, 0x93, 0x3c, 0x23, 0xed, 0xa3, 0x65, 0xa0, 0xac, 0x78, 0x8e, 0xa0, 0x5d, 0x12, 0xc6, 0x5a,
	0x29, 0x69, 0x19, 0x28, 0xe1, 0x96, 0x46, 0x65, 0xe9, 0xf5, 0x18, 0xa6, 0x81, 0xe3, 0xc5, 0x0c,
	0xab, 0x5d, 0x65, 0x49, 0xf1, 0x8a, 0x0a, 0xdd, 0x35, 0xa0, 0x54, 0x82, 0x11, 0x66, 0x24, 0x10,
	0x0e, 0xef, 0xc4, 0xc2, 0x0b, 0x1f, 0xa5, 0x1c, 0x96, 0xb5, 0x12, 0xd4, 0xf6, 0xa6, 0x31, 0x0f,
	0x3c, 0xd7, 0x20, 0xef, 0x86, 0x81, 0x1b, 0x33, 0x46, 0x02, 0x57, 0xcb, 0x9f, 0xa2, 0x9d, 0x86,
	0x64, 0x17, 0x12, 0x91, 0xe8, 0x85, 0x5d, 0x4c, 0x03, 0x25, 0x72, 0x72, 0x76, 0xd1, 0xa0, 0xbb,
	0x0a, 0x44, 0x6f, 0xc3, 0x0d, 0x55, 0x77, 0x02, 0xee, 0x70, 0x82, 0x99, 0xdb, 0x19, 0x6a, 0x52,
	0x6e, 0xdd, 0x30, 0x7d, 0x08, 0xbd, 0xdd, 0x80, 0x37, 0x95, 0x79, 0x20, 0x49, 0x39, 0xda, 0x81,
	0x9c, 0x4f, 0xdb, 0x1d, 0xc1, 0x05, 0x89, 0xac, 0x55, 0x55, 0xa6, 0x5e, 0x9a, 0x9c, 0x91, 0xfb,
	0x09, 0x2d, 0x11, 0x71, 0x03, 0x3f, 0xf4, 0x0e, 0xcc, 0x7d, 0x46, 0xa3, 0x53, 0x1a, 0x58, 0x37,
	0x55, 0x84, 0xca, 0xe4, 0x08, 0x9f, 0x28, 0x4e, 0xa2, 0x1c, 0xb5, 0x07, 0x7a, 0x09, 0x66, 0xb9,
	0xc7, 0xad, 0x75, 0xe5, 0xb8, 0x98, 0xd2, 0x7e, 0x1e, 0x37, 0x4c, 0x69, 0xbf, 0xd8, 0xb6, 0x94,
	0x7a, 0xd6, 0x97, 0xda, 0x96, 0x52, 0x71, 0x9e, 0xe5, 0xb6, 0x74, 0x0f, 0xe6, 0x19, 0xc1, 0x1e,
	0x0d, 0xa4, 0x40, 0x8c, 0x58, 0x78, 0x4c, 0xac, 0xf7, 0x8d, 0x54, 0x4e, 0x6d, 0x3c, 0xb2, 0x94,
	0xc8, 0x1d, 0xa7, 0x21, 0x09, 0x76, 0x69, 0xe0, 0xa1, 0xda, 0xcf, 0xae, 0x7a, 0xff, 0x24, 0x03,
	0xf3, 0x63, 0xaf, 0x54, 0xca, 0x10, 0xec, 0x79, 0x52, 0x8a, 0x9a, 0x2a, 0x9a, 0x34, 0xd1, 0x8b,
	0x50, 0xc0, 0xae, 0x2b, 0xfb, 0x2d, 0xc2, 0x53, 0x12, 0x98, 0x82, 0x9a, 0xd7, 0x58, 0x4b, 0x42,
	0x68, 0x0d, 0x0a, 0x72, 0xbf, 0x25, 0x4c, 0xe8, 0x83, 0x98, 0x3e, 0x3e, 0x81, 0x8b, 0x77, 0x08,
	0x13, 0xea, 0x00, 0xb6, 0x0c, 0x73, 0x4a, 0xc1, 0x13, 0xa5, 0xbc, 0xb2, 0xb6, 0x69, 0xad, 0xac,
	0x43, 0x21, 0x9d, 0x1a, 0xd3, 0xbb, 0xf1, 0x6f, 0xdc, 0x72, 0x2a, 0xaf, 0x41, 0x79, 0xbc, 0x26,
	0xa3, 0x02, 0x64, 0xed, 0xda, 0x6e, 0xdd, 0xae, 0xed, 0xb4, 0xca, 0x97, 0x10, 0xc0, 0x5c, 0xab,
	0x61, 0x1f, 0x7d, 0xf4, 0x71, 0x39, 0x53, 0xf9, 0xf1, 0x65, 0x28, 0xa4, 0x0f, 0x4a, 0x4f, 0x2d,
	0x6d, 0x37, 0xd3, 0x39, 0x7a, 0x73, 0xf2, 0x29, 0xec, 0x3f, 0xda, 0x69, 0xba, 0x76, 0x7a, 0x66,
	0xeb, 0xe5, 0x69, 0xf3, 0xe6, 0xef, 0x39, 0x98, 0x1f, 0x3b, 0xff, 0x3e, 0x75, 0x32, 0xdc, 0x05,
	0x8b, 0x13, 0xce, 0xe5, 0xe4, 0xc8, 0x03, 0x54, 0x40, 0x45, 0xdf, 0x49, 0x02, 0x69, 0x75, 0xb2,
	0x6c, 0xec, 0xdb, 0xc6, 0x5c, 0x33, 0x71, 0x3f, 0x02, 0xe4, 0x87, 0xd8, 0x73, 0x78, 0x87, 0x78,
	0x1e, 0x0d, 0xda, 0x5a, 0x81, 0xe4, 0x95, 0x02, 0x79, 0x65, 0xea, 0x41, 0xbd, 0xba, 0x1f, 0x62,
	0xaf, 0x69, 0x5c, 0xb4, 0x0a, 0xf1, 0xc7, 0x10, 0x54, 0x83, 0x9b, 0xa3, 0x91, 0x7d, 0x2c, 0xe4,
	0xde, 0xe5, 0x88, 0x0e, 0x23, 0xbc, 0x13, 0xfa, 0x9e, 0x39, 0x79, 0xbc, 0x90, 0x76, 0xdd, 0xd7,
	0xa4, 0x56, 0xc2, 0x39, 0x9f, 0x76, 0x8d, 0x09, 0x69, 0xf7, 0x21, 0xcc, 0xcb, 0x1c, 0xc1, 0x41,
	0x10, 0x0a, 0xb5, 0x85, 0x72, 0xeb, 0x13, 0xf5, 0x2a, 0x5f, 0x9f, 0x3e, 0x04, 0x99, 0x72, 0x43,
	0xbe, 0xd9, 0x08, 0xa2, 0x11, 0x10, 0x35, 0x26, 0x0b, 0xec, 0x57, 0xa7, 0x47, 0x7d, 0x6e, 0x22,
	0xfb, 0x1f, 0xb3, 0x90, 0xdd, 0xf6, 0x70, 0x24, 0x08, 0xe3, 0x52, 0xa4, 0xc5, 0x9c, 0x38, 0x58,
	0xb7, 0x9d, 0x1d, 0x7b, 0x97, 0x9b, 0x04, 0x2a, 0xc5, 0x9c, 0x18, 0x9a, 0x44, 0x91, 0x07, 0x4b,
	0xa7, 0xf1, 0x31, 0x61, 0x01, 0x11, 0x84, 0x3b, 0x24, 0xe8, 0x25, 0x27, 0xd7, 0x19, 0xb5, 0x9a,
	0xee, 0x4c, 0x1f, 0x59, 0xf2, 0xb0, 0xea, 0x77, 0x06, 0xfe, 0xb5, 0xa0, 0x67, 0x2f, 0x9e, 0xa6,
	0x9b, 0x26, 0x8f, 0xdf, 0x83, 0x2b, 0x5c, 0x78, 0x34, 0x54, 0xb5, 0x3e, 0xbf, 0xb5, 0x7e, 0x81,
	0xa8, 0x4d, 0xc9, 0xb7, 0xb5, 0x1b, 0x3a, 0x90, 0xfa, 0x3a, 0xec, 0x12, 0xd1, 0x21, 0x31, 0x37,
	0xc7, 0xf1, 0xd7, 0x2f, 0x10, 0xa4, 0x31, 0x70, 0xb2, 0x53, 0x01, 0x56, 0x6e, 0x43, 0x71, 0xa4,
	0xd3, 0xd3, 0xd7, 0xd9, 0xca, 0x1e, 0x5c, 0x51, 0x3d, 0x79, 0xcc, 0x52, 0xbc, 0x05, 0xa5, 0x30,
	0x16, 0x51, 0x2c, 0x1c, 0xcc, 0x9d, 0x87, 0x3c, 0xd4, 0x9b, 0x5e, 0xd6, 0x2e, 0x68, 0x74, 0x9b,
	0x3f, 0xe0, 0x61, 0xb0, 0xf2, 0x03, 0x80, 0x61, 0x6f, 0x1e, 0x13, 0xed, 0x2d, 0xb8, 0x2e, 0x87,
	0x42, 0x5d, 0xee, 0x90, 0xb3, 0x88, 0xb2, 0xfe, 0x50, 0x24, 0xea, 0x65, 0xbe, 0x64, 0xcc, 0x35,
	0x65, 0x4d, 0x34, 0xa2, 0xdc, 0xf1, 0x26, 0x64, 0xf0, 0xf3, 0x3d, 0x2c, 0xbd, 0x03, 0xe5, 0xf1,
	0x42, 0x80, 0xf2, 0x70, 0xb5, 0x76, 0xf8, 0xed, 0x23, 0x7b, 0xa7, 0x56, 0xbe, 0x24, 0x1b, 0xfb,
	0x47, 0x7b, 0x47, 0x87, 0xfb, 0x1f, 0x97, 0x33, 0x72, 0x53, 0xdc, 0xad, 0x37, 0xb7, 0xef, 0xed,
	0xd7, 0x76, 0xcb, 0x33, 0x95, 0x3f, 0x5e, 0x86, 0xd2, 0xe8, 0x35, 0xde, 0x53, 0x57, 0xbf, 0x6b,
	0x70, 0x45, 0x9f, 0x4b, 0x40, 0x77, 0x50, 0x35, 0xd4, 0x29, 0x88, 0xf8, 0x27, 0x0e, 0xa7, 0xed,
	0x80, 0x78, 0xe6, 0xfc, 0x05, 0x12, 0x6a, 0x2a, 0x04, 0xbd, 0x06, 0xc8, 0x65, 0x04, 0x0b, 0xe2,
	0x74, 0x09, 0xef, 0x24, 0xc7, 0xa0, 0x82, 0xe2, 0x95, 0xb5, 0xe5, 0x80, 0xf0, 0x8e, 0x39, 0x07,
	0x5d, 0xa8, 0x0e, 0x1d, 0x4d, 0xae, 0x17, 0xaf, 0x4c, 0xbb, 0xb9, 0x7c, 0x7e, 0xe5, 0xe2, 0x97,
	0x19, 0xc8, 0x4b, 0xbd, 0xa5, 0xaf, 0xd6, 0xd8, 0x53, 0xcf, 0xf5, 0x45, 0xae, 0xc0, 0x47, 0x74,
	0x86, 0xfd, 0x84, 0x3a, 0xe3, 0xcb, 0x67, 0xe5, 0x1f, 0x32, 0xb0, 0x3c, 0xf9, 0x86, 0xf7, 0x19,
	0x67, 0xd8, 0x85, 0x52, 0xe2, 0x59, 0xbd, 0xc1, 0xca, 0x9f, 0x32, 0x70, 0x6d, 0xd2, 0x5d, 0xb3,
	0x2c, 0xfe, 0x6a, 0xa3, 0x3d, 0xc6, 0x3e, 0x0e, 0x5c, 0xc2, 0x1c, 0xda, 0x50, 0xd9, 0x9e, 0xb3,
	0x4b, 0x12, 0xbf, 0x67, 0xe0, 0x7a, 0x03, 0x7d, 0x13, 0xfe, 0x6b, 0x94, 0x69, 0xfa, 0x65, 0xce,
	0xdf, 0x85, 0xb5, 0xd9, 0xf5, 0x9c, 0x6d, 0xa5, 0x9d, 0x9a, 0xfa, 0x55, 0xe9, 0x83, 0xf8, 0x8b,
	0x50, 0x18, 0x5c, 0x3f, 0xd3, 0x06, 0xb7, 0x8a, 0x8a, 0x9f, 0x4f, 0xb0, 0x7a, 0x83, 0xaf, 0xfc,
	0x1f, 0xcc, 0x36, 0xbd, 0xc7, 0x95, 0xbb, 0x89, 0x33, 0x59, 0xb9, 0x0f, 0x8b, 0x13, 0xae, 0xbf,
	0xd1, 0x26, 0x5c, 0x4d, 0xae, 0xcb, 0xf5, 0x37, 0x90, 0xeb, 0xc3, 0x19, 0x1b, 0xbd, 0x28, 0x4f,
	0x78, 0x95, 0x10, 0xca, 0x75, 0xff, 0xf8, 0xcb, 0x86, 0xb9, 0xf8, 0x9c, 0x56, 0x7e, 0x35, 0x07,
	0xc5, 0xd1, 0xc7, 0x21, 0xb8, 0x2c, 0xfa, 0x51, 0x32, 0x42, 0xf5, 0x1b, 0x6d, 0xa5, 0xd5, 0xfa,
	0xda, 0x94, 0xc7, 0x8f, 0xc9, 0xf5, 0xaf, 0x40, 0x4b, 0xb7, 0xa6, 0xe9, 0xa4, 0x57, 0xa7, 0x75,
	0xe9, 0x22, 0x2a, 0xe9, 0x87, 0xb0, 0xc8, 0x09, 0xeb, 0x51, 0x97, 0x8c, 0x44, 0xfe, 0x9e, 0x8a,
	0xbc, 0x31, 0x2d, 0x72, 0x53, 0xbb, 0x9c, 0x8b, 0x8e, 0xf8, 0x39, 0x03, 0x3a, 0x9c, 0x5c, 0x57,
	0x6f, 0x4f, 0x8b, 0xfd, 0xdc, 0xca, 0xea, 0x1d, 0x98, 0xdb, 0xc7, 0xc7, 0xc4, 0xe7, 0xb2, 0x42,
	0xe1, 0x28, 0x4a, 0x2a, 0x14, 0x8e, 0x22, 0x95, 0xea, 0x5c, 0xd0, 0x30, 0xa9, 0x50, 0xaa, 0xf1,
	0xd4, 0x37, 0x9b, 0xcf, 0x60, 0xbf, 0xaf, 0xc1, 0xf5, 0x29, 0x93, 0xfe, 0x7c, 0x65, 0xc3, 0x8f,
	0x32, 0x50, 0x1a, 0xfd, 0x46, 0x25, 0x4b, 0x69, 0x17, 0x07, 0xf4, 0x84, 0x70, 0x91, 0xfe, 0x5a,
	0x5b, 0x48, 0x40, 0x75, 0x4d, 0xf0, 0xf8, 0x1a, 0x5d, 0x85, 0xcb, 0x6a, 0xa9, 0x78, 0x6a, 0xa9,
	0x3c, 0xee, 0x35, 0x2a, 0x5e, 0x25, 0x82, 0x52, 0x5d, 0xbe, 0x91, 0xc1, 0x87, 0x30, 0xf4, 0xaa,
	0x89, 0x30, 0x3b, 0x5e, 0x24, 0x46, 0x3e, 0x30, 0x6b, 0x77, 0xb4, 0x09, 0x73, 0xfa, 0x46, 0xd5,
	0xc8, 0xd3, 0x1b, 0x93, 0xe8, 0x8a, 0x60, 0x1b, 0x62, 0xe5, 0x17, 0x33, 0x70, 0x6d, 0xd2, 0xee,
	0x87, 0xee, 0xc1, 0x9c, 0x4f, 0xbb, 0x54, 0x48, 0xd1, 0x3e, 0xa6, 0x17, 0x26, 0xf1, 0xab, 0xfb,
	0x8a, 0xac, 0x13, 0xdb, 0x78, 0xa2, 0xfb, 0x90, 0x65, 0xe4, 0xd3, 0x98, 0x70, 0xc1, 0xad, 0x19,
	0x15, 0xe5, 0xb5, 0x2f, 0x88, 0x62, 0x1b, 0xba, 0x8e, 0x33, 0xf0, 0x5e, 0x79, 0x1b, 0xf2, 0xa9,
	0x07, 0x3c, 0x51, 0x6a, 0x7c, 0x03, 0x8a, 0x23, 0x51, 0x9f, 0x28, 0x2d, 0x7e, 0x93, 0x81, 0xeb,
	0x53, 0x8e, 0xf0, 0x2a, 0x3f, 0x68, 0xe0, 0xe0, 0x1e, 0xa6, 0xbe, 0xdc, 0x48, 0x54, 0xc4, 0xa2,
	0x5d, 0xe8, 0xd2, 0x60, 0x3b, 0xc1, 0xd0, 0x11, 0x64, 0x07, 0x05, 0x42, 0x1f, 0x67, 0xde, 0x48,
	0x15, 0xcc, 0xc1, 0x9f, 0x0a, 0xaa, 0xd1, 0x69, 0x5b, 0x02, 0xbc, 0xda, 0x25, 0x02, 0xcb, 0xda,
	0xa9, 0x96, 0x70, 0x92, 0xcf, 0xf6, 0x20, 0x08, 0x7a, 0x19, 0xe6, 0xbb, 0xf8, 0xcc, 0x89, 0x83,
	0xe1, 0x73, 0x67, 0xd5, 0x73, 0x4b, 0x5d, 0x7c, 0xf6, 0xc1, 0x10, 0xad, 0xfc, 0x76, 0x06, 0xca,
	0xe3, 0x69, 0x86, 0x76, 0x00, 0x22, 0x2c, 0xdc, 0x8e, 0xfa, 0xfb, 0x84, 0xea, 0x70, 0x69, 0xeb,
	0xd6, 0xf4, 0xb4, 0xac, 0x36, 0x24, 0xb9, 0xd5, 0x8f, 0x88, 0x9d, 0x8b, 0x92, 0x9f, 0xe8, 0x75,
	0x98, 0x09, 0x23, 0x35, 0x9a, 0xd2, 0xe8, 0x3f, 0x00, 0xc6, 0x9c, 0x8f, 0x22, 0x7b, 0x26, 0x8c,
	0xe4, 0xde, 0x73, 0x4a, 0x03, 0xcf, 0xe8, 0x33, 0xf5, 0x5b, 0x0a, 0x61, 0x1c, 0x51, 0xa7, 0x47,
	0x18, 0x97, 0xa7, 0x0a, 0x2d, 0xd4, 0x00, 0x47, 0xf4, 0x43, 0x8d, 0xa0, 0x3b, 0x90, 0x95, 0x33,
	0xe1, 0x61, 0x81, 0xcd, 0x07, 0xcc, 0x6b, 0xa9, 0x8f, 0xc9, 0xc7, 0x0f, 0x89, 0x2b, 0x0e, 0x88,
	0xc0, 0xf6, 0x80, 0x55, 0xb9, 0x05, 0xb9, 0x41, 0x6f, 0x51, 0x11, 0x72, 0xcd, 0x96, 0xbd, 0xdd,
	0xaa, 0xed, 0xd5, 0x77, 0xca, 0x97, 0x50, 0x16, 0x2e, 0x3f, 0x68, 0x1e, 0x1d, 0x96, 0x33, 0x95,
	0x5b, 0x30, 0x73, 0x14, 0xa1, 0xab, 0x30, 0xbb, 0xbd, 0xbb, 0xab, 0xaf, 0xc1, 0x76, 0x6b, 0xfb,
	0xb5, 0x56, 0xad, 0x9c, 0x41, 0x39, 0xb8, 0xd2, 0xd8, 0x6e, 0xed, 0xdc, 0x2f, 0xcf, 0x54, 0xde,
	0x03, 0x18, 0x3e, 0x43, 0x0e, 0x40, 0xfd, 0x01, 0x43, 0xff, 0x55, 0x42, 0xfd, 0x1e, 0x5d, 0xf7,
	0x73, 0x63, 0xeb, 0xbe, 0xf2, 0xb3, 0x0c, 0xe4, 0x06, 0x77, 0xc2, 0x8f, 0x51, 0x1e, 0x37, 0x20,
	0x1b, 0x7b, 0x5c, 0x57, 0x17, 0x9d, 0x7b, 0x57, 0x63, 0x8f, 0xab, 0xc2, 0x52, 0x85, 0x45, 0x79,
	0x7c, 0x16, 0x2c, 0xe6, 0xe2, 0x51, 0xc8, 0x44, 0xa7, 0xef, 0x3c, 0x7c, 0x24, 0xcc, 0xb7, 0xe2,
	0x85, 0x98, 0x93, 0xd6, 0xd0, 0xf2, 0xe0, 0x91, 0x90, 0x27, 0x40, 0xc9, 0x0f, 0x42, 0xd6, 0xc5,
	0xbe, 0xa2, 0xea, 0x7b, 0xcb, 0x42, 0xcc, 0xc9, 0xa1, 0x02, 0x1f, 0x3c, 0x12, 0x95, 0x7f, 0xce,
	0x40, 0xb6, 0x45, 0xb8, 0x90, 0x47, 0xcf, 0xaf, 0xc1, 0x05, 0x71, 0x5a, 0x4e, 0xbc, 0xf1, 0x15,
	0x5f, 0xcd, 0xbd, 0xf9, 0xb5, 0xb8, 0x9a, 0xbb, 0x57, 0xfe, 0xdd, 0xe7, 0xab, 0x99, 0xdf, 0x7f,
	0xbe, 0x9a, 0xf9, 0xcb, 0xe7, 0xab, 0x99, 0x9f, 0xff, 0x75, 0xf5, 0xd2, 0xbf, 0x02, 0x00, 0x00,
	0xff, 0xff, 0x28, 0x98, 0x36, 0xd5, 0xda, 0x24, 0x00, 0x00,
}

func (m *InstallerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstallerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InstallPackagePath != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.InstallPackagePath)))
		i += copy(dAtA[i:], *m.InstallPackagePath)
	}
	if m.ControllerName != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.ControllerName)))
		i += copy(dAtA[i:], *m.ControllerName)
	}
	if m.Hub != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.Hub)))
		i += copy(dAtA[i:], *m.Hub)
	}
	if m.Tag != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.Tag)))
		i += copy(dAtA[i:], *m.Tag)
	}
	if m.DefaultNamespacePrefix != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.DefaultNamespacePrefix)))
		i += copy(dAtA[i:], *m.DefaultNamespacePrefix)
	}
	if m.RemoteClusterConfig != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.RemoteClusterConfig.Size()))
		n1, err := m.RemoteClusterConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.TrafficManagement != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.TrafficManagement.Size()))
		n2, err := m.TrafficManagement.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Policy != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Policy.Size()))
		n3, err := m.Policy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Telemetry != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Telemetry.Size()))
		n4, err := m.Telemetry.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Security != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Security.Size()))
		n5, err := m.Security.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.ConfigManagement != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ConfigManagement.Size()))
		n6, err := m.ConfigManagement.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.IngressGateway) > 0 {
		for _, msg := range m.IngressGateway {
			dAtA[i] = 0xf2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EgressGateway) > 0 {
		for _, msg := range m.EgressGateway {
			dAtA[i] = 0xfa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ExternalOperators) > 0 {
		for _, msg := range m.ExternalOperators {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InstallerStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstallerStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProxyControl != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.ProxyControl)))
		i += copy(dAtA[i:], *m.ProxyControl)
	}
	if m.SidecarInjector != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.SidecarInjector)))
		i += copy(dAtA[i:], *m.SidecarInjector)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RemoteClusterConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteClusterConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled != nil {
		dAtA[i] = 0x8
		i++
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TrafficManagementConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrafficManagementConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled != nil {
		dAtA[i] = 0x8
		i++
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Namespace != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.Namespace)))
		i += copy(dAtA[i:], *m.Namespace)
	}
	if m.AutoInjection != nil {
		dAtA[i] = 0x18
		i++
		if *m.AutoInjection {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PilotConfig != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.PilotConfig.Size()))
		n7, err := m.PilotConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.ProxyConfig != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ProxyConfig.Size()))
		n8, err := m.ProxyConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PilotConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PilotConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Debug != nil {
		dAtA[i] = 0x8
		i++
		if *m.Debug {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Sidecar != nil {
		dAtA[i] = 0x50
		i++
		if *m.Sidecar {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TraceSampling != nil {
		dAtA[i] = 0x5d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.TraceSampling))))
		i += 4
	}
	if m.KeepaliveMaxServerConnectionAge != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.KeepaliveMaxServerConnectionAge)))
		i += copy(dAtA[i:], *m.KeepaliveMaxServerConnectionAge)
	}
	if len(m.AdditionalArgs) > 0 {
		for k, _ := range m.AdditionalArgs {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x3
			i++
			v := m.AdditionalArgs[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Env) > 0 {
		for k, _ := range m.Env {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x3
			i++
			v := m.Env[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Resources != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Resources.Size()))
		n9, err := m.Resources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.ReplicaCount != nil {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(*m.ReplicaCount))
	}
	if m.HpaSpec != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.HpaSpec.Size()))
		n10, err := m.HpaSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.PodDisruptionBudget != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.PodDisruptionBudget.Size()))
		n11, err := m.PodDisruptionBudget.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.NodeSelector) > 0 {
		for k, _ := range m.NodeSelector {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x5
			i++
			v := m.NodeSelector[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.ResourceOverride) > 0 {
		for _, msg := range m.ResourceOverride {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProxyConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProxyConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Debug != nil {
		dAtA[i] = 0x8
		i++
		if *m.Debug {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Privileged != nil {
		dAtA[i] = 0x50
		i++
		if *m.Privileged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EnableCoredump != nil {
		dAtA[i] = 0x58
		i++
		if *m.EnableCoredump {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.InterceptionMode != nil {
		dAtA[i] = 0x60
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(*m.InterceptionMode))
	}
	if m.StatusPort != nil {
		dAtA[i] = 0x68
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(*m.StatusPort))
	}
	if m.ImagePullPolicy != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.ImagePullPolicy)))
		i += copy(dAtA[i:], *m.ImagePullPolicy)
	}
	if m.ProxyInitImage != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.ProxyInitImage)))
		i += copy(dAtA[i:], *m.ProxyInitImage)
	}
	if m.IncludeIpRanges != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.IncludeIpRanges)))
		i += copy(dAtA[i:], *m.IncludeIpRanges)
	}
	if m.ExcludeIpRanges != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.ExcludeIpRanges)))
		i += copy(dAtA[i:], *m.ExcludeIpRanges)
	}
	if m.IncludeInboundPorts != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.IncludeInboundPorts)))
		i += copy(dAtA[i:], *m.IncludeInboundPorts)
	}
	if m.ExcludeInboundPorts != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.ExcludeInboundPorts)))
		i += copy(dAtA[i:], *m.ExcludeInboundPorts)
	}
	if m.ConnectTimeout != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.ConnectTimeout)))
		i += copy(dAtA[i:], *m.ConnectTimeout)
	}
	if m.DrainDuration != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.DrainDuration)))
		i += copy(dAtA[i:], *m.DrainDuration)
	}
	if m.ParentShutdownDuration != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.ParentShutdownDuration)))
		i += copy(dAtA[i:], *m.ParentShutdownDuration)
	}
	if m.Concurrency != nil {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(*m.Concurrency))
	}
	if m.ClusterDomain != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.ClusterDomain)))
		i += copy(dAtA[i:], *m.ClusterDomain)
	}
	if m.PodDnsSearchNamespaces != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.PodDnsSearchNamespaces)))
		i += copy(dAtA[i:], *m.PodDnsSearchNamespaces)
	}
	if m.Lightstep != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Lightstep.Size()))
		n12, err := m.Lightstep.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Zipkin != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Zipkin.Size()))
		n13, err := m.Zipkin.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Sds != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Sds.Size()))
		n14, err := m.Sds.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.AdditionalArgs) > 0 {
		for k, _ := range m.AdditionalArgs {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x3
			i++
			v := m.AdditionalArgs[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Env) > 0 {
		for k, _ := range m.Env {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x3
			i++
			v := m.Env[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Resources != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Resources.Size()))
		n15, err := m.Resources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.ReadinessProbe != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ReadinessProbe.Size()))
		n16, err := m.ReadinessProbe.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if len(m.ResourceOverride) > 0 {
		for _, msg := range m.ResourceOverride {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProxyConfig_LightstepConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProxyConfig_LightstepConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.Address)))
		i += copy(dAtA[i:], *m.Address)
	}
	if m.AccessToken != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.AccessToken)))
		i += copy(dAtA[i:], *m.AccessToken)
	}
	if m.CaCertPath != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.CaCertPath)))
		i += copy(dAtA[i:], *m.CaCertPath)
	}
	if m.Secure != nil {
		dAtA[i] = 0x20
		i++
		if *m.Secure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProxyConfig_ZipkinConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProxyConfig_ZipkinConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.Address)))
		i += copy(dAtA[i:], *m.Address)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PolicyConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled != nil {
		dAtA[i] = 0x8
		i++
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Namespace != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.Namespace)))
		i += copy(dAtA[i:], *m.Namespace)
	}
	if len(m.Env) > 0 {
		for k, _ := range m.Env {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x3
			i++
			v := m.Env[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Resources != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Resources.Size()))
		n17, err := m.Resources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.ReplicaCount != nil {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(*m.ReplicaCount))
	}
	if m.HpaSpec != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.HpaSpec.Size()))
		n18, err := m.HpaSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.PodDisruptionBudget != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.PodDisruptionBudget.Size()))
		n19, err := m.PodDisruptionBudget.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if len(m.ResourceOverride) > 0 {
		for _, msg := range m.ResourceOverride {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TelemetryConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TelemetryConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled != nil {
		dAtA[i] = 0x8
		i++
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Namespace != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.Namespace)))
		i += copy(dAtA[i:], *m.Namespace)
	}
	if m.SessionAffinityEnabled != nil {
		dAtA[i] = 0x50
		i++
		if *m.SessionAffinityEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LoadSheddingMode != nil {
		dAtA[i] = 0x58
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(*m.LoadSheddingMode))
	}
	if m.LoadSheddingLatencyThreshold != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.LoadSheddingLatencyThreshold)))
		i += copy(dAtA[i:], *m.LoadSheddingLatencyThreshold)
	}
	if m.ReplicaCount != nil {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(*m.ReplicaCount))
	}
	if len(m.PodAnnotations) > 0 {
		for k, _ := range m.PodAnnotations {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x5
			i++
			v := m.PodAnnotations[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.NodeSelector) > 0 {
		for k, _ := range m.NodeSelector {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x5
			i++
			v := m.NodeSelector[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.ResourceOverride) > 0 {
		for _, msg := range m.ResourceOverride {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TelemetryConfig_Adapters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TelemetryConfig_Adapters) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UseAdapter_CRDs != nil {
		dAtA[i] = 0x8
		i++
		if *m.UseAdapter_CRDs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.KubernetesEnvConfig != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.KubernetesEnvConfig.Size()))
		n20, err := m.KubernetesEnvConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Stdio != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Stdio.Size()))
		n21, err := m.Stdio.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.Prometheus != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Prometheus.Size()))
		n22, err := m.Prometheus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TelemetryConfig_Adapters_KubernetesEnv) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TelemetryConfig_Adapters_KubernetesEnv) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled != nil {
		dAtA[i] = 0x8
		i++
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TelemetryConfig_Adapters_Stdio) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TelemetryConfig_Adapters_Stdio) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled != nil {
		dAtA[i] = 0x8
		i++
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OutputAsJson != nil {
		dAtA[i] = 0x10
		i++
		if *m.OutputAsJson {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TelemetryConfig_Adapters_Prometheus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TelemetryConfig_Adapters_Prometheus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled != nil {
		dAtA[i] = 0x8
		i++
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MetricsExpiryDuration != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.MetricsExpiryDuration)))
		i += copy(dAtA[i:], *m.MetricsExpiryDuration)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SecurityConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled != nil {
		dAtA[i] = 0x8
		i++
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Namespace != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.Namespace)))
		i += copy(dAtA[i:], *m.Namespace)
	}
	if m.Image != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.Image)))
		i += copy(dAtA[i:], *m.Image)
	}
	if m.SelfSigned != nil {
		dAtA[i] = 0x58
		i++
		if *m.SelfSigned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CreateMeshPolicy != nil {
		dAtA[i] = 0x60
		i++
		if *m.CreateMeshPolicy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReplicaCount != nil {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(*m.ReplicaCount))
	}
	if len(m.NodeSelector) > 0 {
		for k, _ := range m.NodeSelector {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x5
			i++
			v := m.NodeSelector[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.ResourceOverride) > 0 {
		for _, msg := range m.ResourceOverride {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SecurityConfig_CertManager) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityConfig_CertManager) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled != nil {
		dAtA[i] = 0x8
		i++
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Namespace != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.Namespace)))
		i += copy(dAtA[i:], *m.Namespace)
	}
	if m.Hub != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.Hub)))
		i += copy(dAtA[i:], *m.Hub)
	}
	if m.Tag != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.Tag)))
		i += copy(dAtA[i:], *m.Tag)
	}
	if m.Resources != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Resources.Size()))
		n23, err := m.Resources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConfigManagementConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigManagementConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled != nil {
		dAtA[i] = 0x8
		i++
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Namespace != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.Namespace)))
		i += copy(dAtA[i:], *m.Namespace)
	}
	if m.Image != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.Image)))
		i += copy(dAtA[i:], *m.Image)
	}
	if m.ReplicaCount != nil {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(*m.ReplicaCount))
	}
	if len(m.ResourceOverride) > 0 {
		for _, msg := range m.ResourceOverride {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *IngressGatewayConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngressGatewayConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LoadBalancerIP != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.LoadBalancerIP)))
		i += copy(dAtA[i:], *m.LoadBalancerIP)
	}
	if len(m.LoadBalancerSourceRanges) > 0 {
		for _, s := range m.LoadBalancerSourceRanges {
			dAtA[i] = 0x62
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ExternalIPs) > 0 {
		for _, s := range m.ExternalIPs {
			dAtA[i] = 0x6a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *IngressGatewayConfig_Sds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngressGatewayConfig_Sds) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled != nil {
		dAtA[i] = 0x8
		i++
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Image != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.Image)))
		i += copy(dAtA[i:], *m.Image)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EgressGatewayConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EgressGatewayConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Gateway != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Gateway.Size()))
		n24, err := m.Gateway.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *IlbGatewayConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IlbGatewayConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Gateway != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Gateway.Size()))
		n25, err := m.Gateway.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.LoadBalancerIP != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.LoadBalancerIP)))
		i += copy(dAtA[i:], *m.LoadBalancerIP)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GatewayConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GatewayConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.Type)))
		i += copy(dAtA[i:], *m.Type)
	}
	if len(m.Env) > 0 {
		for k, _ := range m.Env {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x3
			i++
			v := m.Env[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.HpaSpec != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.HpaSpec.Size()))
		n26, err := m.HpaSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if len(m.PodAnnotations) > 0 {
		for k, _ := range m.PodAnnotations {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x5
			i++
			v := m.PodAnnotations[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.ServiceAnnotations) > 0 {
		for k, _ := range m.ServiceAnnotations {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x5
			i++
			v := m.ServiceAnnotations[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.NodeSelector) > 0 {
		for k, _ := range m.NodeSelector {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x5
			i++
			v := m.NodeSelector[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.ResourceOverride) > 0 {
		for _, msg := range m.ResourceOverride {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GatewayConfig_Labels) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GatewayConfig_Labels) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.App != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.App)))
		i += copy(dAtA[i:], *m.App)
	}
	if m.Istio != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.Istio)))
		i += copy(dAtA[i:], *m.Istio)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OperatorConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperatorConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ManifestPath != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.ManifestPath)))
		i += copy(dAtA[i:], *m.ManifestPath)
	}
	if m.Namespace != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.Namespace)))
		i += copy(dAtA[i:], *m.Namespace)
	}
	if m.Spec != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Spec.Size()))
		n27, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *IstioInstaller) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IstioInstaller) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Spec.Size()))
		n28, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.Status != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Status.Size()))
		n29, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResourceRequirements) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceRequirements) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Limits) > 0 {
		for k, _ := range m.Limits {
			dAtA[i] = 0xa
			i++
			v := m.Limits[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Requests) > 0 {
		for k, _ := range m.Requests {
			dAtA[i] = 0x12
			i++
			v := m.Requests[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PodDisruptionBudgetSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodDisruptionBudgetSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MinAvailable != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(*m.MinAvailable))
	}
	if m.Selector != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Selector.Size()))
		n30, err := m.Selector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.MaxUnavailable != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(*m.MaxUnavailable))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResourceOverride) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceOverride) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PatchType != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(*m.PatchType))
	}
	if m.Op != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(*m.Op))
	}
	if m.Kind != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.Kind)))
		i += copy(dAtA[i:], *m.Kind)
	}
	if m.ApiVersion != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.ApiVersion)))
		i += copy(dAtA[i:], *m.ApiVersion)
	}
	if m.Metadata != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Metadata.Size()))
		n31, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ObjectMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.Namespace != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.Namespace)))
		i += copy(dAtA[i:], *m.Namespace)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SdsConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SdsConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled != nil {
		dAtA[i] = 0x8
		i++
		if *m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UdsPath != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(*m.UdsPath)))
		i += copy(dAtA[i:], *m.UdsPath)
	}
	if m.UseTrustworthyJwt != nil {
		dAtA[i] = 0x18
		i++
		if *m.UseTrustworthyJwt {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UseNormalJwt != nil {
		dAtA[i] = 0x20
		i++
		if *m.UseNormalJwt {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TestKube) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestKube) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HpaSpec != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.HpaSpec.Size()))
		n32, err := m.HpaSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.PodDisruptionBudget != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.PodDisruptionBudget.Size()))
		n33, err := m.PodDisruptionBudget.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.Resources != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Resources.Size()))
		n34, err := m.Resources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.ReadinessProbe != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ReadinessProbe.Size()))
		n35, err := m.ReadinessProbe.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if len(m.ResourceOverride) > 0 {
		for _, msg := range m.ResourceOverride {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintIstioinstallerTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *InstallerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InstallPackagePath != nil {
		l = len(*m.InstallPackagePath)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ControllerName != nil {
		l = len(*m.ControllerName)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Hub != nil {
		l = len(*m.Hub)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Tag != nil {
		l = len(*m.Tag)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.DefaultNamespacePrefix != nil {
		l = len(*m.DefaultNamespacePrefix)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.RemoteClusterConfig != nil {
		l = m.RemoteClusterConfig.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.TrafficManagement != nil {
		l = m.TrafficManagement.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Telemetry != nil {
		l = m.Telemetry.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Security != nil {
		l = m.Security.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ConfigManagement != nil {
		l = m.ConfigManagement.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.IngressGateway) > 0 {
		for _, e := range m.IngressGateway {
			l = e.Size()
			n += 2 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if len(m.EgressGateway) > 0 {
		for _, e := range m.EgressGateway {
			l = e.Size()
			n += 2 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if len(m.ExternalOperators) > 0 {
		for _, e := range m.ExternalOperators {
			l = e.Size()
			n += 2 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InstallerStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProxyControl != nil {
		l = len(*m.ProxyControl)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.SidecarInjector != nil {
		l = len(*m.SidecarInjector)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoteClusterConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TrafficManagementConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 2
	}
	if m.Namespace != nil {
		l = len(*m.Namespace)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.AutoInjection != nil {
		n += 2
	}
	if m.PilotConfig != nil {
		l = m.PilotConfig.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ProxyConfig != nil {
		l = m.ProxyConfig.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PilotConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Debug != nil {
		n += 2
	}
	if m.Sidecar != nil {
		n += 2
	}
	if m.TraceSampling != nil {
		n += 5
	}
	if m.KeepaliveMaxServerConnectionAge != nil {
		l = len(*m.KeepaliveMaxServerConnectionAge)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.AdditionalArgs) > 0 {
		for k, v := range m.AdditionalArgs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Env) > 0 {
		for k, v := range m.Env {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ReplicaCount != nil {
		n += 2 + sovIstioinstallerTypes(uint64(*m.ReplicaCount))
	}
	if m.HpaSpec != nil {
		l = m.HpaSpec.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.PodDisruptionBudget != nil {
		l = m.PodDisruptionBudget.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.NodeSelector) > 0 {
		for k, v := range m.NodeSelector {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if len(m.ResourceOverride) > 0 {
		for _, e := range m.ResourceOverride {
			l = e.Size()
			n += 2 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProxyConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Debug != nil {
		n += 2
	}
	if m.Privileged != nil {
		n += 2
	}
	if m.EnableCoredump != nil {
		n += 2
	}
	if m.InterceptionMode != nil {
		n += 1 + sovIstioinstallerTypes(uint64(*m.InterceptionMode))
	}
	if m.StatusPort != nil {
		n += 1 + sovIstioinstallerTypes(uint64(*m.StatusPort))
	}
	if m.ImagePullPolicy != nil {
		l = len(*m.ImagePullPolicy)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ProxyInitImage != nil {
		l = len(*m.ProxyInitImage)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.IncludeIpRanges != nil {
		l = len(*m.IncludeIpRanges)
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ExcludeIpRanges != nil {
		l = len(*m.ExcludeIpRanges)
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.IncludeInboundPorts != nil {
		l = len(*m.IncludeInboundPorts)
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ExcludeInboundPorts != nil {
		l = len(*m.ExcludeInboundPorts)
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ConnectTimeout != nil {
		l = len(*m.ConnectTimeout)
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.DrainDuration != nil {
		l = len(*m.DrainDuration)
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ParentShutdownDuration != nil {
		l = len(*m.ParentShutdownDuration)
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Concurrency != nil {
		n += 2 + sovIstioinstallerTypes(uint64(*m.Concurrency))
	}
	if m.ClusterDomain != nil {
		l = len(*m.ClusterDomain)
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.PodDnsSearchNamespaces != nil {
		l = len(*m.PodDnsSearchNamespaces)
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Lightstep != nil {
		l = m.Lightstep.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Zipkin != nil {
		l = m.Zipkin.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Sds != nil {
		l = m.Sds.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.AdditionalArgs) > 0 {
		for k, v := range m.AdditionalArgs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Env) > 0 {
		for k, v := range m.Env {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ReadinessProbe != nil {
		l = m.ReadinessProbe.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.ResourceOverride) > 0 {
		for _, e := range m.ResourceOverride {
			l = e.Size()
			n += 2 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProxyConfig_LightstepConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Address != nil {
		l = len(*m.Address)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.AccessToken != nil {
		l = len(*m.AccessToken)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.CaCertPath != nil {
		l = len(*m.CaCertPath)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Secure != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProxyConfig_ZipkinConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Address != nil {
		l = len(*m.Address)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PolicyConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 2
	}
	if m.Namespace != nil {
		l = len(*m.Namespace)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.Env) > 0 {
		for k, v := range m.Env {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ReplicaCount != nil {
		n += 2 + sovIstioinstallerTypes(uint64(*m.ReplicaCount))
	}
	if m.HpaSpec != nil {
		l = m.HpaSpec.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.PodDisruptionBudget != nil {
		l = m.PodDisruptionBudget.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.ResourceOverride) > 0 {
		for _, e := range m.ResourceOverride {
			l = e.Size()
			n += 2 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TelemetryConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 2
	}
	if m.Namespace != nil {
		l = len(*m.Namespace)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.SessionAffinityEnabled != nil {
		n += 2
	}
	if m.LoadSheddingMode != nil {
		n += 1 + sovIstioinstallerTypes(uint64(*m.LoadSheddingMode))
	}
	if m.LoadSheddingLatencyThreshold != nil {
		l = len(*m.LoadSheddingLatencyThreshold)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ReplicaCount != nil {
		n += 2 + sovIstioinstallerTypes(uint64(*m.ReplicaCount))
	}
	if len(m.PodAnnotations) > 0 {
		for k, v := range m.PodAnnotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if len(m.NodeSelector) > 0 {
		for k, v := range m.NodeSelector {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if len(m.ResourceOverride) > 0 {
		for _, e := range m.ResourceOverride {
			l = e.Size()
			n += 2 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TelemetryConfig_Adapters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseAdapter_CRDs != nil {
		n += 2
	}
	if m.KubernetesEnvConfig != nil {
		l = m.KubernetesEnvConfig.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Stdio != nil {
		l = m.Stdio.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Prometheus != nil {
		l = m.Prometheus.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TelemetryConfig_Adapters_KubernetesEnv) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TelemetryConfig_Adapters_Stdio) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 2
	}
	if m.OutputAsJson != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TelemetryConfig_Adapters_Prometheus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 2
	}
	if m.MetricsExpiryDuration != nil {
		l = len(*m.MetricsExpiryDuration)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 2
	}
	if m.Namespace != nil {
		l = len(*m.Namespace)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Image != nil {
		l = len(*m.Image)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.SelfSigned != nil {
		n += 2
	}
	if m.CreateMeshPolicy != nil {
		n += 2
	}
	if m.ReplicaCount != nil {
		n += 2 + sovIstioinstallerTypes(uint64(*m.ReplicaCount))
	}
	if len(m.NodeSelector) > 0 {
		for k, v := range m.NodeSelector {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if len(m.ResourceOverride) > 0 {
		for _, e := range m.ResourceOverride {
			l = e.Size()
			n += 2 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityConfig_CertManager) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 2
	}
	if m.Namespace != nil {
		l = len(*m.Namespace)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Hub != nil {
		l = len(*m.Hub)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Tag != nil {
		l = len(*m.Tag)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigManagementConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 2
	}
	if m.Namespace != nil {
		l = len(*m.Namespace)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Image != nil {
		l = len(*m.Image)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ReplicaCount != nil {
		n += 2 + sovIstioinstallerTypes(uint64(*m.ReplicaCount))
	}
	if len(m.ResourceOverride) > 0 {
		for _, e := range m.ResourceOverride {
			l = e.Size()
			n += 2 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IngressGatewayConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LoadBalancerIP != nil {
		l = len(*m.LoadBalancerIP)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.LoadBalancerSourceRanges) > 0 {
		for _, s := range m.LoadBalancerSourceRanges {
			l = len(s)
			n += 1 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if len(m.ExternalIPs) > 0 {
		for _, s := range m.ExternalIPs {
			l = len(s)
			n += 1 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IngressGatewayConfig_Sds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 2
	}
	if m.Image != nil {
		l = len(*m.Image)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EgressGatewayConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gateway != nil {
		l = m.Gateway.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IlbGatewayConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gateway != nil {
		l = m.Gateway.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.LoadBalancerIP != nil {
		l = len(*m.LoadBalancerIP)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GatewayConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		l = len(*m.Type)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.Env) > 0 {
		for k, v := range m.Env {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if m.HpaSpec != nil {
		l = m.HpaSpec.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.PodAnnotations) > 0 {
		for k, v := range m.PodAnnotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if len(m.ServiceAnnotations) > 0 {
		for k, v := range m.ServiceAnnotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if len(m.NodeSelector) > 0 {
		for k, v := range m.NodeSelector {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if len(m.ResourceOverride) > 0 {
		for _, e := range m.ResourceOverride {
			l = e.Size()
			n += 2 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GatewayConfig_Labels) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.App != nil {
		l = len(*m.App)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Istio != nil {
		l = len(*m.Istio)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OperatorConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ManifestPath != nil {
		l = len(*m.ManifestPath)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Namespace != nil {
		l = len(*m.Namespace)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IstioInstaller) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourceRequirements) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Limits) > 0 {
		for k, v := range m.Limits {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Requests) > 0 {
		for k, v := range m.Requests {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PodDisruptionBudgetSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinAvailable != nil {
		n += 1 + sovIstioinstallerTypes(uint64(*m.MinAvailable))
	}
	if m.Selector != nil {
		l = m.Selector.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.MaxUnavailable != nil {
		n += 1 + sovIstioinstallerTypes(uint64(*m.MaxUnavailable))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourceOverride) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PatchType != nil {
		n += 1 + sovIstioinstallerTypes(uint64(*m.PatchType))
	}
	if m.Op != nil {
		n += 1 + sovIstioinstallerTypes(uint64(*m.Op))
	}
	if m.Kind != nil {
		l = len(*m.Kind)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ApiVersion != nil {
		l = len(*m.ApiVersion)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Namespace != nil {
		l = len(*m.Namespace)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SdsConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		n += 2
	}
	if m.UdsPath != nil {
		l = len(*m.UdsPath)
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.UseTrustworthyJwt != nil {
		n += 2
	}
	if m.UseNormalJwt != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestKube) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HpaSpec != nil {
		l = m.HpaSpec.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.PodDisruptionBudget != nil {
		l = m.PodDisruptionBudget.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ReadinessProbe != nil {
		l = m.ReadinessProbe.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.ResourceOverride) > 0 {
		for _, e := range m.ResourceOverride {
			l = e.Size()
			n += 2 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovIstioinstallerTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozIstioinstallerTypes(x uint64) (n int) {
	return sovIstioinstallerTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *InstallerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstallerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstallerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstallPackagePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.InstallPackagePath = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControllerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ControllerName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hub", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Hub = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Tag = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultNamespacePrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DefaultNamespacePrefix = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteClusterConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemoteClusterConfig == nil {
				m.RemoteClusterConfig = &RemoteClusterConfig{}
			}
			if err := m.RemoteClusterConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficManagement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrafficManagement == nil {
				m.TrafficManagement = &TrafficManagementConfig{}
			}
			if err := m.TrafficManagement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &PolicyConfig{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Telemetry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Telemetry == nil {
				m.Telemetry = &TelemetryConfig{}
			}
			if err := m.Telemetry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Security", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Security == nil {
				m.Security = &SecurityConfig{}
			}
			if err := m.Security.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigManagement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigManagement == nil {
				m.ConfigManagement = &ConfigManagementConfig{}
			}
			if err := m.ConfigManagement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngressGateway = append(m.IngressGateway, &IngressGatewayConfig{})
			if err := m.IngressGateway[len(m.IngressGateway)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgressGateway = append(m.EgressGateway, &EgressGatewayConfig{})
			if err := m.EgressGateway[len(m.EgressGateway)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalOperators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalOperators = append(m.ExternalOperators, &OperatorConfig{})
			if err := m.ExternalOperators[len(m.ExternalOperators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstallerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstallerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstallerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyControl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ProxyControl = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SidecarInjector", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SidecarInjector = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteClusterConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteClusterConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteClusterConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrafficManagementConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrafficManagementConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrafficManagementConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Namespace = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoInjection", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.AutoInjection = &b
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PilotConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PilotConfig == nil {
				m.PilotConfig = &PilotConfig{}
			}
			if err := m.PilotConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProxyConfig == nil {
				m.ProxyConfig = &ProxyConfig{}
			}
			if err := m.ProxyConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PilotConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PilotConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PilotConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Debug = &b
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sidecar", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Sidecar = &b
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceSampling", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.TraceSampling = &v2
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepaliveMaxServerConnectionAge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.KeepaliveMaxServerConnectionAge = &s
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalArgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdditionalArgs == nil {
				m.AdditionalArgs = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AdditionalArgs[mapkey] = mapvalue
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Env == nil {
				m.Env = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Env[mapkey] = mapvalue
			iNdEx = postIndex
		case 80:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &ResourceRequirements{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 85:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaCount", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReplicaCount = &v
		case 86:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HpaSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HpaSpec == nil {
				m.HpaSpec = &v1.HorizontalPodAutoscalerSpec{}
			}
			if err := m.HpaSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 87:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodDisruptionBudget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodDisruptionBudget == nil {
				m.PodDisruptionBudget = &PodDisruptionBudgetSpec{}
			}
			if err := m.PodDisruptionBudget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 92:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeSelector == nil {
				m.NodeSelector = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeSelector[mapkey] = mapvalue
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceOverride", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceOverride = append(m.ResourceOverride, &ResourceOverride{})
			if err := m.ResourceOverride[len(m.ResourceOverride)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProxyConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProxyConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProxyConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Debug = &b
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Privileged = &b
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableCoredump", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.EnableCoredump = &b
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterceptionMode", wireType)
			}
			var v ProxyConfig_InterceptionMode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= ProxyConfig_InterceptionMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InterceptionMode = &v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusPort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StatusPort = &v
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePullPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ImagePullPolicy = &s
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyInitImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ProxyInitImage = &s
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeIpRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.IncludeIpRanges = &s
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeIpRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ExcludeIpRanges = &s
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeInboundPorts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.IncludeInboundPorts = &s
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeInboundPorts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ExcludeInboundPorts = &s
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectTimeout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ConnectTimeout = &s
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrainDuration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DrainDuration = &s
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentShutdownDuration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ParentShutdownDuration = &s
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Concurrency", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Concurrency = &v
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ClusterDomain = &s
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodDnsSearchNamespaces", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PodDnsSearchNamespaces = &s
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lightstep", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lightstep == nil {
				m.Lightstep = &ProxyConfig_LightstepConfig{}
			}
			if err := m.Lightstep.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zipkin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Zipkin == nil {
				m.Zipkin = &ProxyConfig_ZipkinConfig{}
			}
			if err := m.Zipkin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sds == nil {
				m.Sds = &SdsConfig{}
			}
			if err := m.Sds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalArgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdditionalArgs == nil {
				m.AdditionalArgs = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AdditionalArgs[mapkey] = mapvalue
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Env == nil {
				m.Env = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Env[mapkey] = mapvalue
			iNdEx = postIndex
		case 80:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &ResourceRequirements{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 81:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadinessProbe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadinessProbe == nil {
				m.ReadinessProbe = &v11.Probe{}
			}
			if err := m.ReadinessProbe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceOverride", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceOverride = append(m.ResourceOverride, &ResourceOverride{})
			if err := m.ResourceOverride[len(m.ResourceOverride)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProxyConfig_LightstepConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LightstepConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LightstepConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Address = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.AccessToken = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaCertPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CaCertPath = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Secure = &b
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProxyConfig_ZipkinConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZipkinConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZipkinConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Address = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Namespace = &s
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Env == nil {
				m.Env = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Env[mapkey] = mapvalue
			iNdEx = postIndex
		case 80:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &ResourceRequirements{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 85:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaCount", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReplicaCount = &v
		case 86:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HpaSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HpaSpec == nil {
				m.HpaSpec = &v1.HorizontalPodAutoscalerSpec{}
			}
			if err := m.HpaSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 87:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodDisruptionBudget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodDisruptionBudget == nil {
				m.PodDisruptionBudget = &PodDisruptionBudgetSpec{}
			}
			if err := m.PodDisruptionBudget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceOverride", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceOverride = append(m.ResourceOverride, &ResourceOverride{})
			if err := m.ResourceOverride[len(m.ResourceOverride)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TelemetryConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TelemetryConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TelemetryConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Namespace = &s
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionAffinityEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.SessionAffinityEnabled = &b
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadSheddingMode", wireType)
			}
			var v TelemetryConfig_LoadSheddingMode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= TelemetryConfig_LoadSheddingMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LoadSheddingMode = &v
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadSheddingLatencyThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.LoadSheddingLatencyThreshold = &s
			iNdEx = postIndex
		case 80:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaCount", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReplicaCount = &v
		case 90:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodAnnotations == nil {
				m.PodAnnotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PodAnnotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 92:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeSelector == nil {
				m.NodeSelector = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeSelector[mapkey] = mapvalue
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceOverride", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceOverride = append(m.ResourceOverride, &ResourceOverride{})
			if err := m.ResourceOverride[len(m.ResourceOverride)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TelemetryConfig_Adapters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Adapters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Adapters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseAdapter_CRDs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.UseAdapter_CRDs = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesEnvConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KubernetesEnvConfig == nil {
				m.KubernetesEnvConfig = &TelemetryConfig_Adapters_KubernetesEnv{}
			}
			if err := m.KubernetesEnvConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdio", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stdio == nil {
				m.Stdio = &TelemetryConfig_Adapters_Stdio{}
			}
			if err := m.Stdio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prometheus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prometheus == nil {
				m.Prometheus = &TelemetryConfig_Adapters_Prometheus{}
			}
			if err := m.Prometheus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TelemetryConfig_Adapters_KubernetesEnv) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubernetesEnv: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubernetesEnv: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TelemetryConfig_Adapters_Stdio) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stdio: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stdio: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputAsJson", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OutputAsJson = &b
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TelemetryConfig_Adapters_Prometheus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Prometheus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Prometheus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricsExpiryDuration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.MetricsExpiryDuration = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Namespace = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Image = &s
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfSigned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.SelfSigned = &b
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateMeshPolicy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.CreateMeshPolicy = &b
		case 80:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaCount", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReplicaCount = &v
		case 92:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeSelector == nil {
				m.NodeSelector = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeSelector[mapkey] = mapvalue
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceOverride", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceOverride = append(m.ResourceOverride, &ResourceOverride{})
			if err := m.ResourceOverride[len(m.ResourceOverride)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityConfig_CertManager) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertManager: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertManager: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Namespace = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hub", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Hub = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Tag = &s
			iNdEx = postIndex
		case 82:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &ResourceRequirements{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigManagementConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigManagementConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigManagementConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Namespace = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Image = &s
			iNdEx = postIndex
		case 80:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaCount", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReplicaCount = &v
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceOverride", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceOverride = append(m.ResourceOverride, &ResourceOverride{})
			if err := m.ResourceOverride[len(m.ResourceOverride)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngressGatewayConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngressGatewayConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngressGatewayConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancerIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.LoadBalancerIP = &s
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancerSourceRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadBalancerSourceRanges = append(m.LoadBalancerSourceRanges, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalIPs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalIPs = append(m.ExternalIPs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngressGatewayConfig_Sds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Image = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EgressGatewayConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EgressGatewayConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EgressGatewayConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gateway == nil {
				m.Gateway = &GatewayConfig{}
			}
			if err := m.Gateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IlbGatewayConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IlbGatewayConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IlbGatewayConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gateway == nil {
				m.Gateway = &GatewayConfig{}
			}
			if err := m.Gateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancerIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.LoadBalancerIP = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GatewayConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GatewayConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GatewayConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Type = &s
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Env == nil {
				m.Env = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Env[mapkey] = mapvalue
			iNdEx = postIndex
		case 86:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HpaSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HpaSpec == nil {
				m.HpaSpec = &v1.HorizontalPodAutoscalerSpec{}
			}
			if err := m.HpaSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 90:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodAnnotations == nil {
				m.PodAnnotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PodAnnotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 91:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceAnnotations == nil {
				m.ServiceAnnotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ServiceAnnotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 92:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeSelector == nil {
				m.NodeSelector = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeSelector[mapkey] = mapvalue
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceOverride", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceOverride = append(m.ResourceOverride, &ResourceOverride{})
			if err := m.ResourceOverride[len(m.ResourceOverride)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GatewayConfig_Labels) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Labels: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Labels: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.App = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Istio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Istio = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperatorConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperatorConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperatorConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManifestPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ManifestPath = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Namespace = &s
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &ResourceOverride{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IstioInstaller) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IstioInstaller: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IstioInstaller: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &InstallerSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &InstallerStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceRequirements) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceRequirements: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceRequirements: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limits == nil {
				m.Limits = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Limits[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Requests == nil {
				m.Requests = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Requests[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodDisruptionBudgetSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodDisruptionBudgetSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodDisruptionBudgetSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAvailable", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinAvailable = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Selector == nil {
				m.Selector = &v12.LabelSelector{}
			}
			if err := m.Selector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUnavailable", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxUnavailable = &v
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceOverride) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceOverride: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceOverride: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatchType", wireType)
			}
			var v ResourceOverride_PatchType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= ResourceOverride_PatchType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PatchType = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var v ResourceOverride_Op
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= ResourceOverride_Op(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Op = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Kind = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ApiVersion = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &ObjectMeta{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Namespace = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SdsConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SdsConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SdsConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Enabled = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdsPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.UdsPath = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseTrustworthyJwt", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.UseTrustworthyJwt = &b
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseNormalJwt", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.UseNormalJwt = &b
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestKube) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestKube: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestKube: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HpaSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HpaSpec == nil {
				m.HpaSpec = &v1.HorizontalPodAutoscalerSpec{}
			}
			if err := m.HpaSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodDisruptionBudget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodDisruptionBudget == nil {
				m.PodDisruptionBudget = &PodDisruptionBudgetSpec{}
			}
			if err := m.PodDisruptionBudget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 80:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &ResourceRequirements{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 81:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadinessProbe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadinessProbe == nil {
				m.ReadinessProbe = &v11.Probe{}
			}
			if err := m.ReadinessProbe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceOverride", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceOverride = append(m.ResourceOverride, &ResourceOverride{})
			if err := m.ResourceOverride[len(m.ResourceOverride)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipIstioinstallerTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthIstioinstallerTypes
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthIstioinstallerTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipIstioinstallerTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthIstioinstallerTypes
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthIstioinstallerTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowIstioinstallerTypes   = fmt.Errorf("proto: integer overflow")
)
