// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: istioinstaller_types.proto

package v1alpha1

import (
	fmt "fmt"
	io "io"
	math "math"

	protobuf "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	v11 "k8s.io/api/autoscaling/v1"
	v1 "k8s.io/api/core/v1"
	v12 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Default behavior of the sidecar for handling outbound traffic from the application.
type PolicyFeatureSpec_OutboundPolicy int32

const (
	// Outbound traffic to unknown destinations will be allowed, in case there are no
	// services or ServiceEntries for the destination port
	PolicyFeatureSpec_ALLOW_ANY PolicyFeatureSpec_OutboundPolicy = 0
	// Restrict outbound traffic to services defined in the service registry as well
	// as those defined through ServiceEntries
	PolicyFeatureSpec_REGISTRY_ONLY PolicyFeatureSpec_OutboundPolicy = 1
)

var PolicyFeatureSpec_OutboundPolicy_name = map[int32]string{
	0: "ALLOW_ANY",
	1: "REGISTRY_ONLY",
}

var PolicyFeatureSpec_OutboundPolicy_value = map[string]int32{
	"ALLOW_ANY":     0,
	"REGISTRY_ONLY": 1,
}

func (x PolicyFeatureSpec_OutboundPolicy) String() string {
	return proto.EnumName(PolicyFeatureSpec_OutboundPolicy_name, int32(x))
}

func (PolicyFeatureSpec_OutboundPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{3, 0}
}

// LogLevel sets the component log level. Mappings to underlying log levels are not necessarily 1:1 and depend on
// component support of these levels e.g. DEBUG or INFO may result in the same log verbosity.
type CommonComponentSpec_LogLevel int32

const (
	CommonComponentSpec_NONE  CommonComponentSpec_LogLevel = 0
	CommonComponentSpec_ERROR CommonComponentSpec_LogLevel = 1
	CommonComponentSpec_WARN  CommonComponentSpec_LogLevel = 2
	CommonComponentSpec_DEBUG CommonComponentSpec_LogLevel = 3
	CommonComponentSpec_INFO  CommonComponentSpec_LogLevel = 4
)

var CommonComponentSpec_LogLevel_name = map[int32]string{
	0: "NONE",
	1: "ERROR",
	2: "WARN",
	3: "DEBUG",
	4: "INFO",
}

var CommonComponentSpec_LogLevel_value = map[string]int32{
	"NONE":  0,
	"ERROR": 1,
	"WARN":  2,
	"DEBUG": 3,
	"INFO":  4,
}

func (x CommonComponentSpec_LogLevel) String() string {
	return proto.EnumName(CommonComponentSpec_LogLevel_name, int32(x))
}

func (CommonComponentSpec_LogLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{17, 0}
}

type IngressGatewaySpec_IngressType int32

const (
	IngressGatewaySpec_ISTIO      IngressGatewaySpec_IngressType = 0
	IngressGatewaySpec_KUBERNETES IngressGatewaySpec_IngressType = 1
)

var IngressGatewaySpec_IngressType_name = map[int32]string{
	0: "ISTIO",
	1: "KUBERNETES",
}

var IngressGatewaySpec_IngressType_value = map[string]int32{
	"ISTIO":      0,
	"KUBERNETES": 1,
}

func (x IngressGatewaySpec_IngressType) String() string {
	return proto.EnumName(IngressGatewaySpec_IngressType_name, int32(x))
}

func (IngressGatewaySpec_IngressType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{19, 0}
}

// External traffic policy.
type IngressGatewaySpec_ExternalTrafficPolicy int32

const (
	IngressGatewaySpec_NONE IngressGatewaySpec_ExternalTrafficPolicy = 0
	// Preserves source IP.
	IngressGatewaySpec_LOCAL   IngressGatewaySpec_ExternalTrafficPolicy = 1
	IngressGatewaySpec_CLUSTER IngressGatewaySpec_ExternalTrafficPolicy = 2
)

var IngressGatewaySpec_ExternalTrafficPolicy_name = map[int32]string{
	0: "NONE",
	1: "LOCAL",
	2: "CLUSTER",
}

var IngressGatewaySpec_ExternalTrafficPolicy_value = map[string]int32{
	"NONE":    0,
	"LOCAL":   1,
	"CLUSTER": 2,
}

func (x IngressGatewaySpec_ExternalTrafficPolicy) String() string {
	return proto.EnumName(IngressGatewaySpec_ExternalTrafficPolicy_name, int32(x))
}

func (IngressGatewaySpec_ExternalTrafficPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{19, 1}
}

type InstallStatus_Status int32

const (
	InstallStatus_NONE     InstallStatus_Status = 0
	InstallStatus_UPDATING InstallStatus_Status = 1
	InstallStatus_HEALTHY  InstallStatus_Status = 2
	InstallStatus_ERROR    InstallStatus_Status = 3
)

var InstallStatus_Status_name = map[int32]string{
	0: "NONE",
	1: "UPDATING",
	2: "HEALTHY",
	3: "ERROR",
}

var InstallStatus_Status_value = map[string]int32{
	"NONE":     0,
	"UPDATING": 1,
	"HEALTHY":  2,
	"ERROR":    3,
}

func (x InstallStatus_Status) String() string {
	return proto.EnumName(InstallStatus_Status_name, int32(x))
}

func (InstallStatus_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{25, 0}
}

type IstioControlPlane struct {
	Spec                 *IstioControlPlaneSpec `protobuf:"bytes,3,opt,name=spec,proto3" json:"spec,omitempty"`
	Status               *InstallStatus         `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *IstioControlPlane) Reset()         { *m = IstioControlPlane{} }
func (m *IstioControlPlane) String() string { return proto.CompactTextString(m) }
func (*IstioControlPlane) ProtoMessage()    {}
func (*IstioControlPlane) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{0}
}
func (m *IstioControlPlane) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IstioControlPlane) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IstioControlPlane.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IstioControlPlane) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IstioControlPlane.Merge(m, src)
}
func (m *IstioControlPlane) XXX_Size() int {
	return m.Size()
}
func (m *IstioControlPlane) XXX_DiscardUnknown() {
	xxx_messageInfo_IstioControlPlane.DiscardUnknown(m)
}

var xxx_messageInfo_IstioControlPlane proto.InternalMessageInfo

func (m *IstioControlPlane) GetSpec() *IstioControlPlaneSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *IstioControlPlane) GetStatus() *InstallStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// IstioControlPlaneSpec defines the desired state of IstioControlPlane.
// The spec is a used to define a customization of the default values that are supplied with an Istio charts release.
// It is grouped at the top level by feature, where behavior of Istio functional areas is specified.
// Each feature contains components, where k8s resource level defaults can be overridden.
// Because the spec is a customization API, specifying an empty InstallSpec results in a default Istio installation.
type IstioControlPlaneSpec struct {
	// Prefix added to all namespaces for any installed component.
	DefaultNamespacePrefix string `protobuf:"bytes,5,opt,name=default_namespace_prefix,json=defaultNamespacePrefix,proto3" json:"default_namespace_prefix,omitempty"`
	// Selection and configuration of core Istio features.
	TrafficManagement *TrafficManagementFeatureSpec `protobuf:"bytes,25,opt,name=traffic_management,json=trafficManagement,proto3" json:"traffic_management,omitempty"`
	Policy            *PolicyFeatureSpec            `protobuf:"bytes,26,opt,name=policy,proto3" json:"policy,omitempty"`
	Telemetry         *TelemetryFeatureSpec         `protobuf:"bytes,27,opt,name=telemetry,proto3" json:"telemetry,omitempty"`
	Security          *SecurityFeatureSpec          `protobuf:"bytes,28,opt,name=security,proto3" json:"security,omitempty"`
	ConfigManagement  *ConfigManagementFeatureSpec  `protobuf:"bytes,29,opt,name=config_management,json=configManagement,proto3" json:"config_management,omitempty"`
	AutoInjection     *AutoInjectionFeatureSpec     `protobuf:"bytes,30,opt,name=auto_injection,json=autoInjection,proto3" json:"auto_injection,omitempty"`
	// Ingress/egress gateway installation and configuration.
	IngressGateway []*IngressGatewaySpec `protobuf:"bytes,31,rep,name=ingress_gateway,json=ingressGateway,proto3" json:"ingress_gateway,omitempty"`
	EgressGateway  []*EgressGatewaySpec  `protobuf:"bytes,32,rep,name=egress_gateway,json=egressGateway,proto3" json:"egress_gateway,omitempty"`
	// Global k8s defaults. Can be overridden per component.
	K8SDefaults *KubernetesResourcesSpec `protobuf:"bytes,80,opt,name=k8s_defaults,json=k8sDefaults,proto3" json:"k8s_defaults,omitempty"`
	// URL for the base spec. e.g.
	//   istio-minimal.yaml (looks in default dir)
	//   file://var/istio/install/values/custom/custom-install.yaml
	// Uses compiled in default install spec by default.
	BaseSpecPath string `protobuf:"bytes,100,opt,name=base_spec_path,json=baseSpecPath,proto3" json:"base_spec_path,omitempty"`
	// URL for the install package. e.g.
	//   http://github.com/istio/istio/releases/install/1.1.2
	//   http://github.com/istio/istio/releases/install/lts
	//   file://tmp/istio-installer/nightly
	// Uses compiled in install package by default.
	CustomPackagePath string `protobuf:"bytes,102,opt,name=custom_package_path,json=customPackagePath,proto3" json:"custom_package_path,omitempty"`
	// Root for docker image paths e.g. docker.io/istio-release.
	// Releases are published to docker hub under 'istio' project.
	// Daily builds from prow are on gcr.io, and nightly builds from circle on docker.io/istionightly
	Hub string `protobuf:"bytes,103,opt,name=hub,proto3" json:"hub,omitempty"`
	// Version tag for docker images e.g. 1.0.6
	Tag                  string   `protobuf:"bytes,104,opt,name=tag,proto3" json:"tag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IstioControlPlaneSpec) Reset()         { *m = IstioControlPlaneSpec{} }
func (m *IstioControlPlaneSpec) String() string { return proto.CompactTextString(m) }
func (*IstioControlPlaneSpec) ProtoMessage()    {}
func (*IstioControlPlaneSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{1}
}
func (m *IstioControlPlaneSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IstioControlPlaneSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IstioControlPlaneSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IstioControlPlaneSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IstioControlPlaneSpec.Merge(m, src)
}
func (m *IstioControlPlaneSpec) XXX_Size() int {
	return m.Size()
}
func (m *IstioControlPlaneSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_IstioControlPlaneSpec.DiscardUnknown(m)
}

var xxx_messageInfo_IstioControlPlaneSpec proto.InternalMessageInfo

func (m *IstioControlPlaneSpec) GetDefaultNamespacePrefix() string {
	if m != nil {
		return m.DefaultNamespacePrefix
	}
	return ""
}

func (m *IstioControlPlaneSpec) GetTrafficManagement() *TrafficManagementFeatureSpec {
	if m != nil {
		return m.TrafficManagement
	}
	return nil
}

func (m *IstioControlPlaneSpec) GetPolicy() *PolicyFeatureSpec {
	if m != nil {
		return m.Policy
	}
	return nil
}

func (m *IstioControlPlaneSpec) GetTelemetry() *TelemetryFeatureSpec {
	if m != nil {
		return m.Telemetry
	}
	return nil
}

func (m *IstioControlPlaneSpec) GetSecurity() *SecurityFeatureSpec {
	if m != nil {
		return m.Security
	}
	return nil
}

func (m *IstioControlPlaneSpec) GetConfigManagement() *ConfigManagementFeatureSpec {
	if m != nil {
		return m.ConfigManagement
	}
	return nil
}

func (m *IstioControlPlaneSpec) GetAutoInjection() *AutoInjectionFeatureSpec {
	if m != nil {
		return m.AutoInjection
	}
	return nil
}

func (m *IstioControlPlaneSpec) GetIngressGateway() []*IngressGatewaySpec {
	if m != nil {
		return m.IngressGateway
	}
	return nil
}

func (m *IstioControlPlaneSpec) GetEgressGateway() []*EgressGatewaySpec {
	if m != nil {
		return m.EgressGateway
	}
	return nil
}

func (m *IstioControlPlaneSpec) GetK8SDefaults() *KubernetesResourcesSpec {
	if m != nil {
		return m.K8SDefaults
	}
	return nil
}

func (m *IstioControlPlaneSpec) GetBaseSpecPath() string {
	if m != nil {
		return m.BaseSpecPath
	}
	return ""
}

func (m *IstioControlPlaneSpec) GetCustomPackagePath() string {
	if m != nil {
		return m.CustomPackagePath
	}
	return ""
}

func (m *IstioControlPlaneSpec) GetHub() string {
	if m != nil {
		return m.Hub
	}
	return ""
}

func (m *IstioControlPlaneSpec) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

// Configuration options for traffic management.
type TrafficManagementFeatureSpec struct {
	// Selects whether traffic management is installed.
	// Must be enabled to enable any sub-component.
	Enabled              *protobuf.BoolValue                      `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Components           *TrafficManagementFeatureSpec_Components `protobuf:"bytes,50,opt,name=components,proto3" json:"components,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                 `json:"-"`
	XXX_unrecognized     []byte                                   `json:"-"`
	XXX_sizecache        int32                                    `json:"-"`
}

func (m *TrafficManagementFeatureSpec) Reset()         { *m = TrafficManagementFeatureSpec{} }
func (m *TrafficManagementFeatureSpec) String() string { return proto.CompactTextString(m) }
func (*TrafficManagementFeatureSpec) ProtoMessage()    {}
func (*TrafficManagementFeatureSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{2}
}
func (m *TrafficManagementFeatureSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrafficManagementFeatureSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrafficManagementFeatureSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrafficManagementFeatureSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrafficManagementFeatureSpec.Merge(m, src)
}
func (m *TrafficManagementFeatureSpec) XXX_Size() int {
	return m.Size()
}
func (m *TrafficManagementFeatureSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TrafficManagementFeatureSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TrafficManagementFeatureSpec proto.InternalMessageInfo

func (m *TrafficManagementFeatureSpec) GetEnabled() *protobuf.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *TrafficManagementFeatureSpec) GetComponents() *TrafficManagementFeatureSpec_Components {
	if m != nil {
		return m.Components
	}
	return nil
}

// Component specific config.
type TrafficManagementFeatureSpec_Components struct {
	// Namespace that all traffic management components are installed into.
	Namespace            string              `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Pilot                *PilotComponentSpec `protobuf:"bytes,20,opt,name=pilot,proto3" json:"pilot,omitempty"`
	Proxy                *ProxyComponentSpec `protobuf:"bytes,21,opt,name=proxy,proto3" json:"proxy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TrafficManagementFeatureSpec_Components) Reset() {
	*m = TrafficManagementFeatureSpec_Components{}
}
func (m *TrafficManagementFeatureSpec_Components) String() string { return proto.CompactTextString(m) }
func (*TrafficManagementFeatureSpec_Components) ProtoMessage()    {}
func (*TrafficManagementFeatureSpec_Components) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{2, 0}
}
func (m *TrafficManagementFeatureSpec_Components) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrafficManagementFeatureSpec_Components) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrafficManagementFeatureSpec_Components.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrafficManagementFeatureSpec_Components) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrafficManagementFeatureSpec_Components.Merge(m, src)
}
func (m *TrafficManagementFeatureSpec_Components) XXX_Size() int {
	return m.Size()
}
func (m *TrafficManagementFeatureSpec_Components) XXX_DiscardUnknown() {
	xxx_messageInfo_TrafficManagementFeatureSpec_Components.DiscardUnknown(m)
}

var xxx_messageInfo_TrafficManagementFeatureSpec_Components proto.InternalMessageInfo

func (m *TrafficManagementFeatureSpec_Components) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *TrafficManagementFeatureSpec_Components) GetPilot() *PilotComponentSpec {
	if m != nil {
		return m.Pilot
	}
	return nil
}

func (m *TrafficManagementFeatureSpec_Components) GetProxy() *ProxyComponentSpec {
	if m != nil {
		return m.Proxy
	}
	return nil
}

// Configuration options for the policy feature.
type PolicyFeatureSpec struct {
	// Selects whether policy is installed.
	// Must be enabled to enable any sub-component.
	Enabled *protobuf.BoolValue `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// If set, allows traffic in cases when the mixer policy service cannot be reached.
	PolicyCheckFailOpen *protobuf.BoolValue `protobuf:"bytes,10,opt,name=policy_check_fail_open,json=policyCheckFailOpen,proto3" json:"policy_check_fail_open,omitempty"`
	// Selects the outbound traffic policy mode.
	OutboundTrafficPolicyMode PolicyFeatureSpec_OutboundPolicy `protobuf:"varint,11,opt,name=outbound_traffic_policy_mode,json=outboundTrafficPolicyMode,proto3,enum=v1alpha1.PolicyFeatureSpec_OutboundPolicy" json:"outbound_traffic_policy_mode,omitempty"`
	Components                *PolicyFeatureSpec_Components    `protobuf:"bytes,50,opt,name=components,proto3" json:"components,omitempty"`
	XXX_NoUnkeyedLiteral      struct{}                         `json:"-"`
	XXX_unrecognized          []byte                           `json:"-"`
	XXX_sizecache             int32                            `json:"-"`
}

func (m *PolicyFeatureSpec) Reset()         { *m = PolicyFeatureSpec{} }
func (m *PolicyFeatureSpec) String() string { return proto.CompactTextString(m) }
func (*PolicyFeatureSpec) ProtoMessage()    {}
func (*PolicyFeatureSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{3}
}
func (m *PolicyFeatureSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicyFeatureSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PolicyFeatureSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PolicyFeatureSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyFeatureSpec.Merge(m, src)
}
func (m *PolicyFeatureSpec) XXX_Size() int {
	return m.Size()
}
func (m *PolicyFeatureSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyFeatureSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyFeatureSpec proto.InternalMessageInfo

func (m *PolicyFeatureSpec) GetEnabled() *protobuf.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *PolicyFeatureSpec) GetPolicyCheckFailOpen() *protobuf.BoolValue {
	if m != nil {
		return m.PolicyCheckFailOpen
	}
	return nil
}

func (m *PolicyFeatureSpec) GetOutboundTrafficPolicyMode() PolicyFeatureSpec_OutboundPolicy {
	if m != nil {
		return m.OutboundTrafficPolicyMode
	}
	return PolicyFeatureSpec_ALLOW_ANY
}

func (m *PolicyFeatureSpec) GetComponents() *PolicyFeatureSpec_Components {
	if m != nil {
		return m.Components
	}
	return nil
}

// Component specific config.
type PolicyFeatureSpec_Components struct {
	// Namespace that all policy components are installed into.
	Namespace            string               `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Policy               *PolicyComponentSpec `protobuf:"bytes,20,opt,name=policy,proto3" json:"policy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *PolicyFeatureSpec_Components) Reset()         { *m = PolicyFeatureSpec_Components{} }
func (m *PolicyFeatureSpec_Components) String() string { return proto.CompactTextString(m) }
func (*PolicyFeatureSpec_Components) ProtoMessage()    {}
func (*PolicyFeatureSpec_Components) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{3, 0}
}
func (m *PolicyFeatureSpec_Components) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicyFeatureSpec_Components) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PolicyFeatureSpec_Components.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PolicyFeatureSpec_Components) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyFeatureSpec_Components.Merge(m, src)
}
func (m *PolicyFeatureSpec_Components) XXX_Size() int {
	return m.Size()
}
func (m *PolicyFeatureSpec_Components) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyFeatureSpec_Components.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyFeatureSpec_Components proto.InternalMessageInfo

func (m *PolicyFeatureSpec_Components) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *PolicyFeatureSpec_Components) GetPolicy() *PolicyComponentSpec {
	if m != nil {
		return m.Policy
	}
	return nil
}

// Configuration options for the telemetry feature.
type TelemetryFeatureSpec struct {
	// Selects whether telemetry is installed.
	// Must be enabled to enable any sub-component.
	Enabled              *protobuf.BoolValue              `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Components           *TelemetryFeatureSpec_Components `protobuf:"bytes,50,opt,name=components,proto3" json:"components,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *TelemetryFeatureSpec) Reset()         { *m = TelemetryFeatureSpec{} }
func (m *TelemetryFeatureSpec) String() string { return proto.CompactTextString(m) }
func (*TelemetryFeatureSpec) ProtoMessage()    {}
func (*TelemetryFeatureSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{4}
}
func (m *TelemetryFeatureSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TelemetryFeatureSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TelemetryFeatureSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TelemetryFeatureSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TelemetryFeatureSpec.Merge(m, src)
}
func (m *TelemetryFeatureSpec) XXX_Size() int {
	return m.Size()
}
func (m *TelemetryFeatureSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TelemetryFeatureSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TelemetryFeatureSpec proto.InternalMessageInfo

func (m *TelemetryFeatureSpec) GetEnabled() *protobuf.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *TelemetryFeatureSpec) GetComponents() *TelemetryFeatureSpec_Components {
	if m != nil {
		return m.Components
	}
	return nil
}

// Component specific config.
type TelemetryFeatureSpec_Components struct {
	// Namespace that all telemetry components are installed into.
	Namespace            string                  `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Telemetry            *TelemetryComponentSpec `protobuf:"bytes,20,opt,name=telemetry,proto3" json:"telemetry,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *TelemetryFeatureSpec_Components) Reset()         { *m = TelemetryFeatureSpec_Components{} }
func (m *TelemetryFeatureSpec_Components) String() string { return proto.CompactTextString(m) }
func (*TelemetryFeatureSpec_Components) ProtoMessage()    {}
func (*TelemetryFeatureSpec_Components) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{4, 0}
}
func (m *TelemetryFeatureSpec_Components) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TelemetryFeatureSpec_Components) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TelemetryFeatureSpec_Components.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TelemetryFeatureSpec_Components) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TelemetryFeatureSpec_Components.Merge(m, src)
}
func (m *TelemetryFeatureSpec_Components) XXX_Size() int {
	return m.Size()
}
func (m *TelemetryFeatureSpec_Components) XXX_DiscardUnknown() {
	xxx_messageInfo_TelemetryFeatureSpec_Components.DiscardUnknown(m)
}

var xxx_messageInfo_TelemetryFeatureSpec_Components proto.InternalMessageInfo

func (m *TelemetryFeatureSpec_Components) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *TelemetryFeatureSpec_Components) GetTelemetry() *TelemetryComponentSpec {
	if m != nil {
		return m.Telemetry
	}
	return nil
}

// Configuration options for security feature.
type SecurityFeatureSpec struct {
	// Selects whether security feature is installed. Must be set for any sub-component to be installed.
	Enabled *protobuf.BoolValue `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Enables MTLS for control plane.
	// Will result in delays starting the pods while secrets are propagated, not recommended for tests.
	ControlPlaneMtls *protobuf.BoolValue `protobuf:"bytes,13,opt,name=control_plane_mtls,json=controlPlaneMtls,proto3" json:"control_plane_mtls,omitempty"`
	// Enables strict MTLS for service to service traffic, or permissive mode MTLS if unset.
	DataPlaneMtlsStrict  *protobuf.BoolValue             `protobuf:"bytes,14,opt,name=data_plane_mtls_strict,json=dataPlaneMtlsStrict,proto3" json:"data_plane_mtls_strict,omitempty"`
	Components           *SecurityFeatureSpec_Components `protobuf:"bytes,50,opt,name=components,proto3" json:"components,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *SecurityFeatureSpec) Reset()         { *m = SecurityFeatureSpec{} }
func (m *SecurityFeatureSpec) String() string { return proto.CompactTextString(m) }
func (*SecurityFeatureSpec) ProtoMessage()    {}
func (*SecurityFeatureSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{5}
}
func (m *SecurityFeatureSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityFeatureSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityFeatureSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityFeatureSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityFeatureSpec.Merge(m, src)
}
func (m *SecurityFeatureSpec) XXX_Size() int {
	return m.Size()
}
func (m *SecurityFeatureSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityFeatureSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityFeatureSpec proto.InternalMessageInfo

func (m *SecurityFeatureSpec) GetEnabled() *protobuf.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *SecurityFeatureSpec) GetControlPlaneMtls() *protobuf.BoolValue {
	if m != nil {
		return m.ControlPlaneMtls
	}
	return nil
}

func (m *SecurityFeatureSpec) GetDataPlaneMtlsStrict() *protobuf.BoolValue {
	if m != nil {
		return m.DataPlaneMtlsStrict
	}
	return nil
}

func (m *SecurityFeatureSpec) GetComponents() *SecurityFeatureSpec_Components {
	if m != nil {
		return m.Components
	}
	return nil
}

type SecurityFeatureSpec_Components struct {
	// Namespace that security components are installed into.
	Namespace            string                    `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Citadel              *CitadelComponentSpec     `protobuf:"bytes,20,opt,name=citadel,proto3" json:"citadel,omitempty"`
	CertManager          *CertManagerComponentSpec `protobuf:"bytes,21,opt,name=cert_manager,json=certManager,proto3" json:"cert_manager,omitempty"`
	NodeAgent            *NodeAgentComponentSpec   `protobuf:"bytes,22,opt,name=node_agent,json=nodeAgent,proto3" json:"node_agent,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *SecurityFeatureSpec_Components) Reset()         { *m = SecurityFeatureSpec_Components{} }
func (m *SecurityFeatureSpec_Components) String() string { return proto.CompactTextString(m) }
func (*SecurityFeatureSpec_Components) ProtoMessage()    {}
func (*SecurityFeatureSpec_Components) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{5, 0}
}
func (m *SecurityFeatureSpec_Components) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityFeatureSpec_Components) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityFeatureSpec_Components.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityFeatureSpec_Components) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityFeatureSpec_Components.Merge(m, src)
}
func (m *SecurityFeatureSpec_Components) XXX_Size() int {
	return m.Size()
}
func (m *SecurityFeatureSpec_Components) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityFeatureSpec_Components.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityFeatureSpec_Components proto.InternalMessageInfo

func (m *SecurityFeatureSpec_Components) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *SecurityFeatureSpec_Components) GetCitadel() *CitadelComponentSpec {
	if m != nil {
		return m.Citadel
	}
	return nil
}

func (m *SecurityFeatureSpec_Components) GetCertManager() *CertManagerComponentSpec {
	if m != nil {
		return m.CertManager
	}
	return nil
}

func (m *SecurityFeatureSpec_Components) GetNodeAgent() *NodeAgentComponentSpec {
	if m != nil {
		return m.NodeAgent
	}
	return nil
}

// Configuration options for configuration management feature.
type ConfigManagementFeatureSpec struct {
	// Selects whether config management feature is installed. Must be set for any sub-component to be installed.
	Enabled              *protobuf.BoolValue                     `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Components           *ConfigManagementFeatureSpec_Components `protobuf:"bytes,50,opt,name=components,proto3" json:"components,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                `json:"-"`
	XXX_unrecognized     []byte                                  `json:"-"`
	XXX_sizecache        int32                                   `json:"-"`
}

func (m *ConfigManagementFeatureSpec) Reset()         { *m = ConfigManagementFeatureSpec{} }
func (m *ConfigManagementFeatureSpec) String() string { return proto.CompactTextString(m) }
func (*ConfigManagementFeatureSpec) ProtoMessage()    {}
func (*ConfigManagementFeatureSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{6}
}
func (m *ConfigManagementFeatureSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigManagementFeatureSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigManagementFeatureSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigManagementFeatureSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigManagementFeatureSpec.Merge(m, src)
}
func (m *ConfigManagementFeatureSpec) XXX_Size() int {
	return m.Size()
}
func (m *ConfigManagementFeatureSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigManagementFeatureSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigManagementFeatureSpec proto.InternalMessageInfo

func (m *ConfigManagementFeatureSpec) GetEnabled() *protobuf.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *ConfigManagementFeatureSpec) GetComponents() *ConfigManagementFeatureSpec_Components {
	if m != nil {
		return m.Components
	}
	return nil
}

type ConfigManagementFeatureSpec_Components struct {
	// Namespace that security components are installed into.
	Namespace            string               `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Galley               *GalleyComponentSpec `protobuf:"bytes,20,opt,name=galley,proto3" json:"galley,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ConfigManagementFeatureSpec_Components) Reset() {
	*m = ConfigManagementFeatureSpec_Components{}
}
func (m *ConfigManagementFeatureSpec_Components) String() string { return proto.CompactTextString(m) }
func (*ConfigManagementFeatureSpec_Components) ProtoMessage()    {}
func (*ConfigManagementFeatureSpec_Components) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{6, 0}
}
func (m *ConfigManagementFeatureSpec_Components) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigManagementFeatureSpec_Components) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigManagementFeatureSpec_Components.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigManagementFeatureSpec_Components) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigManagementFeatureSpec_Components.Merge(m, src)
}
func (m *ConfigManagementFeatureSpec_Components) XXX_Size() int {
	return m.Size()
}
func (m *ConfigManagementFeatureSpec_Components) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigManagementFeatureSpec_Components.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigManagementFeatureSpec_Components proto.InternalMessageInfo

func (m *ConfigManagementFeatureSpec_Components) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ConfigManagementFeatureSpec_Components) GetGalley() *GalleyComponentSpec {
	if m != nil {
		return m.Galley
	}
	return nil
}

// Configuration options for auto injection feature.
type AutoInjectionFeatureSpec struct {
	// Selects whether auto injection feature is installed. Must be set for any sub-component to be installed.
	Enabled              *protobuf.BoolValue                  `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Components           *AutoInjectionFeatureSpec_Components `protobuf:"bytes,50,opt,name=components,proto3" json:"components,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                             `json:"-"`
	XXX_unrecognized     []byte                               `json:"-"`
	XXX_sizecache        int32                                `json:"-"`
}

func (m *AutoInjectionFeatureSpec) Reset()         { *m = AutoInjectionFeatureSpec{} }
func (m *AutoInjectionFeatureSpec) String() string { return proto.CompactTextString(m) }
func (*AutoInjectionFeatureSpec) ProtoMessage()    {}
func (*AutoInjectionFeatureSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{7}
}
func (m *AutoInjectionFeatureSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AutoInjectionFeatureSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AutoInjectionFeatureSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AutoInjectionFeatureSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutoInjectionFeatureSpec.Merge(m, src)
}
func (m *AutoInjectionFeatureSpec) XXX_Size() int {
	return m.Size()
}
func (m *AutoInjectionFeatureSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_AutoInjectionFeatureSpec.DiscardUnknown(m)
}

var xxx_messageInfo_AutoInjectionFeatureSpec proto.InternalMessageInfo

func (m *AutoInjectionFeatureSpec) GetEnabled() *protobuf.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *AutoInjectionFeatureSpec) GetComponents() *AutoInjectionFeatureSpec_Components {
	if m != nil {
		return m.Components
	}
	return nil
}

type AutoInjectionFeatureSpec_Components struct {
	// Namespace that auto injections components are installed into.
	Namespace            string                        `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Injector             *SidecarInjectorComponentSpec `protobuf:"bytes,20,opt,name=injector,proto3" json:"injector,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *AutoInjectionFeatureSpec_Components) Reset()         { *m = AutoInjectionFeatureSpec_Components{} }
func (m *AutoInjectionFeatureSpec_Components) String() string { return proto.CompactTextString(m) }
func (*AutoInjectionFeatureSpec_Components) ProtoMessage()    {}
func (*AutoInjectionFeatureSpec_Components) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{7, 0}
}
func (m *AutoInjectionFeatureSpec_Components) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AutoInjectionFeatureSpec_Components) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AutoInjectionFeatureSpec_Components.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AutoInjectionFeatureSpec_Components) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutoInjectionFeatureSpec_Components.Merge(m, src)
}
func (m *AutoInjectionFeatureSpec_Components) XXX_Size() int {
	return m.Size()
}
func (m *AutoInjectionFeatureSpec_Components) XXX_DiscardUnknown() {
	xxx_messageInfo_AutoInjectionFeatureSpec_Components.DiscardUnknown(m)
}

var xxx_messageInfo_AutoInjectionFeatureSpec_Components proto.InternalMessageInfo

func (m *AutoInjectionFeatureSpec_Components) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *AutoInjectionFeatureSpec_Components) GetInjector() *SidecarInjectorComponentSpec {
	if m != nil {
		return m.Injector
	}
	return nil
}

// Configuration options for the pilot component.
type PilotComponentSpec struct {
	Common *CommonComponentSpec `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	// Enables sidecar in the pilot pod.
	Sidecar              *protobuf.BoolValue `protobuf:"bytes,10,opt,name=sidecar,proto3" json:"sidecar,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *PilotComponentSpec) Reset()         { *m = PilotComponentSpec{} }
func (m *PilotComponentSpec) String() string { return proto.CompactTextString(m) }
func (*PilotComponentSpec) ProtoMessage()    {}
func (*PilotComponentSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{8}
}
func (m *PilotComponentSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PilotComponentSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PilotComponentSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PilotComponentSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PilotComponentSpec.Merge(m, src)
}
func (m *PilotComponentSpec) XXX_Size() int {
	return m.Size()
}
func (m *PilotComponentSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PilotComponentSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PilotComponentSpec proto.InternalMessageInfo

func (m *PilotComponentSpec) GetCommon() *CommonComponentSpec {
	if m != nil {
		return m.Common
	}
	return nil
}

func (m *PilotComponentSpec) GetSidecar() *protobuf.BoolValue {
	if m != nil {
		return m.Sidecar
	}
	return nil
}

// Configuration options for the proxy.
type ProxyComponentSpec struct {
	Common               *CommonComponentSpec `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ProxyComponentSpec) Reset()         { *m = ProxyComponentSpec{} }
func (m *ProxyComponentSpec) String() string { return proto.CompactTextString(m) }
func (*ProxyComponentSpec) ProtoMessage()    {}
func (*ProxyComponentSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{9}
}
func (m *ProxyComponentSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProxyComponentSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProxyComponentSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProxyComponentSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProxyComponentSpec.Merge(m, src)
}
func (m *ProxyComponentSpec) XXX_Size() int {
	return m.Size()
}
func (m *ProxyComponentSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ProxyComponentSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ProxyComponentSpec proto.InternalMessageInfo

func (m *ProxyComponentSpec) GetCommon() *CommonComponentSpec {
	if m != nil {
		return m.Common
	}
	return nil
}

// Configuration options for the sidecar injector component.
type SidecarInjectorComponentSpec struct {
	Common               *CommonComponentSpec `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *SidecarInjectorComponentSpec) Reset()         { *m = SidecarInjectorComponentSpec{} }
func (m *SidecarInjectorComponentSpec) String() string { return proto.CompactTextString(m) }
func (*SidecarInjectorComponentSpec) ProtoMessage()    {}
func (*SidecarInjectorComponentSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{10}
}
func (m *SidecarInjectorComponentSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SidecarInjectorComponentSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SidecarInjectorComponentSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SidecarInjectorComponentSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SidecarInjectorComponentSpec.Merge(m, src)
}
func (m *SidecarInjectorComponentSpec) XXX_Size() int {
	return m.Size()
}
func (m *SidecarInjectorComponentSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SidecarInjectorComponentSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SidecarInjectorComponentSpec proto.InternalMessageInfo

func (m *SidecarInjectorComponentSpec) GetCommon() *CommonComponentSpec {
	if m != nil {
		return m.Common
	}
	return nil
}

// Configuration options for the policy enforcement component.
type PolicyComponentSpec struct {
	Common               *CommonComponentSpec `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *PolicyComponentSpec) Reset()         { *m = PolicyComponentSpec{} }
func (m *PolicyComponentSpec) String() string { return proto.CompactTextString(m) }
func (*PolicyComponentSpec) ProtoMessage()    {}
func (*PolicyComponentSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{11}
}
func (m *PolicyComponentSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicyComponentSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PolicyComponentSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PolicyComponentSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyComponentSpec.Merge(m, src)
}
func (m *PolicyComponentSpec) XXX_Size() int {
	return m.Size()
}
func (m *PolicyComponentSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyComponentSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyComponentSpec proto.InternalMessageInfo

func (m *PolicyComponentSpec) GetCommon() *CommonComponentSpec {
	if m != nil {
		return m.Common
	}
	return nil
}

// Configuration options for the telemetry component.
type TelemetryComponentSpec struct {
	Common               *CommonComponentSpec `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *TelemetryComponentSpec) Reset()         { *m = TelemetryComponentSpec{} }
func (m *TelemetryComponentSpec) String() string { return proto.CompactTextString(m) }
func (*TelemetryComponentSpec) ProtoMessage()    {}
func (*TelemetryComponentSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{12}
}
func (m *TelemetryComponentSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TelemetryComponentSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TelemetryComponentSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TelemetryComponentSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TelemetryComponentSpec.Merge(m, src)
}
func (m *TelemetryComponentSpec) XXX_Size() int {
	return m.Size()
}
func (m *TelemetryComponentSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TelemetryComponentSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TelemetryComponentSpec proto.InternalMessageInfo

func (m *TelemetryComponentSpec) GetCommon() *CommonComponentSpec {
	if m != nil {
		return m.Common
	}
	return nil
}

// Configuration options for Citadel component.
type CitadelComponentSpec struct {
	Common               *CommonComponentSpec `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	SelfSigned           bool                 `protobuf:"varint,11,opt,name=self_signed,json=selfSigned,proto3" json:"self_signed,omitempty"`
	CreateMeshPolicy     bool                 `protobuf:"varint,12,opt,name=create_mesh_policy,json=createMeshPolicy,proto3" json:"create_mesh_policy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *CitadelComponentSpec) Reset()         { *m = CitadelComponentSpec{} }
func (m *CitadelComponentSpec) String() string { return proto.CompactTextString(m) }
func (*CitadelComponentSpec) ProtoMessage()    {}
func (*CitadelComponentSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{13}
}
func (m *CitadelComponentSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CitadelComponentSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CitadelComponentSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CitadelComponentSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CitadelComponentSpec.Merge(m, src)
}
func (m *CitadelComponentSpec) XXX_Size() int {
	return m.Size()
}
func (m *CitadelComponentSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CitadelComponentSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CitadelComponentSpec proto.InternalMessageInfo

func (m *CitadelComponentSpec) GetCommon() *CommonComponentSpec {
	if m != nil {
		return m.Common
	}
	return nil
}

func (m *CitadelComponentSpec) GetSelfSigned() bool {
	if m != nil {
		return m.SelfSigned
	}
	return false
}

func (m *CitadelComponentSpec) GetCreateMeshPolicy() bool {
	if m != nil {
		return m.CreateMeshPolicy
	}
	return false
}

// Configuration options for certificate manager component.
type CertManagerComponentSpec struct {
	Common               *CommonComponentSpec `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *CertManagerComponentSpec) Reset()         { *m = CertManagerComponentSpec{} }
func (m *CertManagerComponentSpec) String() string { return proto.CompactTextString(m) }
func (*CertManagerComponentSpec) ProtoMessage()    {}
func (*CertManagerComponentSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{14}
}
func (m *CertManagerComponentSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertManagerComponentSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CertManagerComponentSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CertManagerComponentSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertManagerComponentSpec.Merge(m, src)
}
func (m *CertManagerComponentSpec) XXX_Size() int {
	return m.Size()
}
func (m *CertManagerComponentSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CertManagerComponentSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CertManagerComponentSpec proto.InternalMessageInfo

func (m *CertManagerComponentSpec) GetCommon() *CommonComponentSpec {
	if m != nil {
		return m.Common
	}
	return nil
}

// Configuration options for node agent component.
type NodeAgentComponentSpec struct {
	Common               *CommonComponentSpec `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *NodeAgentComponentSpec) Reset()         { *m = NodeAgentComponentSpec{} }
func (m *NodeAgentComponentSpec) String() string { return proto.CompactTextString(m) }
func (*NodeAgentComponentSpec) ProtoMessage()    {}
func (*NodeAgentComponentSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{15}
}
func (m *NodeAgentComponentSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeAgentComponentSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeAgentComponentSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeAgentComponentSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeAgentComponentSpec.Merge(m, src)
}
func (m *NodeAgentComponentSpec) XXX_Size() int {
	return m.Size()
}
func (m *NodeAgentComponentSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeAgentComponentSpec.DiscardUnknown(m)
}

var xxx_messageInfo_NodeAgentComponentSpec proto.InternalMessageInfo

func (m *NodeAgentComponentSpec) GetCommon() *CommonComponentSpec {
	if m != nil {
		return m.Common
	}
	return nil
}

// Configuration options for node agent component.
type GalleyComponentSpec struct {
	Common               *CommonComponentSpec `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *GalleyComponentSpec) Reset()         { *m = GalleyComponentSpec{} }
func (m *GalleyComponentSpec) String() string { return proto.CompactTextString(m) }
func (*GalleyComponentSpec) ProtoMessage()    {}
func (*GalleyComponentSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{16}
}
func (m *GalleyComponentSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GalleyComponentSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GalleyComponentSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GalleyComponentSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GalleyComponentSpec.Merge(m, src)
}
func (m *GalleyComponentSpec) XXX_Size() int {
	return m.Size()
}
func (m *GalleyComponentSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_GalleyComponentSpec.DiscardUnknown(m)
}

var xxx_messageInfo_GalleyComponentSpec proto.InternalMessageInfo

func (m *GalleyComponentSpec) GetCommon() *CommonComponentSpec {
	if m != nil {
		return m.Common
	}
	return nil
}

// Configuration common to all components.
type CommonComponentSpec struct {
	// Selects whether this component is installed.
	Enabled *protobuf.BoolValue `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Namespace that all resources for this component are installed into. Override for parent feature namespace.
	Namespace string                       `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Debug     CommonComponentSpec_LogLevel `protobuf:"varint,3,opt,name=debug,proto3,enum=v1alpha1.CommonComponentSpec_LogLevel" json:"debug,omitempty"`
	// Kubernetes resource spec.
	K8S                        *KubernetesResourcesSpec `protobuf:"bytes,80,opt,name=k8s,proto3" json:"k8s,omitempty"`
	ValuesOverrides            map[string]interface{}   `protobuf:"bytes,6,opt,name=valuesOverrides" json:"valuesOverrides,omitempty"`
	UnvalidatedValuesOverrides map[string]interface{}   `protobuf:"bytes,6,opt,name=unvalidatedValuesOverrides" json:"unvalidatedValuesOverrides,omitempty"`
	XXX_NoUnkeyedLiteral       struct{}                 `json:"-"`
	XXX_unrecognized           []byte                   `json:"-"`
	XXX_sizecache              int32                    `json:"-"`
}

func (m *CommonComponentSpec) Reset()         { *m = CommonComponentSpec{} }
func (m *CommonComponentSpec) String() string { return proto.CompactTextString(m) }
func (*CommonComponentSpec) ProtoMessage()    {}
func (*CommonComponentSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{17}
}
func (m *CommonComponentSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommonComponentSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommonComponentSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommonComponentSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommonComponentSpec.Merge(m, src)
}
func (m *CommonComponentSpec) XXX_Size() int {
	return m.Size()
}
func (m *CommonComponentSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CommonComponentSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CommonComponentSpec proto.InternalMessageInfo

func (m *CommonComponentSpec) GetEnabled() *protobuf.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *CommonComponentSpec) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *CommonComponentSpec) GetDebug() CommonComponentSpec_LogLevel {
	if m != nil {
		return m.Debug
	}
	return CommonComponentSpec_NONE
}

func (m *CommonComponentSpec) GetK8S() *KubernetesResourcesSpec {
	if m != nil {
		return m.K8S
	}
	return nil
}

// KubernetesResourcesConfig is a common set of k8s resource configs for components.
type KubernetesResourcesSpec struct {
	// k8s resources settings.
	// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#resource-requests-and-limits-of-pod-and-container
	Resources *Resources `protobuf:"bytes,1,opt,name=resources,proto3" json:"resources,omitempty"`
	// k8s readinessProbe settings.
	// https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/
	ReadinessProbe *v1.Probe `protobuf:"bytes,2,opt,name=readiness_probe,json=readinessProbe,proto3" json:"readiness_probe,omitempty"`
	// k8s Deployment replicas setting.
	// https://kubernetes.io/docs/concepts/workloads/controllers/deployment/
	ReplicaCount uint32 `protobuf:"varint,3,opt,name=replica_count,json=replicaCount,proto3" json:"replica_count,omitempty"`
	// k8s HorizontalPodAutoscaler settings.
	// https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/
	HpaSpec *v11.HorizontalPodAutoscalerSpec `protobuf:"bytes,4,opt,name=hpa_spec,json=hpaSpec,proto3" json:"hpa_spec,omitempty"`
	// k8s PodDisruptionBudget settings.
	// https://kubernetes.io/docs/concepts/workloads/pods/disruptions/#how-disruption-budgets-work
	PodDisruptionBudget *PodDisruptionBudgetSpec `protobuf:"bytes,5,opt,name=pod_disruption_budget,json=podDisruptionBudget,proto3" json:"pod_disruption_budget,omitempty"`
	// k8s pod annotations.
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
	PodAnnotations map[string]string `protobuf:"bytes,6,rep,name=pod_annotations,json=podAnnotations,proto3" json:"pod_annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// k8s nodeSelector.
	// https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
	NodeSelector map[string]string `protobuf:"bytes,7,rep,name=node_selector,json=nodeSelector,proto3" json:"node_selector,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// k8s affinity.
	// https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
	Affinity *v1.Affinity `protobuf:"bytes,8,opt,name=affinity,proto3" json:"affinity,omitempty"`
	// k8s imagePullPolicy.
	// https://kubernetes.io/docs/concepts/containers/images/
	ImagePullPolicy string `protobuf:"bytes,9,opt,name=image_pull_policy,json=imagePullPolicy,proto3" json:"image_pull_policy,omitempty"`
	// k8s priority_class_name. Default for all resources unless overridden.
	// https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass
	PriorityClassName string `protobuf:"bytes,10,opt,name=priority_class_name,json=priorityClassName,proto3" json:"priority_class_name,omitempty"`
	// Overlays for k8s resources in rendered manifests.
	Overlays             []*K8SObjectOverlay `protobuf:"bytes,100,rep,name=overlays,proto3" json:"overlays,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *KubernetesResourcesSpec) Reset()         { *m = KubernetesResourcesSpec{} }
func (m *KubernetesResourcesSpec) String() string { return proto.CompactTextString(m) }
func (*KubernetesResourcesSpec) ProtoMessage()    {}
func (*KubernetesResourcesSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{18}
}
func (m *KubernetesResourcesSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubernetesResourcesSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubernetesResourcesSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubernetesResourcesSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesResourcesSpec.Merge(m, src)
}
func (m *KubernetesResourcesSpec) XXX_Size() int {
	return m.Size()
}
func (m *KubernetesResourcesSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesResourcesSpec.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesResourcesSpec proto.InternalMessageInfo

func (m *KubernetesResourcesSpec) GetResources() *Resources {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *KubernetesResourcesSpec) GetReadinessProbe() *v1.Probe {
	if m != nil {
		return m.ReadinessProbe
	}
	return nil
}

func (m *KubernetesResourcesSpec) GetReplicaCount() uint32 {
	if m != nil {
		return m.ReplicaCount
	}
	return 0
}

func (m *KubernetesResourcesSpec) GetHpaSpec() *v11.HorizontalPodAutoscalerSpec {
	if m != nil {
		return m.HpaSpec
	}
	return nil
}

func (m *KubernetesResourcesSpec) GetPodDisruptionBudget() *PodDisruptionBudgetSpec {
	if m != nil {
		return m.PodDisruptionBudget
	}
	return nil
}

func (m *KubernetesResourcesSpec) GetPodAnnotations() map[string]string {
	if m != nil {
		return m.PodAnnotations
	}
	return nil
}

func (m *KubernetesResourcesSpec) GetNodeSelector() map[string]string {
	if m != nil {
		return m.NodeSelector
	}
	return nil
}

func (m *KubernetesResourcesSpec) GetAffinity() *v1.Affinity {
	if m != nil {
		return m.Affinity
	}
	return nil
}

func (m *KubernetesResourcesSpec) GetImagePullPolicy() string {
	if m != nil {
		return m.ImagePullPolicy
	}
	return ""
}

func (m *KubernetesResourcesSpec) GetPriorityClassName() string {
	if m != nil {
		return m.PriorityClassName
	}
	return ""
}

func (m *KubernetesResourcesSpec) GetOverlays() []*K8SObjectOverlay {
	if m != nil {
		return m.Overlays
	}
	return nil
}

// Configuration options for ingress gateways.
type IngressGatewaySpec struct {
	// Common gateway configuration.
	Gateway      *GatewayConfig                 `protobuf:"bytes,10,opt,name=gateway,proto3" json:"gateway,omitempty"`
	IngressType  IngressGatewaySpec_IngressType `protobuf:"varint,11,opt,name=ingress_type,json=ingressType,proto3,enum=v1alpha1.IngressGatewaySpec_IngressType" json:"ingress_type,omitempty"`
	LoadBalancer *LoadBalancerConfig            `protobuf:"bytes,13,opt,name=load_balancer,json=loadBalancer,proto3" json:"load_balancer,omitempty"`
	// If true, ingress gateway fetches credentials from SDS server to handle TLS connections.
	SdsEnabled            *protobuf.BoolValue                      `protobuf:"bytes,16,opt,name=sds_enabled,json=sdsEnabled,proto3" json:"sds_enabled,omitempty"`
	ExternalTrafficPolicy IngressGatewaySpec_ExternalTrafficPolicy `protobuf:"varint,17,opt,name=externalTrafficPolicy,proto3,enum=v1alpha1.IngressGatewaySpec_ExternalTrafficPolicy" json:"externalTrafficPolicy,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}                                 `json:"-"`
	XXX_unrecognized      []byte                                   `json:"-"`
	XXX_sizecache         int32                                    `json:"-"`
}

func (m *IngressGatewaySpec) Reset()         { *m = IngressGatewaySpec{} }
func (m *IngressGatewaySpec) String() string { return proto.CompactTextString(m) }
func (*IngressGatewaySpec) ProtoMessage()    {}
func (*IngressGatewaySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{19}
}
func (m *IngressGatewaySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngressGatewaySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngressGatewaySpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IngressGatewaySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngressGatewaySpec.Merge(m, src)
}
func (m *IngressGatewaySpec) XXX_Size() int {
	return m.Size()
}
func (m *IngressGatewaySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_IngressGatewaySpec.DiscardUnknown(m)
}

var xxx_messageInfo_IngressGatewaySpec proto.InternalMessageInfo

func (m *IngressGatewaySpec) GetGateway() *GatewayConfig {
	if m != nil {
		return m.Gateway
	}
	return nil
}

func (m *IngressGatewaySpec) GetIngressType() IngressGatewaySpec_IngressType {
	if m != nil {
		return m.IngressType
	}
	return IngressGatewaySpec_ISTIO
}

func (m *IngressGatewaySpec) GetLoadBalancer() *LoadBalancerConfig {
	if m != nil {
		return m.LoadBalancer
	}
	return nil
}

func (m *IngressGatewaySpec) GetSdsEnabled() *protobuf.BoolValue {
	if m != nil {
		return m.SdsEnabled
	}
	return nil
}

func (m *IngressGatewaySpec) GetExternalTrafficPolicy() IngressGatewaySpec_ExternalTrafficPolicy {
	if m != nil {
		return m.ExternalTrafficPolicy
	}
	return IngressGatewaySpec_NONE
}

// Configuration options for egress gateways.
type EgressGatewaySpec struct {
	// Common gateway configuration.
	Gateway              *GatewayConfig `protobuf:"bytes,10,opt,name=gateway,proto3" json:"gateway,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *EgressGatewaySpec) Reset()         { *m = EgressGatewaySpec{} }
func (m *EgressGatewaySpec) String() string { return proto.CompactTextString(m) }
func (*EgressGatewaySpec) ProtoMessage()    {}
func (*EgressGatewaySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{20}
}
func (m *EgressGatewaySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EgressGatewaySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EgressGatewaySpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EgressGatewaySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EgressGatewaySpec.Merge(m, src)
}
func (m *EgressGatewaySpec) XXX_Size() int {
	return m.Size()
}
func (m *EgressGatewaySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_EgressGatewaySpec.DiscardUnknown(m)
}

var xxx_messageInfo_EgressGatewaySpec proto.InternalMessageInfo

func (m *EgressGatewaySpec) GetGateway() *GatewayConfig {
	if m != nil {
		return m.Gateway
	}
	return nil
}

// Configuration options for internal load balancer gateways.
type LoadBalancingGatewayConfig struct {
	// Common gateway configuration.
	Gateway *GatewayConfig `protobuf:"bytes,10,opt,name=gateway,proto3" json:"gateway,omitempty"`
	// Load balancer config.
	LoadBalancer         *LoadBalancerConfig `protobuf:"bytes,11,opt,name=load_balancer,json=loadBalancer,proto3" json:"load_balancer,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *LoadBalancingGatewayConfig) Reset()         { *m = LoadBalancingGatewayConfig{} }
func (m *LoadBalancingGatewayConfig) String() string { return proto.CompactTextString(m) }
func (*LoadBalancingGatewayConfig) ProtoMessage()    {}
func (*LoadBalancingGatewayConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{21}
}
func (m *LoadBalancingGatewayConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadBalancingGatewayConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoadBalancingGatewayConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoadBalancingGatewayConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadBalancingGatewayConfig.Merge(m, src)
}
func (m *LoadBalancingGatewayConfig) XXX_Size() int {
	return m.Size()
}
func (m *LoadBalancingGatewayConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadBalancingGatewayConfig.DiscardUnknown(m)
}

var xxx_messageInfo_LoadBalancingGatewayConfig proto.InternalMessageInfo

func (m *LoadBalancingGatewayConfig) GetGateway() *GatewayConfig {
	if m != nil {
		return m.Gateway
	}
	return nil
}

func (m *LoadBalancingGatewayConfig) GetLoadBalancer() *LoadBalancerConfig {
	if m != nil {
		return m.LoadBalancer
	}
	return nil
}

// Common config for all gateway types.
type GatewayConfig struct {
	Common    *CommonComponentSpec `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	Namespace string               `protobuf:"bytes,3,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// NodePort, ClusterIP or LoadBalancer.
	Type                 string   `protobuf:"bytes,10,opt,name=type,proto3" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GatewayConfig) Reset()         { *m = GatewayConfig{} }
func (m *GatewayConfig) String() string { return proto.CompactTextString(m) }
func (*GatewayConfig) ProtoMessage()    {}
func (*GatewayConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{22}
}
func (m *GatewayConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GatewayConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GatewayConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GatewayConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GatewayConfig.Merge(m, src)
}
func (m *GatewayConfig) XXX_Size() int {
	return m.Size()
}
func (m *GatewayConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GatewayConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GatewayConfig proto.InternalMessageInfo

func (m *GatewayConfig) GetCommon() *CommonComponentSpec {
	if m != nil {
		return m.Common
	}
	return nil
}

func (m *GatewayConfig) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *GatewayConfig) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

// Configuration options for internal load balancer gateways.
// Subset of k8s.io/api/core/v1 ServiceSpec.
type LoadBalancerConfig struct {
	// The list of ports that are exposed by this service.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	Ports []*v1.ServicePort `protobuf:"bytes,1,rep,name=ports,proto3" json:"ports,omitempty"`
	// clusterIP is the IP address of the service and is usually assigned
	// randomly by the master. If an address is specified manually and is not in
	// use by others, it will be allocated to the service; otherwise, creation
	// of the service will fail. This field can not be changed through updates.
	// Valid values are "None", empty string (""), or a valid IP address. "None"
	// can be specified for headless services when proxying is not required.
	// Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if
	// type is ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	// +optional
	ClusterIP string `protobuf:"bytes,3,opt,name=clusterIP,proto3" json:"clusterIP,omitempty"`
	// externalIPs is a list of IP addresses for which nodes in the cluster
	// will also accept traffic for this service.  These IPs are not managed by
	// Kubernetes.  The user is responsible for ensuring that traffic arrives
	// at a node with this IP.  A common example is external load-balancers
	// that are not part of the Kubernetes system.
	// +optional
	ExternalIPs []string `protobuf:"bytes,5,rep,name=externalIPs,proto3" json:"externalIPs,omitempty"`
	// Supports "ClientIP" and "None". Used to maintain session affinity.
	// Enable client IP based session affinity.
	// Must be ClientIP or None.
	// Defaults to None.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	// +optional
	SessionAffinity string `protobuf:"bytes,7,opt,name=sessionAffinity,proto3" json:"sessionAffinity,omitempty"`
	// LoadBalancer will get created with the IP specified in this field.
	// This feature depends on whether the underlying cloud-provider supports specifying
	// the loadBalancerIP when a load balancer is created.
	// This field will be ignored if the cloud-provider does not support the feature.
	// +optional
	LoadBalancerIP string `protobuf:"bytes,8,opt,name=loadBalancerIP,proto3" json:"loadBalancerIP,omitempty"`
	// If specified and supported by the platform, this will restrict traffic through the cloud-provider
	// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
	// cloud-provider does not support the feature."
	// More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/
	// +optional
	LoadBalancerSourceRanges []string `protobuf:"bytes,9,rep,name=loadBalancerSourceRanges,proto3" json:"loadBalancerSourceRanges,omitempty"`
	// externalName is the external reference that kubedns or equivalent will
	// return as a CNAME record for this service. No proxying will be involved.
	// Must be a valid RFC-1123 hostname (https://tools.ietf.org/html/rfc1123)
	// and requires Type to be ExternalName.
	// +optional
	ExternalName string `protobuf:"bytes,10,opt,name=externalName,proto3" json:"externalName,omitempty"`
	// externalTrafficPolicy denotes if this Service desires to route external
	// traffic to node-local or cluster-wide endpoints. "Local" preserves the
	// client source IP and avoids a second hop for LoadBalancer and Nodeport
	// type services, but risks potentially imbalanced traffic spreading.
	// "Cluster" obscures the client source IP and may cause a second hop to
	// another node, but should have good overall load-spreading.
	// +optional
	ExternalTrafficPolicy string   `protobuf:"bytes,11,opt,name=externalTrafficPolicy,proto3" json:"externalTrafficPolicy,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *LoadBalancerConfig) Reset()         { *m = LoadBalancerConfig{} }
func (m *LoadBalancerConfig) String() string { return proto.CompactTextString(m) }
func (*LoadBalancerConfig) ProtoMessage()    {}
func (*LoadBalancerConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{23}
}
func (m *LoadBalancerConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadBalancerConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoadBalancerConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoadBalancerConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadBalancerConfig.Merge(m, src)
}
func (m *LoadBalancerConfig) XXX_Size() int {
	return m.Size()
}
func (m *LoadBalancerConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadBalancerConfig.DiscardUnknown(m)
}

var xxx_messageInfo_LoadBalancerConfig proto.InternalMessageInfo

func (m *LoadBalancerConfig) GetPorts() []*v1.ServicePort {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *LoadBalancerConfig) GetClusterIP() string {
	if m != nil {
		return m.ClusterIP
	}
	return ""
}

func (m *LoadBalancerConfig) GetExternalIPs() []string {
	if m != nil {
		return m.ExternalIPs
	}
	return nil
}

func (m *LoadBalancerConfig) GetSessionAffinity() string {
	if m != nil {
		return m.SessionAffinity
	}
	return ""
}

func (m *LoadBalancerConfig) GetLoadBalancerIP() string {
	if m != nil {
		return m.LoadBalancerIP
	}
	return ""
}

func (m *LoadBalancerConfig) GetLoadBalancerSourceRanges() []string {
	if m != nil {
		return m.LoadBalancerSourceRanges
	}
	return nil
}

func (m *LoadBalancerConfig) GetExternalName() string {
	if m != nil {
		return m.ExternalName
	}
	return ""
}

func (m *LoadBalancerConfig) GetExternalTrafficPolicy() string {
	if m != nil {
		return m.ExternalTrafficPolicy
	}
	return ""
}

// Patch for an existing k8s resource.
type K8SObjectOverlay struct {
	// Resource API version.
	ApiVersion string `protobuf:"bytes,1,opt,name=api_version,json=apiVersion,proto3" json:"api_version,omitempty"`
	// Resource kind.
	Kind string `protobuf:"bytes,2,opt,name=kind,proto3" json:"kind,omitempty"`
	// Name of resource.
	// Namespace is always the component namespace.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// List of patches to apply to resource.
	Patches              []*K8SObjectOverlay_PathValue `protobuf:"bytes,4,rep,name=patches,proto3" json:"patches,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *K8SObjectOverlay) Reset()         { *m = K8SObjectOverlay{} }
func (m *K8SObjectOverlay) String() string { return proto.CompactTextString(m) }
func (*K8SObjectOverlay) ProtoMessage()    {}
func (*K8SObjectOverlay) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{24}
}
func (m *K8SObjectOverlay) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *K8SObjectOverlay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_K8SObjectOverlay.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *K8SObjectOverlay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_K8SObjectOverlay.Merge(m, src)
}
func (m *K8SObjectOverlay) XXX_Size() int {
	return m.Size()
}
func (m *K8SObjectOverlay) XXX_DiscardUnknown() {
	xxx_messageInfo_K8SObjectOverlay.DiscardUnknown(m)
}

var xxx_messageInfo_K8SObjectOverlay proto.InternalMessageInfo

func (m *K8SObjectOverlay) GetApiVersion() string {
	if m != nil {
		return m.ApiVersion
	}
	return ""
}

func (m *K8SObjectOverlay) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *K8SObjectOverlay) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *K8SObjectOverlay) GetPatches() []*K8SObjectOverlay_PathValue {
	if m != nil {
		return m.Patches
	}
	return nil
}

type K8SObjectOverlay_PathValue struct {
	// Path of the form a.b:c.e.:f
	// Where b:c is a list element selector of the form key:value and :f is a list selector of the form :value.
	// All path intermediate nodes must exist.
	Path                 string      `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Value                interface{} `protobuf:"bytes,4,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *K8SObjectOverlay_PathValue) Reset()         { *m = K8SObjectOverlay_PathValue{} }
func (m *K8SObjectOverlay_PathValue) String() string { return proto.CompactTextString(m) }
func (*K8SObjectOverlay_PathValue) ProtoMessage()    {}
func (*K8SObjectOverlay_PathValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{24, 0}
}
func (m *K8SObjectOverlay_PathValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *K8SObjectOverlay_PathValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_K8SObjectOverlay_PathValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *K8SObjectOverlay_PathValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_K8SObjectOverlay_PathValue.Merge(m, src)
}
func (m *K8SObjectOverlay_PathValue) XXX_Size() int {
	return m.Size()
}
func (m *K8SObjectOverlay_PathValue) XXX_DiscardUnknown() {
	xxx_messageInfo_K8SObjectOverlay_PathValue.DiscardUnknown(m)
}

var xxx_messageInfo_K8SObjectOverlay_PathValue proto.InternalMessageInfo

func (m *K8SObjectOverlay_PathValue) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// Observed state of IstioControlPlane.
type InstallStatus struct {
	TrafficManagement    *InstallStatus_VersionStatus   `protobuf:"bytes,1,opt,name=traffic_management,json=trafficManagement,proto3" json:"traffic_management,omitempty"`
	PolicyTelemetry      *InstallStatus_VersionStatus   `protobuf:"bytes,2,opt,name=policy_telemetry,json=policyTelemetry,proto3" json:"policy_telemetry,omitempty"`
	Security             *InstallStatus_VersionStatus   `protobuf:"bytes,3,opt,name=security,proto3" json:"security,omitempty"`
	ConfigManagement     *InstallStatus_VersionStatus   `protobuf:"bytes,4,opt,name=config_management,json=configManagement,proto3" json:"config_management,omitempty"`
	IngressGateway       []*InstallStatus_VersionStatus `protobuf:"bytes,5,rep,name=ingress_gateway,json=ingressGateway,proto3" json:"ingress_gateway,omitempty"`
	EgressGateway        []*InstallStatus_VersionStatus `protobuf:"bytes,6,rep,name=egress_gateway,json=egressGateway,proto3" json:"egress_gateway,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *InstallStatus) Reset()         { *m = InstallStatus{} }
func (m *InstallStatus) String() string { return proto.CompactTextString(m) }
func (*InstallStatus) ProtoMessage()    {}
func (*InstallStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{25}
}
func (m *InstallStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstallStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstallStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstallStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallStatus.Merge(m, src)
}
func (m *InstallStatus) XXX_Size() int {
	return m.Size()
}
func (m *InstallStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallStatus.DiscardUnknown(m)
}

var xxx_messageInfo_InstallStatus proto.InternalMessageInfo

func (m *InstallStatus) GetTrafficManagement() *InstallStatus_VersionStatus {
	if m != nil {
		return m.TrafficManagement
	}
	return nil
}

func (m *InstallStatus) GetPolicyTelemetry() *InstallStatus_VersionStatus {
	if m != nil {
		return m.PolicyTelemetry
	}
	return nil
}

func (m *InstallStatus) GetSecurity() *InstallStatus_VersionStatus {
	if m != nil {
		return m.Security
	}
	return nil
}

func (m *InstallStatus) GetConfigManagement() *InstallStatus_VersionStatus {
	if m != nil {
		return m.ConfigManagement
	}
	return nil
}

func (m *InstallStatus) GetIngressGateway() []*InstallStatus_VersionStatus {
	if m != nil {
		return m.IngressGateway
	}
	return nil
}

func (m *InstallStatus) GetEgressGateway() []*InstallStatus_VersionStatus {
	if m != nil {
		return m.EgressGateway
	}
	return nil
}

type InstallStatus_VersionStatus struct {
	Version              string               `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	Status               InstallStatus_Status `protobuf:"varint,2,opt,name=status,proto3,enum=v1alpha1.InstallStatus_Status" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *InstallStatus_VersionStatus) Reset()         { *m = InstallStatus_VersionStatus{} }
func (m *InstallStatus_VersionStatus) String() string { return proto.CompactTextString(m) }
func (*InstallStatus_VersionStatus) ProtoMessage()    {}
func (*InstallStatus_VersionStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{25, 0}
}
func (m *InstallStatus_VersionStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstallStatus_VersionStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstallStatus_VersionStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstallStatus_VersionStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallStatus_VersionStatus.Merge(m, src)
}
func (m *InstallStatus_VersionStatus) XXX_Size() int {
	return m.Size()
}
func (m *InstallStatus_VersionStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallStatus_VersionStatus.DiscardUnknown(m)
}

var xxx_messageInfo_InstallStatus_VersionStatus proto.InternalMessageInfo

func (m *InstallStatus_VersionStatus) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *InstallStatus_VersionStatus) GetStatus() InstallStatus_Status {
	if m != nil {
		return m.Status
	}
	return InstallStatus_NONE
}

// Mirrors k8s.io.api.core.v1.ResourceRequirements for unmarshaling.
type Resources struct {
	Limits               map[string]string `protobuf:"bytes,1,rep,name=limits,proto3" json:"limits,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Requests             map[string]string `protobuf:"bytes,2,rep,name=requests,proto3" json:"requests,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Resources) Reset()         { *m = Resources{} }
func (m *Resources) String() string { return proto.CompactTextString(m) }
func (*Resources) ProtoMessage()    {}
func (*Resources) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{26}
}
func (m *Resources) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Resources) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Resources.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Resources) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Resources.Merge(m, src)
}
func (m *Resources) XXX_Size() int {
	return m.Size()
}
func (m *Resources) XXX_DiscardUnknown() {
	xxx_messageInfo_Resources.DiscardUnknown(m)
}

var xxx_messageInfo_Resources proto.InternalMessageInfo

func (m *Resources) GetLimits() map[string]string {
	if m != nil {
		return m.Limits
	}
	return nil
}

func (m *Resources) GetRequests() map[string]string {
	if m != nil {
		return m.Requests
	}
	return nil
}

// Mirrors k8s.io.api.policy.v1beta1.PodDisruptionBudget for unmarshaling.
type PodDisruptionBudgetSpec struct {
	MinAvailable         uint32             `protobuf:"varint,1,opt,name=min_available,json=minAvailable,proto3" json:"min_available,omitempty"`
	Selector             *v12.LabelSelector `protobuf:"bytes,2,opt,name=selector,proto3" json:"selector,omitempty"`
	MaxUnavailable       uint32             `protobuf:"varint,3,opt,name=max_unavailable,json=maxUnavailable,proto3" json:"max_unavailable,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *PodDisruptionBudgetSpec) Reset()         { *m = PodDisruptionBudgetSpec{} }
func (m *PodDisruptionBudgetSpec) String() string { return proto.CompactTextString(m) }
func (*PodDisruptionBudgetSpec) ProtoMessage()    {}
func (*PodDisruptionBudgetSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{27}
}
func (m *PodDisruptionBudgetSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodDisruptionBudgetSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodDisruptionBudgetSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodDisruptionBudgetSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodDisruptionBudgetSpec.Merge(m, src)
}
func (m *PodDisruptionBudgetSpec) XXX_Size() int {
	return m.Size()
}
func (m *PodDisruptionBudgetSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PodDisruptionBudgetSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PodDisruptionBudgetSpec proto.InternalMessageInfo

func (m *PodDisruptionBudgetSpec) GetMinAvailable() uint32 {
	if m != nil {
		return m.MinAvailable
	}
	return 0
}

func (m *PodDisruptionBudgetSpec) GetSelector() *v12.LabelSelector {
	if m != nil {
		return m.Selector
	}
	return nil
}

func (m *PodDisruptionBudgetSpec) GetMaxUnavailable() uint32 {
	if m != nil {
		return m.MaxUnavailable
	}
	return 0
}

type ObjectMeta struct {
	// From k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta
	Name                 string   `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	Namespace            string   `protobuf:"bytes,6,opt,name=namespace,proto3" json:"namespace,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ObjectMeta) Reset()         { *m = ObjectMeta{} }
func (m *ObjectMeta) String() string { return proto.CompactTextString(m) }
func (*ObjectMeta) ProtoMessage()    {}
func (*ObjectMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{28}
}
func (m *ObjectMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectMeta.Merge(m, src)
}
func (m *ObjectMeta) XXX_Size() int {
	return m.Size()
}
func (m *ObjectMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectMeta.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectMeta proto.InternalMessageInfo

func (m *ObjectMeta) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ObjectMeta) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// TESTING ONLY
type TestKube struct {
	Env                 map[string]string                `protobuf:"bytes,60,rep,name=env,proto3" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Resources           *Resources                       `protobuf:"bytes,80,opt,name=resources,proto3" json:"resources,omitempty"`
	ReadinessProbe      *v1.Probe                        `protobuf:"bytes,81,opt,name=readiness_probe,json=readinessProbe,proto3" json:"readiness_probe,omitempty"`
	HpaSpec             *v11.HorizontalPodAutoscalerSpec `protobuf:"bytes,86,opt,name=hpa_spec,json=hpaSpec,proto3" json:"hpa_spec,omitempty"`
	PodDisruptionBudget *PodDisruptionBudgetSpec         `protobuf:"bytes,87,opt,name=pod_disruption_budget,json=podDisruptionBudget,proto3" json:"pod_disruption_budget,omitempty"`
	Affinity            *v1.Affinity                     `protobuf:"bytes,8,opt,name=affinity,proto3" json:"affinity,omitempty"`
	PodAnnotations      map[string]string                `protobuf:"bytes,90,rep,name=pod_annotations,json=podAnnotations,proto3" json:"pod_annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	NodeSelector        map[string]string                `protobuf:"bytes,92,rep,name=node_selector,json=nodeSelector,proto3" json:"node_selector,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Kustomize style overrides for k8s resources in rendered manifests.
	Overlays             []*K8SObjectOverlay `protobuf:"bytes,100,rep,name=overlays,proto3" json:"overlays,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TestKube) Reset()         { *m = TestKube{} }
func (m *TestKube) String() string { return proto.CompactTextString(m) }
func (*TestKube) ProtoMessage()    {}
func (*TestKube) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{29}
}
func (m *TestKube) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestKube) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestKube.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestKube) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestKube.Merge(m, src)
}
func (m *TestKube) XXX_Size() int {
	return m.Size()
}
func (m *TestKube) XXX_DiscardUnknown() {
	xxx_messageInfo_TestKube.DiscardUnknown(m)
}

var xxx_messageInfo_TestKube proto.InternalMessageInfo

func (m *TestKube) GetEnv() map[string]string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *TestKube) GetResources() *Resources {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *TestKube) GetReadinessProbe() *v1.Probe {
	if m != nil {
		return m.ReadinessProbe
	}
	return nil
}

func (m *TestKube) GetHpaSpec() *v11.HorizontalPodAutoscalerSpec {
	if m != nil {
		return m.HpaSpec
	}
	return nil
}

func (m *TestKube) GetPodDisruptionBudget() *PodDisruptionBudgetSpec {
	if m != nil {
		return m.PodDisruptionBudget
	}
	return nil
}

func (m *TestKube) GetAffinity() *v1.Affinity {
	if m != nil {
		return m.Affinity
	}
	return nil
}

func (m *TestKube) GetPodAnnotations() map[string]string {
	if m != nil {
		return m.PodAnnotations
	}
	return nil
}

func (m *TestKube) GetNodeSelector() map[string]string {
	if m != nil {
		return m.NodeSelector
	}
	return nil
}

func (m *TestKube) GetOverlays() []*K8SObjectOverlay {
	if m != nil {
		return m.Overlays
	}
	return nil
}

func init() {
	proto.RegisterEnum("v1alpha1.PolicyFeatureSpec_OutboundPolicy", PolicyFeatureSpec_OutboundPolicy_name, PolicyFeatureSpec_OutboundPolicy_value)
	proto.RegisterEnum("v1alpha1.CommonComponentSpec_LogLevel", CommonComponentSpec_LogLevel_name, CommonComponentSpec_LogLevel_value)
	proto.RegisterEnum("v1alpha1.IngressGatewaySpec_IngressType", IngressGatewaySpec_IngressType_name, IngressGatewaySpec_IngressType_value)
	proto.RegisterEnum("v1alpha1.IngressGatewaySpec_ExternalTrafficPolicy", IngressGatewaySpec_ExternalTrafficPolicy_name, IngressGatewaySpec_ExternalTrafficPolicy_value)
	proto.RegisterEnum("v1alpha1.InstallStatus_Status", InstallStatus_Status_name, InstallStatus_Status_value)
	proto.RegisterType((*IstioControlPlane)(nil), "v1alpha1.IstioControlPlane")
	proto.RegisterType((*IstioControlPlaneSpec)(nil), "v1alpha1.IstioControlPlaneSpec")
	proto.RegisterType((*TrafficManagementFeatureSpec)(nil), "v1alpha1.TrafficManagementFeatureSpec")
	proto.RegisterType((*TrafficManagementFeatureSpec_Components)(nil), "v1alpha1.TrafficManagementFeatureSpec.Components")
	proto.RegisterType((*PolicyFeatureSpec)(nil), "v1alpha1.PolicyFeatureSpec")
	proto.RegisterType((*PolicyFeatureSpec_Components)(nil), "v1alpha1.PolicyFeatureSpec.Components")
	proto.RegisterType((*TelemetryFeatureSpec)(nil), "v1alpha1.TelemetryFeatureSpec")
	proto.RegisterType((*TelemetryFeatureSpec_Components)(nil), "v1alpha1.TelemetryFeatureSpec.Components")
	proto.RegisterType((*SecurityFeatureSpec)(nil), "v1alpha1.SecurityFeatureSpec")
	proto.RegisterType((*SecurityFeatureSpec_Components)(nil), "v1alpha1.SecurityFeatureSpec.Components")
	proto.RegisterType((*ConfigManagementFeatureSpec)(nil), "v1alpha1.ConfigManagementFeatureSpec")
	proto.RegisterType((*ConfigManagementFeatureSpec_Components)(nil), "v1alpha1.ConfigManagementFeatureSpec.Components")
	proto.RegisterType((*AutoInjectionFeatureSpec)(nil), "v1alpha1.AutoInjectionFeatureSpec")
	proto.RegisterType((*AutoInjectionFeatureSpec_Components)(nil), "v1alpha1.AutoInjectionFeatureSpec.Components")
	proto.RegisterType((*PilotComponentSpec)(nil), "v1alpha1.PilotComponentSpec")
	proto.RegisterType((*ProxyComponentSpec)(nil), "v1alpha1.ProxyComponentSpec")
	proto.RegisterType((*SidecarInjectorComponentSpec)(nil), "v1alpha1.SidecarInjectorComponentSpec")
	proto.RegisterType((*PolicyComponentSpec)(nil), "v1alpha1.PolicyComponentSpec")
	proto.RegisterType((*TelemetryComponentSpec)(nil), "v1alpha1.TelemetryComponentSpec")
	proto.RegisterType((*CitadelComponentSpec)(nil), "v1alpha1.CitadelComponentSpec")
	proto.RegisterType((*CertManagerComponentSpec)(nil), "v1alpha1.CertManagerComponentSpec")
	proto.RegisterType((*NodeAgentComponentSpec)(nil), "v1alpha1.NodeAgentComponentSpec")
	proto.RegisterType((*GalleyComponentSpec)(nil), "v1alpha1.GalleyComponentSpec")
	proto.RegisterType((*CommonComponentSpec)(nil), "v1alpha1.CommonComponentSpec")
	proto.RegisterType((*KubernetesResourcesSpec)(nil), "v1alpha1.KubernetesResourcesSpec")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.KubernetesResourcesSpec.NodeSelectorEntry")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.KubernetesResourcesSpec.PodAnnotationsEntry")
	proto.RegisterType((*IngressGatewaySpec)(nil), "v1alpha1.IngressGatewaySpec")
	proto.RegisterType((*EgressGatewaySpec)(nil), "v1alpha1.EgressGatewaySpec")
	proto.RegisterType((*LoadBalancingGatewayConfig)(nil), "v1alpha1.LoadBalancingGatewayConfig")
	proto.RegisterType((*GatewayConfig)(nil), "v1alpha1.GatewayConfig")
	proto.RegisterType((*LoadBalancerConfig)(nil), "v1alpha1.LoadBalancerConfig")
	proto.RegisterType((*K8SObjectOverlay)(nil), "v1alpha1.k8sObjectOverlay")
	proto.RegisterType((*K8SObjectOverlay_PathValue)(nil), "v1alpha1.k8sObjectOverlay.PathValue")
	proto.RegisterType((*InstallStatus)(nil), "v1alpha1.InstallStatus")
	proto.RegisterType((*InstallStatus_VersionStatus)(nil), "v1alpha1.InstallStatus.VersionStatus")
	proto.RegisterType((*Resources)(nil), "v1alpha1.Resources")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.Resources.LimitsEntry")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.Resources.RequestsEntry")
	proto.RegisterType((*PodDisruptionBudgetSpec)(nil), "v1alpha1.PodDisruptionBudgetSpec")
	proto.RegisterType((*ObjectMeta)(nil), "v1alpha1.ObjectMeta")
	proto.RegisterType((*TestKube)(nil), "v1alpha1.TestKube")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.TestKube.EnvEntry")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.TestKube.NodeSelectorEntry")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.TestKube.PodAnnotationsEntry")
}

func init() { proto.RegisterFile("istioinstaller_types.proto", fileDescriptor_d0a1188b3d395975) }

var fileDescriptor_d0a1188b3d395975 = []byte{
	// 2621 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x59, 0xcd, 0x73, 0xdb, 0xc6,
	0xd9, 0x37, 0x45, 0x7d, 0x90, 0x0f, 0x45, 0x89, 0x5a, 0xd9, 0x0e, 0xc2, 0x38, 0xb2, 0x5e, 0xbc,
	0x79, 0xfd, 0x2a, 0x99, 0x37, 0xd4, 0x6b, 0x39, 0x71, 0x95, 0x8f, 0x3a, 0xa5, 0x64, 0xda, 0xe6,
	0x98, 0x26, 0x69, 0x50, 0x4a, 0xea, 0x4e, 0xa7, 0x98, 0x25, 0xb0, 0x22, 0x11, 0x81, 0x58, 0x14,
	0x58, 0x2a, 0x66, 0x6f, 0x9d, 0x5e, 0xda, 0x53, 0x67, 0x72, 0xea, 0xa1, 0x33, 0xbd, 0xf4, 0x8f,
	0xe8, 0x21, 0x87, 0x1e, 0x7b, 0xec, 0x9f, 0xd0, 0x49, 0x66, 0x7a, 0x69, 0x6f, 0x3d, 0xf6, 0xd2,
	0xd9, 0x5d, 0x80, 0x00, 0x48, 0x50, 0x32, 0x99, 0x74, 0xa6, 0x37, 0xe0, 0xf9, 0xda, 0xdd, 0xe7,
	0xd9, 0xfd, 0x3d, 0xcf, 0xb3, 0x0b, 0x65, 0xcb, 0x67, 0x16, 0xb5, 0x1c, 0x9f, 0x61, 0xdb, 0x26,
	0x9e, 0xce, 0x46, 0x2e, 0xf1, 0x2b, 0xae, 0x47, 0x19, 0x45, 0xb9, 0x8b, 0xbb, 0xd8, 0x76, 0xfb,
	0xf8, 0x6e, 0x59, 0x3d, 0x3f, 0xf4, 0x2b, 0x16, 0xdd, 0xc7, 0xae, 0xb5, 0x6f, 0x50, 0x8f, 0xec,
	0x5f, 0xdc, 0xdd, 0xef, 0x11, 0x87, 0x78, 0x98, 0x11, 0x53, 0x4a, 0x97, 0xdf, 0x8e, 0xc9, 0xe0,
	0x21, 0xa3, 0xbe, 0x81, 0x6d, 0xcb, 0xe9, 0xa5, 0x89, 0xbe, 0x17, 0x89, 0x0e, 0xb0, 0xd1, 0xb7,
	0x1c, 0xe2, 0x8d, 0xf6, 0xdd, 0xf3, 0x1e, 0x27, 0xf8, 0xfb, 0x03, 0xc2, 0x70, 0x9a, 0xd6, 0x0f,
	0x7a, 0x16, 0xeb, 0x0f, 0xbb, 0x15, 0x83, 0x0e, 0xf6, 0x7b, 0xb4, 0x47, 0xf7, 0x05, 0xb9, 0x3b,
	0x3c, 0x8b, 0x3e, 0x7a, 0x94, 0xf6, 0x6c, 0x12, 0xfd, 0x7f, 0xe1, 0x61, 0xd7, 0x25, 0x5e, 0xb0,
	0x20, 0x75, 0x04, 0x5b, 0x75, 0xbe, 0xdc, 0x63, 0xea, 0x30, 0x8f, 0xda, 0x6d, 0x1b, 0x3b, 0x04,
	0xdd, 0x83, 0x65, 0xdf, 0x25, 0x86, 0x92, 0xdd, 0xcd, 0xec, 0x15, 0x0e, 0x6e, 0x57, 0xc2, 0x45,
	0x57, 0xa6, 0x44, 0x3b, 0x2e, 0x31, 0x34, 0x21, 0x8c, 0xf6, 0x61, 0xd5, 0x67, 0x98, 0x0d, 0x7d,
	0x65, 0x59, 0xa8, 0xbd, 0x16, 0x53, 0x93, 0xbe, 0xec, 0x08, 0xb6, 0x16, 0x88, 0xa9, 0x7f, 0x5c,
	0x85, 0x1b, 0xa9, 0x06, 0xd1, 0x21, 0x28, 0x26, 0x39, 0xc3, 0x43, 0x9b, 0xe9, 0x0e, 0x1e, 0x10,
	0xdf, 0xc5, 0x06, 0xd1, 0x5d, 0x8f, 0x9c, 0x59, 0x2f, 0x95, 0x95, 0xdd, 0xcc, 0x5e, 0x5e, 0xbb,
	0x19, 0xf0, 0x9b, 0x21, 0xbb, 0x2d, 0xb8, 0xe8, 0x14, 0x10, 0xf3, 0xf0, 0xd9, 0x99, 0x65, 0xe8,
	0x03, 0xec, 0xe0, 0x1e, 0x19, 0x10, 0x87, 0x29, 0xaf, 0x8b, 0x09, 0xdd, 0x89, 0x26, 0x74, 0x22,
	0x65, 0x9e, 0x8d, 0x45, 0x1e, 0x11, 0xcc, 0x86, 0x9e, 0x5c, 0xce, 0x16, 0x9b, 0xe4, 0xa2, 0x7b,
	0xb0, 0xea, 0x52, 0xdb, 0x32, 0x46, 0x4a, 0x59, 0x98, 0x7a, 0x23, 0x32, 0xd5, 0x16, 0xf4, 0xb8,
	0x7e, 0x20, 0x8a, 0x3e, 0x86, 0x3c, 0x23, 0x36, 0x19, 0x10, 0xe6, 0x8d, 0x94, 0x37, 0x84, 0xde,
	0x4e, 0x6c, 0x0a, 0x21, 0x2b, 0xae, 0x1a, 0x29, 0xa0, 0x0f, 0x20, 0xe7, 0x13, 0x63, 0xe8, 0x59,
	0x6c, 0xa4, 0xdc, 0x12, 0xca, 0x6f, 0x46, 0xca, 0x9d, 0x80, 0x13, 0xd7, 0x1d, 0x8b, 0x23, 0x0d,
	0xb6, 0x0c, 0xea, 0x9c, 0x59, 0xbd, 0xb8, 0x0f, 0xde, 0x14, 0x36, 0xfe, 0x27, 0xb2, 0x71, 0x2c,
	0x44, 0xd2, 0x5d, 0x50, 0x32, 0x26, 0x98, 0xa8, 0x0e, 0x1b, 0x7c, 0x07, 0xeb, 0x96, 0xf3, 0x39,
	0x31, 0x98, 0x45, 0x1d, 0x65, 0x47, 0x18, 0x54, 0x23, 0x83, 0xd5, 0x21, 0xa3, 0xf5, 0x90, 0x1d,
	0xb7, 0x56, 0xc4, 0x71, 0x0e, 0xaa, 0xc1, 0xa6, 0xe5, 0xf4, 0x3c, 0xe2, 0xfb, 0x7a, 0x0f, 0x33,
	0xf2, 0x05, 0x1e, 0x29, 0xb7, 0x77, 0xb3, 0x7b, 0x85, 0x83, 0x5b, 0xf1, 0x1d, 0x23, 0x04, 0x1e,
	0x4b, 0xbe, 0xb0, 0xb2, 0x61, 0x25, 0x68, 0xe8, 0x08, 0x36, 0x48, 0xd2, 0xca, 0xae, 0xb0, 0x12,
	0x8b, 0x4d, 0x6d, 0xca, 0x48, 0x91, 0x24, 0x6c, 0x3c, 0x84, 0xf5, 0xf3, 0x43, 0x5f, 0x0f, 0x36,
	0x93, 0xaf, 0xb4, 0xc5, 0x9a, 0xfe, 0x2b, 0xb2, 0xf0, 0x74, 0xd8, 0x25, 0x9e, 0x43, 0x18, 0xf1,
	0x35, 0xe2, 0xd3, 0xa1, 0x67, 0x10, 0x5f, 0xd8, 0x29, 0x9c, 0x1f, 0xfa, 0x0f, 0x03, 0x2d, 0xf4,
	0x16, 0x6c, 0x74, 0xb1, 0x4f, 0x74, 0x7e, 0x0c, 0x74, 0x17, 0xb3, 0xbe, 0x62, 0x8a, 0x4d, 0xba,
	0xce, 0xa9, 0x5c, 0xbc, 0x8d, 0x59, 0x1f, 0x55, 0x60, 0xdb, 0x18, 0xfa, 0x8c, 0x0e, 0x74, 0x17,
	0x1b, 0xe7, 0xb8, 0x47, 0xa4, 0xe8, 0x99, 0x10, 0xdd, 0x92, 0xac, 0xb6, 0xe4, 0x08, 0xf9, 0x12,
	0x64, 0xfb, 0xc3, 0xae, 0xd2, 0x13, 0x7c, 0xfe, 0xc9, 0x29, 0x0c, 0xf7, 0x94, 0xbe, 0xa4, 0x30,
	0xdc, 0x53, 0xbf, 0x5a, 0x82, 0x5b, 0x97, 0xed, 0x65, 0xf4, 0x1e, 0xac, 0x11, 0x07, 0x77, 0x6d,
	0x62, 0x2a, 0x19, 0xb1, 0xb6, 0x72, 0x45, 0x02, 0x42, 0x25, 0x04, 0x84, 0xca, 0x11, 0xa5, 0xf6,
	0xa7, 0xd8, 0x1e, 0x12, 0x2d, 0x14, 0x45, 0xcf, 0x01, 0x0c, 0x3a, 0x70, 0xa9, 0x43, 0x1c, 0xe6,
	0x2b, 0x07, 0x42, 0xf1, 0xee, 0xab, 0x9d, 0x9e, 0xca, 0xf1, 0x58, 0x51, 0x8b, 0x19, 0x29, 0x7f,
	0x99, 0x01, 0x88, 0x58, 0xe8, 0x16, 0xe4, 0xc7, 0x27, 0x5b, 0xcc, 0x2c, 0xaf, 0x45, 0x04, 0x74,
	0x00, 0x2b, 0xae, 0x65, 0x53, 0xa6, 0x5c, 0x17, 0x43, 0xc7, 0xf6, 0x45, 0x9b, 0x93, 0xc7, 0x76,
	0x44, 0x28, 0xa4, 0xa8, 0xd0, 0xf1, 0xe8, 0xcb, 0x91, 0x72, 0x63, 0x4a, 0x87, 0x93, 0x27, 0x75,
	0x38, 0x4d, 0xfd, 0x6b, 0x16, 0xb6, 0xa6, 0xce, 0xef, 0x82, 0x3e, 0x6b, 0xc1, 0x4d, 0x79, 0xee,
	0x75, 0xa3, 0x4f, 0x8c, 0x73, 0xfd, 0x0c, 0x5b, 0xb6, 0x4e, 0x5d, 0xe2, 0x28, 0x70, 0xa5, 0x91,
	0x6d, 0xa9, 0x79, 0xcc, 0x15, 0x1f, 0x61, 0xcb, 0x6e, 0xb9, 0xc4, 0x41, 0xe7, 0x70, 0x8b, 0x0e,
	0x59, 0x97, 0x0e, 0x1d, 0x53, 0x0f, 0x31, 0x2d, 0x18, 0x61, 0x40, 0x4d, 0xa2, 0x14, 0x76, 0x33,
	0x7b, 0x1b, 0x07, 0xef, 0x5c, 0x82, 0x44, 0x95, 0x56, 0xa0, 0x2f, 0x39, 0xda, 0xeb, 0xa1, 0xbd,
	0x20, 0x80, 0x92, 0xfc, 0x8c, 0x9a, 0x04, 0x3d, 0x4a, 0x89, 0xf8, 0x9d, 0xcb, 0x4c, 0xcf, 0x08,
	0x33, 0x9e, 0x23, 0xca, 0xef, 0x8f, 0x41, 0xf5, 0xfa, 0x24, 0xbe, 0xc9, 0xf1, 0x92, 0x31, 0x0b,
	0x84, 0xd5, 0x03, 0xd8, 0x48, 0xae, 0x0b, 0x15, 0x21, 0x5f, 0x6d, 0x34, 0x5a, 0x9f, 0xe9, 0xd5,
	0xe6, 0x8b, 0xd2, 0x35, 0xb4, 0x05, 0x45, 0xad, 0xf6, 0xb8, 0xde, 0x39, 0xd1, 0x5e, 0xe8, 0xad,
	0x66, 0xe3, 0x45, 0x29, 0xa3, 0xfe, 0x62, 0x09, 0xae, 0xa7, 0x01, 0xee, 0x82, 0xb1, 0xae, 0xa7,
	0x78, 0xeb, 0xed, 0xcb, 0xa1, 0x7d, 0x96, 0xc3, 0x3e, 0x9f, 0xc3, 0x61, 0x0f, 0xe2, 0x09, 0x45,
	0xfa, 0x6c, 0x37, 0x65, 0xd4, 0xa4, 0xdb, 0x22, 0x15, 0xf5, 0x77, 0xcb, 0xb0, 0x9d, 0x92, 0x39,
	0x16, 0x74, 0xc2, 0x13, 0x40, 0x86, 0x4c, 0xdc, 0xba, 0xcb, 0x33, 0xb7, 0x3e, 0x60, 0xb6, 0xaf,
	0x14, 0xaf, 0x34, 0x50, 0x32, 0x62, 0xe9, 0xfe, 0x19, 0xb3, 0x7d, 0x7e, 0x74, 0x4c, 0xcc, 0x70,
	0xcc, 0x8c, 0xee, 0x33, 0xcf, 0x32, 0x98, 0xb2, 0x71, 0xf5, 0xd1, 0xe1, 0x9a, 0x63, 0x53, 0x1d,
	0xa1, 0x86, 0x9e, 0xa4, 0xc4, 0x67, 0xef, 0xd2, 0xec, 0x39, 0x2b, 0x3c, 0x7f, 0x9f, 0x07, 0xb6,
	0x0e, 0x61, 0xcd, 0xb0, 0x18, 0x36, 0x89, 0x1d, 0x44, 0x27, 0x96, 0xee, 0x8f, 0x25, 0x23, 0x19,
	0x9b, 0x50, 0x1c, 0xd5, 0x60, 0xdd, 0x20, 0x1e, 0x0b, 0xf2, 0xb5, 0x17, 0x60, 0x58, 0x2c, 0xb7,
	0x1e, 0x13, 0x8f, 0x49, 0xbc, 0xf5, 0x92, 0x26, 0x0a, 0x46, 0xc4, 0x41, 0x9f, 0x00, 0x38, 0xd4,
	0x24, 0x3a, 0xee, 0xf1, 0x8c, 0x7f, 0x73, 0x72, 0x87, 0x34, 0xa9, 0x49, 0xaa, 0x9c, 0x35, 0xb1,
	0x43, 0x9c, 0x90, 0xae, 0xfe, 0x72, 0x09, 0xde, 0xb8, 0xa4, 0x2e, 0x58, 0x70, 0xa7, 0xb4, 0x53,
	0xc2, 0xf1, 0xff, 0xaf, 0x54, 0x88, 0x7c, 0x47, 0x30, 0xd3, 0xe3, 0x85, 0x7c, 0x0a, 0xcc, 0x3c,
	0x16, 0xf4, 0x09, 0x98, 0x91, 0xc2, 0xea, 0xaf, 0x97, 0x40, 0x99, 0x55, 0xd1, 0x2c, 0xe8, 0x87,
	0x67, 0x29, 0x7e, 0x78, 0xf7, 0xea, 0xfa, 0x69, 0x96, 0x13, 0x9c, 0x39, 0x9c, 0x70, 0x04, 0x39,
	0x59, 0xb9, 0x51, 0x2f, 0x70, 0x43, 0x0c, 0xdd, 0x3b, 0x96, 0x49, 0x0c, 0xec, 0xd5, 0x03, 0x81,
	0xa4, 0x3f, 0xc6, 0x7a, 0xea, 0xcf, 0x33, 0x80, 0xa6, 0xf3, 0x2f, 0xf7, 0xaf, 0x41, 0x07, 0x03,
	0xea, 0x04, 0xae, 0x78, 0x33, 0x1e, 0x59, 0x4e, 0x9f, 0xf0, 0xaf, 0x14, 0xe6, 0x2e, 0xf4, 0xe5,
	0xb8, 0xaf, 0x90, 0x20, 0x43, 0x51, 0xf5, 0x29, 0xa0, 0xe9, 0x74, 0xbe, 0xe0, 0x14, 0xd4, 0x53,
	0xb8, 0x75, 0xd9, 0xd2, 0x17, 0x35, 0xdb, 0x80, 0xed, 0x94, 0xfc, 0xb5, 0xa8, 0xb5, 0x16, 0xdc,
	0x4c, 0x47, 0xf6, 0x45, 0x0d, 0xfe, 0x36, 0x03, 0xd7, 0xd3, 0xd0, 0x68, 0xd1, 0x40, 0xde, 0x86,
	0x82, 0x4f, 0xec, 0x33, 0xdd, 0xb7, 0x7a, 0x0e, 0x31, 0x45, 0x59, 0x92, 0xd3, 0x80, 0x93, 0x3a,
	0x82, 0x82, 0xfe, 0x0f, 0x90, 0xe1, 0x11, 0xcc, 0x88, 0x3e, 0x20, 0x7e, 0x3f, 0xa8, 0x61, 0x94,
	0x75, 0x21, 0x57, 0x92, 0x9c, 0x67, 0xc4, 0xef, 0x4b, 0x9f, 0xa9, 0xcf, 0x41, 0x99, 0x05, 0x76,
	0xdf, 0xc2, 0x85, 0xe9, 0xd0, 0xf7, 0x2d, 0x22, 0x9c, 0x02, 0x1d, 0x0b, 0x07, 0x64, 0x09, 0xb6,
	0x53, 0xf8, 0x0b, 0x82, 0x4c, 0x02, 0x07, 0x96, 0x26, 0x71, 0xe0, 0x63, 0x58, 0x31, 0x49, 0x77,
	0xd8, 0x13, 0xad, 0xfd, 0x46, 0x1c, 0x04, 0x52, 0x66, 0x50, 0x69, 0xd0, 0x5e, 0x83, 0x5c, 0x10,
	0x5b, 0x93, 0x4a, 0xe8, 0x1e, 0x64, 0xcf, 0x0f, 0xe7, 0xe8, 0x92, 0xb8, 0xb4, 0xfa, 0x00, 0x72,
	0xa1, 0x1d, 0x94, 0x83, 0xe5, 0x66, 0xab, 0x59, 0x2b, 0x5d, 0x43, 0x79, 0x58, 0xa9, 0x69, 0x5a,
	0x4b, 0x2b, 0x65, 0x38, 0xf1, 0xb3, 0xaa, 0xd6, 0x2c, 0x2d, 0x71, 0xe2, 0xc3, 0xda, 0xd1, 0xe9,
	0xe3, 0x52, 0x96, 0x13, 0xeb, 0xcd, 0x47, 0xad, 0xd2, 0xb2, 0xfa, 0xb7, 0x55, 0x78, 0x6d, 0xc6,
	0x00, 0xe8, 0x2e, 0xe4, 0xbd, 0x90, 0x10, 0x38, 0x69, 0x3b, 0x9a, 0xd6, 0x58, 0x56, 0x8b, 0xa4,
	0xd0, 0x11, 0x6c, 0x7a, 0x04, 0x9b, 0x96, 0xc3, 0x3b, 0x47, 0xd7, 0xa3, 0x5d, 0xe9, 0xa5, 0xc2,
	0xc1, 0xeb, 0x15, 0x79, 0x05, 0x53, 0xc1, 0xae, 0x55, 0x31, 0xa8, 0x47, 0x2a, 0x17, 0xa2, 0x77,
	0xe8, 0x12, 0x6d, 0x63, 0xac, 0x21, 0xfe, 0xd1, 0x7f, 0x43, 0xd1, 0x23, 0xae, 0x6d, 0x19, 0x58,
	0x37, 0xe8, 0xd0, 0x61, 0xc2, 0x9b, 0x45, 0x6d, 0x3d, 0x20, 0x1e, 0x73, 0x1a, 0x7a, 0x0e, 0xb9,
	0xbe, 0x8b, 0x45, 0x53, 0x18, 0xdc, 0x88, 0xdc, 0x8f, 0x8f, 0x10, 0xbb, 0x0f, 0xe2, 0x03, 0x3d,
	0xa1, 0x9e, 0xf5, 0x33, 0xea, 0x30, 0x6c, 0xb7, 0xa9, 0x59, 0x0d, 0x78, 0xc4, 0x93, 0x65, 0x42,
	0xdf, 0xc5, 0x62, 0xb9, 0xa7, 0x70, 0xc3, 0xa5, 0xa6, 0x6e, 0x5a, 0xbe, 0x37, 0x74, 0x79, 0x96,
	0xd0, 0xbb, 0x43, 0xb3, 0x47, 0x98, 0xb8, 0x14, 0x49, 0x44, 0xa4, 0x4d, 0xcd, 0x87, 0x63, 0xa9,
	0x23, 0x21, 0x24, 0x4c, 0x6d, 0xbb, 0xd3, 0x0c, 0xf4, 0x13, 0xd8, 0xe4, 0x66, 0xb1, 0xe3, 0x50,
	0x86, 0x39, 0xdd, 0x57, 0x56, 0x45, 0x2b, 0xfd, 0xfe, 0x95, 0x21, 0xe6, 0x03, 0x55, 0x23, 0xbd,
	0x9a, 0xc3, 0xbc, 0x91, 0xb6, 0xe1, 0x26, 0x88, 0xe8, 0x87, 0x50, 0x14, 0x65, 0x89, 0x4f, 0x6c,
	0x99, 0x81, 0xd6, 0x84, 0xf5, 0x7b, 0x57, 0x5b, 0xe7, 0xc7, 0xb6, 0x13, 0x68, 0x49, 0xdb, 0xeb,
	0x4e, 0x8c, 0x84, 0x0e, 0x21, 0xc7, 0x3b, 0x19, 0xc7, 0x62, 0x23, 0x25, 0x17, 0xf4, 0x7d, 0x29,
	0x51, 0xac, 0x06, 0x32, 0xda, 0x58, 0x1a, 0xbd, 0x03, 0x5b, 0xd6, 0x40, 0x34, 0xe1, 0x43, 0xdb,
	0x0e, 0x31, 0x29, 0x2f, 0x8e, 0xcb, 0xa6, 0x60, 0xb4, 0x87, 0xb6, 0x1d, 0xf4, 0x17, 0x15, 0xd8,
	0x76, 0x3d, 0x8b, 0xf2, 0x92, 0x51, 0x37, 0x6c, 0xec, 0xfb, 0xe2, 0x56, 0x4a, 0xa4, 0xad, 0xbc,
	0xb6, 0x15, 0xb2, 0x8e, 0x39, 0xa7, 0x89, 0x07, 0x04, 0xdd, 0x87, 0x1c, 0xbd, 0x20, 0x9e, 0x8d,
	0x47, 0xbe, 0x62, 0x8a, 0xa5, 0x96, 0xa3, 0xa5, 0x9e, 0x1f, 0xfa, 0xad, 0x2e, 0xcf, 0x36, 0x2d,
	0x29, 0xa2, 0x8d, 0x65, 0xcb, 0x55, 0x9e, 0x38, 0xa6, 0xdc, 0xc9, 0xdb, 0xfe, 0x73, 0x32, 0x0a,
	0x72, 0x3a, 0xff, 0x44, 0xd7, 0x61, 0xe5, 0x82, 0x9f, 0xfa, 0xe0, 0x7c, 0xcb, 0x9f, 0x0f, 0x97,
	0x0e, 0x33, 0xe5, 0x4f, 0x60, 0x6b, 0xca, 0x67, 0xf3, 0x18, 0x50, 0xbf, 0xc9, 0x02, 0x9a, 0xbe,
	0x7c, 0x41, 0x77, 0x61, 0x2d, 0xbc, 0x65, 0x81, 0xc9, 0xdb, 0xbd, 0x40, 0x4e, 0x96, 0x71, 0x5a,
	0x28, 0x87, 0x9e, 0xc2, 0x7a, 0x78, 0xcd, 0xc3, 0x46, 0x6e, 0xd8, 0xaf, 0xee, 0x5d, 0x76, 0xc7,
	0x13, 0x92, 0x4e, 0x46, 0x2e, 0xd1, 0x0a, 0x56, 0xf4, 0x83, 0xaa, 0x50, 0xb4, 0x29, 0x36, 0xf5,
	0x2e, 0xb6, 0xb1, 0x63, 0x10, 0x2f, 0xe8, 0x33, 0x62, 0x5d, 0x7e, 0x83, 0x62, 0xf3, 0x28, 0xe0,
	0x06, 0x53, 0x59, 0xb7, 0x63, 0x34, 0xf4, 0x11, 0x14, 0x7c, 0xd3, 0xd7, 0x43, 0x48, 0x2d, 0x5d,
	0x09, 0xa9, 0xe0, 0x9b, 0x7e, 0x2d, 0x40, 0xd5, 0x3e, 0xdc, 0x20, 0x2f, 0x19, 0xf1, 0x1c, 0x6c,
	0x27, 0x9a, 0x67, 0x65, 0x4b, 0xac, 0xea, 0xe0, 0xd2, 0x55, 0xd5, 0xd2, 0x34, 0xb5, 0x74, 0x83,
	0xea, 0x1e, 0x14, 0x62, 0x5e, 0xe0, 0x90, 0x58, 0xef, 0x9c, 0xd4, 0x5b, 0xa5, 0x6b, 0x68, 0x03,
	0xe0, 0xe9, 0xe9, 0x51, 0x4d, 0x6b, 0xd6, 0x4e, 0x6a, 0x9d, 0x52, 0x46, 0xfd, 0x00, 0x6e, 0xa4,
	0x5a, 0x4e, 0xa2, 0x6c, 0xa3, 0x75, 0x5c, 0x6d, 0x94, 0x32, 0xa8, 0x00, 0x6b, 0xc7, 0x8d, 0xd3,
	0xce, 0x49, 0x4d, 0x2b, 0x2d, 0xa9, 0x8f, 0x60, 0xab, 0xf6, 0x1d, 0xc4, 0x58, 0xfd, 0x32, 0x03,
	0xe5, 0xc8, 0xf1, 0x96, 0xd3, 0x4b, 0xc8, 0x2d, 0xb2, 0x6b, 0xa6, 0x02, 0x5d, 0x98, 0x37, 0xd0,
	0xea, 0x4b, 0x28, 0x26, 0xa7, 0xb1, 0x60, 0x61, 0x93, 0xc8, 0xa4, 0xd9, 0xc9, 0x4c, 0x8a, 0x60,
	0x59, 0x6c, 0x6b, 0x89, 0x02, 0xe2, 0x5b, 0xfd, 0xc7, 0x12, 0xa0, 0xe9, 0xe9, 0xa1, 0xf7, 0x61,
	0xc5, 0xa5, 0x1e, 0xe3, 0x19, 0x2a, 0x2b, 0xee, 0xd3, 0x53, 0x20, 0xaa, 0x43, 0xbc, 0x0b, 0xcb,
	0x20, 0x6d, 0xea, 0x31, 0x4d, 0x4a, 0xf3, 0xf1, 0x0d, 0x7b, 0xe8, 0x33, 0xe2, 0xd5, 0xdb, 0xe1,
	0xf8, 0x63, 0x02, 0xda, 0x85, 0x42, 0xb8, 0x81, 0xea, 0x6d, 0x5f, 0x59, 0xd9, 0xcd, 0xee, 0xe5,
	0xb5, 0x38, 0x09, 0xed, 0xc1, 0xa6, 0x4f, 0x7c, 0xdf, 0xa2, 0x4e, 0x88, 0x7f, 0xca, 0x9a, 0x04,
	0xb8, 0x09, 0x32, 0xba, 0x03, 0x1b, 0x71, 0x0f, 0xd6, 0xdb, 0x02, 0x4c, 0xf3, 0xda, 0x04, 0x15,
	0x7d, 0x08, 0x4a, 0x9c, 0xd2, 0x11, 0x48, 0xad, 0x61, 0xa7, 0x47, 0x7c, 0x25, 0x2f, 0x26, 0x30,
	0x93, 0x8f, 0x54, 0x58, 0x0f, 0x27, 0xd7, 0x8c, 0xd0, 0x33, 0x41, 0x43, 0xef, 0xcd, 0x3a, 0x65,
	0x05, 0x21, 0x3c, 0xe3, 0xc4, 0x7c, 0x95, 0x81, 0xd2, 0x24, 0xaa, 0xf2, 0xaa, 0x14, 0xbb, 0x96,
	0x7e, 0x41, 0x3c, 0xbe, 0xd2, 0x00, 0xfb, 0x00, 0xbb, 0xd6, 0xa7, 0x92, 0xc2, 0xe3, 0x77, 0x6e,
	0x39, 0x66, 0x80, 0x80, 0xe2, 0x9b, 0xd3, 0x04, 0xb2, 0x4b, 0x67, 0x8b, 0x6f, 0xf4, 0x00, 0xd6,
	0x5c, 0xcc, 0x8c, 0x3e, 0xf1, 0x95, 0x65, 0x11, 0xbe, 0xb7, 0x66, 0x63, 0x79, 0xa5, 0x8d, 0x59,
	0x3f, 0xa8, 0xc7, 0x02, 0xa5, 0xf2, 0x6d, 0xc8, 0x8f, 0xa9, 0x7c, 0x00, 0x71, 0xe9, 0x2b, 0xa7,
	0x23, 0xbe, 0xd5, 0x5f, 0xad, 0x40, 0x31, 0xf1, 0x40, 0x82, 0x4e, 0x52, 0x1f, 0x31, 0x32, 0x93,
	0x17, 0xf8, 0x09, 0xa5, 0x4a, 0xb0, 0xae, 0xe0, 0x8d, 0x25, 0xe5, 0x0d, 0xa3, 0x0d, 0xa5, 0xe0,
	0xfa, 0x30, 0xba, 0x44, 0x5a, 0x9a, 0xc7, 0xe6, 0xa6, 0x54, 0x1f, 0x77, 0x23, 0xa8, 0x1a, 0x7b,
	0xa2, 0xc8, 0xce, 0x63, 0xe9, 0x8a, 0xa7, 0x8a, 0xe5, 0x79, 0x6c, 0x4d, 0x3f, 0x55, 0x34, 0xa7,
	0xdf, 0x17, 0x56, 0x44, 0xe4, 0x5e, 0xd1, 0xe2, 0xe4, 0x43, 0x43, 0x63, 0xea, 0xa1, 0x61, 0x75,
	0x1e, 0x73, 0xc9, 0x27, 0x87, 0x32, 0x86, 0x62, 0x82, 0x8f, 0x14, 0x58, 0x4b, 0xee, 0xd2, 0xf0,
	0x17, 0xdd, 0x1f, 0xbf, 0xa8, 0x2d, 0x89, 0x2c, 0xb3, 0x33, 0x6b, 0xc0, 0x89, 0x87, 0xb5, 0x43,
	0x58, 0x0d, 0x6c, 0x47, 0x99, 0x60, 0x1d, 0x72, 0xa7, 0xed, 0x87, 0xd5, 0x93, 0x7a, 0xf3, 0xb1,
	0x4c, 0x06, 0x4f, 0x6a, 0xd5, 0xc6, 0xc9, 0x93, 0x17, 0xb2, 0xea, 0x96, 0xa5, 0x78, 0x56, 0xfd,
	0x67, 0x06, 0xf2, 0xe3, 0x0a, 0x0c, 0x7d, 0x0f, 0x56, 0x6d, 0x6b, 0x60, 0xc5, 0x80, 0x6b, 0xba,
	0xb4, 0xae, 0x34, 0x84, 0x84, 0x2c, 0xce, 0x02, 0x71, 0xf4, 0x7d, 0xc8, 0x79, 0xe4, 0xa7, 0x43,
	0xe2, 0x33, 0x3e, 0xf5, 0x6c, 0xb2, 0x34, 0x8d, 0x54, 0xb5, 0x40, 0x46, 0x2a, 0x8f, 0x55, 0xca,
	0x1f, 0x40, 0x21, 0x66, 0x75, 0xae, 0xfa, 0xe7, 0x23, 0x28, 0x26, 0xac, 0xce, 0x55, 0xfb, 0xfc,
	0x21, 0x03, 0xaf, 0xcd, 0x28, 0x9c, 0x79, 0xc9, 0x3f, 0xb0, 0x1c, 0x1d, 0x5f, 0x60, 0xcb, 0xe6,
	0x25, 0x81, 0xb0, 0x58, 0xd4, 0xd6, 0x07, 0x96, 0x53, 0x0d, 0x69, 0xa8, 0xc5, 0x0f, 0x44, 0x50,
	0xe3, 0xca, 0xa3, 0x75, 0x2f, 0x86, 0xf5, 0xe3, 0x77, 0xdd, 0x8a, 0x7b, 0xde, 0xe3, 0x04, 0xbf,
	0x32, 0x20, 0x0c, 0x73, 0xf4, 0x6f, 0xe0, 0x2e, 0xb1, 0xc3, 0xa2, 0x4d, 0x1b, 0x1b, 0x41, 0xff,
	0x0b, 0x9b, 0x03, 0xfc, 0x52, 0x1f, 0x3a, 0xd1, 0xb8, 0xb2, 0xd5, 0xd8, 0x18, 0xe0, 0x97, 0xa7,
	0x11, 0x55, 0x7d, 0x00, 0x20, 0x91, 0xe8, 0x19, 0x61, 0x78, 0x8c, 0x63, 0x2b, 0x31, 0x1c, 0x4b,
	0x64, 0xb3, 0xd5, 0x89, 0x6c, 0xa6, 0xfe, 0x7e, 0x15, 0x72, 0x27, 0xc4, 0x67, 0xbc, 0x10, 0x47,
	0xef, 0x42, 0x96, 0x38, 0x17, 0xca, 0xc7, 0x93, 0xcf, 0x69, 0xa1, 0x40, 0xa5, 0xe6, 0x5c, 0xc8,
	0x98, 0x71, 0xb9, 0x64, 0x13, 0xd6, 0x5e, 0xb4, 0x09, 0x7b, 0x3e, 0x6f, 0x13, 0x16, 0xef, 0xaf,
	0x3e, 0xfd, 0x37, 0xf7, 0x57, 0x9f, 0x7d, 0xab, 0xfe, 0x6a, 0xf1, 0x2e, 0xa5, 0x35, 0xdd, 0x99,
	0xfd, 0x48, 0x44, 0xe5, 0x4e, 0x4a, 0x54, 0x5e, 0xa5, 0x15, 0xab, 0x4f, 0xb6, 0x62, 0x3f, 0x9e,
	0xcc, 0x69, 0x63, 0x73, 0x57, 0xf5, 0x5e, 0x8b, 0x76, 0x39, 0xf7, 0x21, 0x17, 0xee, 0x9f, 0xb9,
	0x8e, 0xf6, 0x7f, 0x40, 0x77, 0x74, 0x54, 0xfa, 0xd3, 0xd7, 0x3b, 0x99, 0x3f, 0x7f, 0xbd, 0x93,
	0xf9, 0xcb, 0xd7, 0x3b, 0x99, 0xdf, 0x7c, 0xb3, 0x73, 0xad, 0xbb, 0x2a, 0x1a, 0x87, 0x7b, 0xff,
	0x0a, 0x00, 0x00, 0xff, 0xff, 0xd7, 0xd8, 0xc7, 0x3d, 0x35, 0x22, 0x00, 0x00,
}

func (m *IstioControlPlane) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IstioControlPlane) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Spec.Size()))
		n1, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Status != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Status.Size()))
		n2, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *IstioControlPlaneSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IstioControlPlaneSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DefaultNamespacePrefix) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.DefaultNamespacePrefix)))
		i += copy(dAtA[i:], m.DefaultNamespacePrefix)
	}
	if m.TrafficManagement != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.TrafficManagement.Size()))
		n3, err := m.TrafficManagement.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Policy != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Policy.Size()))
		n4, err := m.Policy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Telemetry != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Telemetry.Size()))
		n5, err := m.Telemetry.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Security != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Security.Size()))
		n6, err := m.Security.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.ConfigManagement != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ConfigManagement.Size()))
		n7, err := m.ConfigManagement.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.AutoInjection != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.AutoInjection.Size()))
		n8, err := m.AutoInjection.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.IngressGateway) > 0 {
		for _, msg := range m.IngressGateway {
			dAtA[i] = 0xfa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EgressGateway) > 0 {
		for _, msg := range m.EgressGateway {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.K8SDefaults != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.K8SDefaults.Size()))
		n9, err := m.K8SDefaults.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.BaseSpecPath) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.BaseSpecPath)))
		i += copy(dAtA[i:], m.BaseSpecPath)
	}
	if len(m.CustomPackagePath) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.CustomPackagePath)))
		i += copy(dAtA[i:], m.CustomPackagePath)
	}
	if len(m.Hub) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Hub)))
		i += copy(dAtA[i:], m.Hub)
	}
	if len(m.Tag) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Tag)))
		i += copy(dAtA[i:], m.Tag)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TrafficManagementFeatureSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrafficManagementFeatureSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Enabled.Size()))
		n10, err := m.Enabled.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Components != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Components.Size()))
		n11, err := m.Components.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TrafficManagementFeatureSpec_Components) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrafficManagementFeatureSpec_Components) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if m.Pilot != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Pilot.Size()))
		n12, err := m.Pilot.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Proxy != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Proxy.Size()))
		n13, err := m.Proxy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PolicyFeatureSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyFeatureSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Enabled.Size()))
		n14, err := m.Enabled.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.PolicyCheckFailOpen != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.PolicyCheckFailOpen.Size()))
		n15, err := m.PolicyCheckFailOpen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.OutboundTrafficPolicyMode != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.OutboundTrafficPolicyMode))
	}
	if m.Components != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Components.Size()))
		n16, err := m.Components.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PolicyFeatureSpec_Components) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyFeatureSpec_Components) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if m.Policy != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Policy.Size()))
		n17, err := m.Policy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TelemetryFeatureSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TelemetryFeatureSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Enabled.Size()))
		n18, err := m.Enabled.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Components != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Components.Size()))
		n19, err := m.Components.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TelemetryFeatureSpec_Components) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TelemetryFeatureSpec_Components) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if m.Telemetry != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Telemetry.Size()))
		n20, err := m.Telemetry.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SecurityFeatureSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityFeatureSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Enabled.Size()))
		n21, err := m.Enabled.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.ControlPlaneMtls != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ControlPlaneMtls.Size()))
		n22, err := m.ControlPlaneMtls.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.DataPlaneMtlsStrict != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.DataPlaneMtlsStrict.Size()))
		n23, err := m.DataPlaneMtlsStrict.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.Components != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Components.Size()))
		n24, err := m.Components.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SecurityFeatureSpec_Components) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityFeatureSpec_Components) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if m.Citadel != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Citadel.Size()))
		n25, err := m.Citadel.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.CertManager != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.CertManager.Size()))
		n26, err := m.CertManager.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.NodeAgent != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.NodeAgent.Size()))
		n27, err := m.NodeAgent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConfigManagementFeatureSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigManagementFeatureSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Enabled.Size()))
		n28, err := m.Enabled.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.Components != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Components.Size()))
		n29, err := m.Components.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConfigManagementFeatureSpec_Components) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigManagementFeatureSpec_Components) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if m.Galley != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Galley.Size()))
		n30, err := m.Galley.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AutoInjectionFeatureSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoInjectionFeatureSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Enabled.Size()))
		n31, err := m.Enabled.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.Components != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Components.Size()))
		n32, err := m.Components.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AutoInjectionFeatureSpec_Components) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoInjectionFeatureSpec_Components) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if m.Injector != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Injector.Size()))
		n33, err := m.Injector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PilotComponentSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PilotComponentSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n34, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.Sidecar != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Sidecar.Size()))
		n35, err := m.Sidecar.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProxyComponentSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProxyComponentSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n36, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SidecarInjectorComponentSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SidecarInjectorComponentSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n37, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PolicyComponentSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyComponentSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n38, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TelemetryComponentSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TelemetryComponentSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n39, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CitadelComponentSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CitadelComponentSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n40, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.SelfSigned {
		dAtA[i] = 0x58
		i++
		if m.SelfSigned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CreateMeshPolicy {
		dAtA[i] = 0x60
		i++
		if m.CreateMeshPolicy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CertManagerComponentSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertManagerComponentSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n41, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NodeAgentComponentSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeAgentComponentSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n42, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GalleyComponentSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GalleyComponentSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n43, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommonComponentSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommonComponentSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Enabled.Size()))
		n44, err := m.Enabled.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if m.Debug != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Debug))
	}
	if m.K8S != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.K8S.Size()))
		n45, err := m.K8S.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KubernetesResourcesSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesResourcesSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Resources != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Resources.Size()))
		n46, err := m.Resources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if m.ReadinessProbe != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ReadinessProbe.Size()))
		n47, err := m.ReadinessProbe.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if m.ReplicaCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ReplicaCount))
	}
	if m.HpaSpec != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.HpaSpec.Size()))
		n48, err := m.HpaSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	if m.PodDisruptionBudget != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.PodDisruptionBudget.Size()))
		n49, err := m.PodDisruptionBudget.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if len(m.PodAnnotations) > 0 {
		for k, _ := range m.PodAnnotations {
			dAtA[i] = 0x32
			i++
			v := m.PodAnnotations[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.NodeSelector) > 0 {
		for k, _ := range m.NodeSelector {
			dAtA[i] = 0x3a
			i++
			v := m.NodeSelector[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Affinity != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Affinity.Size()))
		n50, err := m.Affinity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if len(m.ImagePullPolicy) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.ImagePullPolicy)))
		i += copy(dAtA[i:], m.ImagePullPolicy)
	}
	if len(m.PriorityClassName) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.PriorityClassName)))
		i += copy(dAtA[i:], m.PriorityClassName)
	}
	if len(m.Overlays) > 0 {
		for _, msg := range m.Overlays {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *IngressGatewaySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngressGatewaySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Gateway != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Gateway.Size()))
		n51, err := m.Gateway.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if m.IngressType != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.IngressType))
	}
	if m.LoadBalancer != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.LoadBalancer.Size()))
		n52, err := m.LoadBalancer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if m.SdsEnabled != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.SdsEnabled.Size()))
		n53, err := m.SdsEnabled.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if m.ExternalTrafficPolicy != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ExternalTrafficPolicy))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EgressGatewaySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EgressGatewaySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Gateway != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Gateway.Size()))
		n54, err := m.Gateway.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LoadBalancingGatewayConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadBalancingGatewayConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Gateway != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Gateway.Size()))
		n55, err := m.Gateway.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	if m.LoadBalancer != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.LoadBalancer.Size()))
		n56, err := m.LoadBalancer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GatewayConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GatewayConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n57, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LoadBalancerConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadBalancerConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ClusterIP) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.ClusterIP)))
		i += copy(dAtA[i:], m.ClusterIP)
	}
	if len(m.ExternalIPs) > 0 {
		for _, s := range m.ExternalIPs {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.SessionAffinity) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.SessionAffinity)))
		i += copy(dAtA[i:], m.SessionAffinity)
	}
	if len(m.LoadBalancerIP) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.LoadBalancerIP)))
		i += copy(dAtA[i:], m.LoadBalancerIP)
	}
	if len(m.LoadBalancerSourceRanges) > 0 {
		for _, s := range m.LoadBalancerSourceRanges {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ExternalName) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.ExternalName)))
		i += copy(dAtA[i:], m.ExternalName)
	}
	if len(m.ExternalTrafficPolicy) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.ExternalTrafficPolicy)))
		i += copy(dAtA[i:], m.ExternalTrafficPolicy)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *K8SObjectOverlay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SObjectOverlay) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiVersion) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.ApiVersion)))
		i += copy(dAtA[i:], m.ApiVersion)
	}
	if len(m.Kind) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Patches) > 0 {
		for _, msg := range m.Patches {
			dAtA[i] = 0x22
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *K8SObjectOverlay_PathValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SObjectOverlay_PathValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InstallStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstallStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TrafficManagement != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.TrafficManagement.Size()))
		n58, err := m.TrafficManagement.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	if m.PolicyTelemetry != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.PolicyTelemetry.Size()))
		n59, err := m.PolicyTelemetry.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	if m.Security != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Security.Size()))
		n60, err := m.Security.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	if m.ConfigManagement != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ConfigManagement.Size()))
		n61, err := m.ConfigManagement.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	if len(m.IngressGateway) > 0 {
		for _, msg := range m.IngressGateway {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EgressGateway) > 0 {
		for _, msg := range m.EgressGateway {
			dAtA[i] = 0x32
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InstallStatus_VersionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstallStatus_VersionStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Resources) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resources) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Limits) > 0 {
		for k, _ := range m.Limits {
			dAtA[i] = 0xa
			i++
			v := m.Limits[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Requests) > 0 {
		for k, _ := range m.Requests {
			dAtA[i] = 0x12
			i++
			v := m.Requests[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PodDisruptionBudgetSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodDisruptionBudgetSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MinAvailable != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.MinAvailable))
	}
	if m.Selector != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Selector.Size()))
		n62, err := m.Selector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	if m.MaxUnavailable != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.MaxUnavailable))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ObjectMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TestKube) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestKube) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Affinity != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Affinity.Size()))
		n63, err := m.Affinity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	if len(m.Env) > 0 {
		for k, _ := range m.Env {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x3
			i++
			v := m.Env[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Resources != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Resources.Size()))
		n64, err := m.Resources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	if m.ReadinessProbe != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ReadinessProbe.Size()))
		n65, err := m.ReadinessProbe.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	if m.HpaSpec != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.HpaSpec.Size()))
		n66, err := m.HpaSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	if m.PodDisruptionBudget != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.PodDisruptionBudget.Size()))
		n67, err := m.PodDisruptionBudget.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	if len(m.PodAnnotations) > 0 {
		for k, _ := range m.PodAnnotations {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x5
			i++
			v := m.PodAnnotations[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.NodeSelector) > 0 {
		for k, _ := range m.NodeSelector {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x5
			i++
			v := m.NodeSelector[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Overlays) > 0 {
		for _, msg := range m.Overlays {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintIstioinstallerTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *IstioControlPlane) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IstioControlPlaneSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DefaultNamespacePrefix)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.TrafficManagement != nil {
		l = m.TrafficManagement.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Telemetry != nil {
		l = m.Telemetry.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Security != nil {
		l = m.Security.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ConfigManagement != nil {
		l = m.ConfigManagement.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.AutoInjection != nil {
		l = m.AutoInjection.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.IngressGateway) > 0 {
		for _, e := range m.IngressGateway {
			l = e.Size()
			n += 2 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if len(m.EgressGateway) > 0 {
		for _, e := range m.EgressGateway {
			l = e.Size()
			n += 2 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if m.K8SDefaults != nil {
		l = m.K8SDefaults.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.BaseSpecPath)
	if l > 0 {
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.CustomPackagePath)
	if l > 0 {
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.Hub)
	if l > 0 {
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TrafficManagementFeatureSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Components != nil {
		l = m.Components.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TrafficManagementFeatureSpec_Components) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Pilot != nil {
		l = m.Pilot.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Proxy != nil {
		l = m.Proxy.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PolicyFeatureSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.PolicyCheckFailOpen != nil {
		l = m.PolicyCheckFailOpen.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.OutboundTrafficPolicyMode != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.OutboundTrafficPolicyMode))
	}
	if m.Components != nil {
		l = m.Components.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PolicyFeatureSpec_Components) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TelemetryFeatureSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Components != nil {
		l = m.Components.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TelemetryFeatureSpec_Components) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Telemetry != nil {
		l = m.Telemetry.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityFeatureSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ControlPlaneMtls != nil {
		l = m.ControlPlaneMtls.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.DataPlaneMtlsStrict != nil {
		l = m.DataPlaneMtlsStrict.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Components != nil {
		l = m.Components.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityFeatureSpec_Components) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Citadel != nil {
		l = m.Citadel.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.CertManager != nil {
		l = m.CertManager.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.NodeAgent != nil {
		l = m.NodeAgent.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigManagementFeatureSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Components != nil {
		l = m.Components.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigManagementFeatureSpec_Components) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Galley != nil {
		l = m.Galley.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AutoInjectionFeatureSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Components != nil {
		l = m.Components.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AutoInjectionFeatureSpec_Components) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Injector != nil {
		l = m.Injector.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PilotComponentSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Sidecar != nil {
		l = m.Sidecar.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProxyComponentSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SidecarInjectorComponentSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PolicyComponentSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TelemetryComponentSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CitadelComponentSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.SelfSigned {
		n += 2
	}
	if m.CreateMeshPolicy {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CertManagerComponentSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeAgentComponentSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GalleyComponentSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommonComponentSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Debug != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.Debug))
	}
	if m.K8S != nil {
		l = m.K8S.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KubernetesResourcesSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ReadinessProbe != nil {
		l = m.ReadinessProbe.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ReplicaCount != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.ReplicaCount))
	}
	if m.HpaSpec != nil {
		l = m.HpaSpec.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.PodDisruptionBudget != nil {
		l = m.PodDisruptionBudget.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.PodAnnotations) > 0 {
		for k, v := range m.PodAnnotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if len(m.NodeSelector) > 0 {
		for k, v := range m.NodeSelector {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if m.Affinity != nil {
		l = m.Affinity.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.ImagePullPolicy)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.PriorityClassName)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.Overlays) > 0 {
		for _, e := range m.Overlays {
			l = e.Size()
			n += 2 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IngressGatewaySpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gateway != nil {
		l = m.Gateway.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.IngressType != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.IngressType))
	}
	if m.LoadBalancer != nil {
		l = m.LoadBalancer.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.SdsEnabled != nil {
		l = m.SdsEnabled.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ExternalTrafficPolicy != 0 {
		n += 2 + sovIstioinstallerTypes(uint64(m.ExternalTrafficPolicy))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EgressGatewaySpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gateway != nil {
		l = m.Gateway.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoadBalancingGatewayConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gateway != nil {
		l = m.Gateway.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.LoadBalancer != nil {
		l = m.LoadBalancer.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GatewayConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoadBalancerConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	l = len(m.ClusterIP)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.ExternalIPs) > 0 {
		for _, s := range m.ExternalIPs {
			l = len(s)
			n += 1 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	l = len(m.SessionAffinity)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.LoadBalancerIP)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.LoadBalancerSourceRanges) > 0 {
		for _, s := range m.LoadBalancerSourceRanges {
			l = len(s)
			n += 1 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	l = len(m.ExternalName)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.ExternalTrafficPolicy)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *K8SObjectOverlay) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ApiVersion)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.Patches) > 0 {
		for _, e := range m.Patches {
			l = e.Size()
			n += 1 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *K8SObjectOverlay_PathValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InstallStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TrafficManagement != nil {
		l = m.TrafficManagement.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.PolicyTelemetry != nil {
		l = m.PolicyTelemetry.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Security != nil {
		l = m.Security.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ConfigManagement != nil {
		l = m.ConfigManagement.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.IngressGateway) > 0 {
		for _, e := range m.IngressGateway {
			l = e.Size()
			n += 1 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if len(m.EgressGateway) > 0 {
		for _, e := range m.EgressGateway {
			l = e.Size()
			n += 1 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InstallStatus_VersionStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Resources) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Limits) > 0 {
		for k, v := range m.Limits {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Requests) > 0 {
		for k, v := range m.Requests {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PodDisruptionBudgetSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinAvailable != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.MinAvailable))
	}
	if m.Selector != nil {
		l = m.Selector.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.MaxUnavailable != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.MaxUnavailable))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestKube) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Affinity != nil {
		l = m.Affinity.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.Env) > 0 {
		for k, v := range m.Env {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ReadinessProbe != nil {
		l = m.ReadinessProbe.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.HpaSpec != nil {
		l = m.HpaSpec.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.PodDisruptionBudget != nil {
		l = m.PodDisruptionBudget.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.PodAnnotations) > 0 {
		for k, v := range m.PodAnnotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if len(m.NodeSelector) > 0 {
		for k, v := range m.NodeSelector {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Overlays) > 0 {
		for _, e := range m.Overlays {
			l = e.Size()
			n += 2 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovIstioinstallerTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozIstioinstallerTypes(x uint64) (n int) {
	return sovIstioinstallerTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *IstioControlPlane) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IstioControlPlane: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IstioControlPlane: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &IstioControlPlaneSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &InstallStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IstioControlPlaneSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IstioControlPlaneSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IstioControlPlaneSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultNamespacePrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultNamespacePrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficManagement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrafficManagement == nil {
				m.TrafficManagement = &TrafficManagementFeatureSpec{}
			}
			if err := m.TrafficManagement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &PolicyFeatureSpec{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Telemetry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Telemetry == nil {
				m.Telemetry = &TelemetryFeatureSpec{}
			}
			if err := m.Telemetry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Security", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Security == nil {
				m.Security = &SecurityFeatureSpec{}
			}
			if err := m.Security.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigManagement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigManagement == nil {
				m.ConfigManagement = &ConfigManagementFeatureSpec{}
			}
			if err := m.ConfigManagement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoInjection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoInjection == nil {
				m.AutoInjection = &AutoInjectionFeatureSpec{}
			}
			if err := m.AutoInjection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngressGateway = append(m.IngressGateway, &IngressGatewaySpec{})
			if err := m.IngressGateway[len(m.IngressGateway)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgressGateway = append(m.EgressGateway, &EgressGatewaySpec{})
			if err := m.EgressGateway[len(m.EgressGateway)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 80:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8SDefaults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.K8SDefaults == nil {
				m.K8SDefaults = &KubernetesResourcesSpec{}
			}
			if err := m.K8SDefaults.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseSpecPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseSpecPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomPackagePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomPackagePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hub", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hub = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 104:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrafficManagementFeatureSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrafficManagementFeatureSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrafficManagementFeatureSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &protobuf.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Components", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Components == nil {
				m.Components = &TrafficManagementFeatureSpec_Components{}
			}
			if err := m.Components.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrafficManagementFeatureSpec_Components) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Components: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Components: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pilot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pilot == nil {
				m.Pilot = &PilotComponentSpec{}
			}
			if err := m.Pilot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proxy == nil {
				m.Proxy = &ProxyComponentSpec{}
			}
			if err := m.Proxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyFeatureSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyFeatureSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyFeatureSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &protobuf.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyCheckFailOpen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PolicyCheckFailOpen == nil {
				m.PolicyCheckFailOpen = &protobuf.BoolValue{}
			}
			if err := m.PolicyCheckFailOpen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutboundTrafficPolicyMode", wireType)
			}
			m.OutboundTrafficPolicyMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutboundTrafficPolicyMode |= PolicyFeatureSpec_OutboundPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Components", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Components == nil {
				m.Components = &PolicyFeatureSpec_Components{}
			}
			if err := m.Components.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyFeatureSpec_Components) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Components: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Components: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &PolicyComponentSpec{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TelemetryFeatureSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TelemetryFeatureSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TelemetryFeatureSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &protobuf.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Components", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Components == nil {
				m.Components = &TelemetryFeatureSpec_Components{}
			}
			if err := m.Components.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TelemetryFeatureSpec_Components) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Components: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Components: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Telemetry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Telemetry == nil {
				m.Telemetry = &TelemetryComponentSpec{}
			}
			if err := m.Telemetry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityFeatureSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityFeatureSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityFeatureSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &protobuf.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlPlaneMtls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ControlPlaneMtls == nil {
				m.ControlPlaneMtls = &protobuf.BoolValue{}
			}
			if err := m.ControlPlaneMtls.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataPlaneMtlsStrict", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataPlaneMtlsStrict == nil {
				m.DataPlaneMtlsStrict = &protobuf.BoolValue{}
			}
			if err := m.DataPlaneMtlsStrict.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Components", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Components == nil {
				m.Components = &SecurityFeatureSpec_Components{}
			}
			if err := m.Components.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityFeatureSpec_Components) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Components: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Components: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Citadel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Citadel == nil {
				m.Citadel = &CitadelComponentSpec{}
			}
			if err := m.Citadel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertManager", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CertManager == nil {
				m.CertManager = &CertManagerComponentSpec{}
			}
			if err := m.CertManager.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAgent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeAgent == nil {
				m.NodeAgent = &NodeAgentComponentSpec{}
			}
			if err := m.NodeAgent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigManagementFeatureSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigManagementFeatureSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigManagementFeatureSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &protobuf.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Components", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Components == nil {
				m.Components = &ConfigManagementFeatureSpec_Components{}
			}
			if err := m.Components.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigManagementFeatureSpec_Components) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Components: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Components: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Galley", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Galley == nil {
				m.Galley = &GalleyComponentSpec{}
			}
			if err := m.Galley.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoInjectionFeatureSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoInjectionFeatureSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoInjectionFeatureSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &protobuf.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Components", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Components == nil {
				m.Components = &AutoInjectionFeatureSpec_Components{}
			}
			if err := m.Components.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoInjectionFeatureSpec_Components) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Components: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Components: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Injector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Injector == nil {
				m.Injector = &SidecarInjectorComponentSpec{}
			}
			if err := m.Injector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PilotComponentSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PilotComponentSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PilotComponentSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentSpec{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sidecar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sidecar == nil {
				m.Sidecar = &protobuf.BoolValue{}
			}
			if err := m.Sidecar.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProxyComponentSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProxyComponentSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProxyComponentSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentSpec{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SidecarInjectorComponentSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SidecarInjectorComponentSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SidecarInjectorComponentSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentSpec{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyComponentSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyComponentSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyComponentSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentSpec{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TelemetryComponentSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TelemetryComponentSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TelemetryComponentSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentSpec{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CitadelComponentSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CitadelComponentSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CitadelComponentSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentSpec{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfSigned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SelfSigned = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateMeshPolicy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateMeshPolicy = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertManagerComponentSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertManagerComponentSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertManagerComponentSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentSpec{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeAgentComponentSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeAgentComponentSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeAgentComponentSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentSpec{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GalleyComponentSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GalleyComponentSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GalleyComponentSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentSpec{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommonComponentSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommonComponentSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommonComponentSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &protobuf.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			m.Debug = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Debug |= CommonComponentSpec_LogLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 80:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8S", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.K8S == nil {
				m.K8S = &KubernetesResourcesSpec{}
			}
			if err := m.K8S.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesResourcesSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubernetesResourcesSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubernetesResourcesSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &Resources{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadinessProbe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadinessProbe == nil {
				m.ReadinessProbe = &v1.Probe{}
			}
			if err := m.ReadinessProbe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaCount", wireType)
			}
			m.ReplicaCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HpaSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HpaSpec == nil {
				m.HpaSpec = &v11.HorizontalPodAutoscalerSpec{}
			}
			if err := m.HpaSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodDisruptionBudget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodDisruptionBudget == nil {
				m.PodDisruptionBudget = &PodDisruptionBudgetSpec{}
			}
			if err := m.PodDisruptionBudget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodAnnotations == nil {
				m.PodAnnotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PodAnnotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeSelector == nil {
				m.NodeSelector = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeSelector[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Affinity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Affinity == nil {
				m.Affinity = &v1.Affinity{}
			}
			if err := m.Affinity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePullPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImagePullPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriorityClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriorityClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Overlays", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Overlays = append(m.Overlays, &K8SObjectOverlay{})
			if err := m.Overlays[len(m.Overlays)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngressGatewaySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngressGatewaySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngressGatewaySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gateway == nil {
				m.Gateway = &GatewayConfig{}
			}
			if err := m.Gateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressType", wireType)
			}
			m.IngressType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IngressType |= IngressGatewaySpec_IngressType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LoadBalancer == nil {
				m.LoadBalancer = &LoadBalancerConfig{}
			}
			if err := m.LoadBalancer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SdsEnabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SdsEnabled == nil {
				m.SdsEnabled = &protobuf.BoolValue{}
			}
			if err := m.SdsEnabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalTrafficPolicy", wireType)
			}
			m.ExternalTrafficPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalTrafficPolicy |= IngressGatewaySpec_ExternalTrafficPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EgressGatewaySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EgressGatewaySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EgressGatewaySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gateway == nil {
				m.Gateway = &GatewayConfig{}
			}
			if err := m.Gateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadBalancingGatewayConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadBalancingGatewayConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadBalancingGatewayConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gateway == nil {
				m.Gateway = &GatewayConfig{}
			}
			if err := m.Gateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LoadBalancer == nil {
				m.LoadBalancer = &LoadBalancerConfig{}
			}
			if err := m.LoadBalancer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GatewayConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GatewayConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GatewayConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentSpec{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadBalancerConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadBalancerConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadBalancerConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &v1.ServicePort{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalIPs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalIPs = append(m.ExternalIPs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionAffinity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionAffinity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancerIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadBalancerIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancerSourceRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadBalancerSourceRanges = append(m.LoadBalancerSourceRanges, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalTrafficPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalTrafficPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SObjectOverlay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: k8sObjectOverlay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: k8sObjectOverlay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Patches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Patches = append(m.Patches, &K8SObjectOverlay_PathValue{})
			if err := m.Patches[len(m.Patches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SObjectOverlay_PathValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstallStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstallStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstallStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficManagement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrafficManagement == nil {
				m.TrafficManagement = &InstallStatus_VersionStatus{}
			}
			if err := m.TrafficManagement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyTelemetry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PolicyTelemetry == nil {
				m.PolicyTelemetry = &InstallStatus_VersionStatus{}
			}
			if err := m.PolicyTelemetry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Security", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Security == nil {
				m.Security = &InstallStatus_VersionStatus{}
			}
			if err := m.Security.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigManagement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigManagement == nil {
				m.ConfigManagement = &InstallStatus_VersionStatus{}
			}
			if err := m.ConfigManagement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngressGateway = append(m.IngressGateway, &InstallStatus_VersionStatus{})
			if err := m.IngressGateway[len(m.IngressGateway)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgressGateway = append(m.EgressGateway, &InstallStatus_VersionStatus{})
			if err := m.EgressGateway[len(m.EgressGateway)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstallStatus_VersionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= InstallStatus_Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resources) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Resources: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Resources: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limits == nil {
				m.Limits = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Limits[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Requests == nil {
				m.Requests = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Requests[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodDisruptionBudgetSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodDisruptionBudgetSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodDisruptionBudgetSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAvailable", wireType)
			}
			m.MinAvailable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinAvailable |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Selector == nil {
				m.Selector = &v12.LabelSelector{}
			}
			if err := m.Selector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUnavailable", wireType)
			}
			m.MaxUnavailable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxUnavailable |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestKube) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestKube: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestKube: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Affinity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Affinity == nil {
				m.Affinity = &v1.Affinity{}
			}
			if err := m.Affinity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Env == nil {
				m.Env = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Env[mapkey] = mapvalue
			iNdEx = postIndex
		case 80:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &Resources{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 81:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadinessProbe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadinessProbe == nil {
				m.ReadinessProbe = &v1.Probe{}
			}
			if err := m.ReadinessProbe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 86:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HpaSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HpaSpec == nil {
				m.HpaSpec = &v11.HorizontalPodAutoscalerSpec{}
			}
			if err := m.HpaSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 87:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodDisruptionBudget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodDisruptionBudget == nil {
				m.PodDisruptionBudget = &PodDisruptionBudgetSpec{}
			}
			if err := m.PodDisruptionBudget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 90:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodAnnotations == nil {
				m.PodAnnotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PodAnnotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 92:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeSelector == nil {
				m.NodeSelector = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeSelector[mapkey] = mapvalue
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Overlays", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Overlays = append(m.Overlays, &K8SObjectOverlay{})
			if err := m.Overlays[len(m.Overlays)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipIstioinstallerTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthIstioinstallerTypes
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthIstioinstallerTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipIstioinstallerTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthIstioinstallerTypes
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthIstioinstallerTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowIstioinstallerTypes   = fmt.Errorf("proto: integer overflow")
)
