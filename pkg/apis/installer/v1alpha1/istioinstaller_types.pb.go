// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: istioinstaller_types.proto

package v1alpha1

import (
	fmt "fmt"
	protobuf "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	io "io"
	v11 "k8s.io/api/autoscaling/v1"
	v1 "k8s.io/api/core/v1"
	v12 "k8s.io/apimachinery/pkg/apis/meta/v1"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Default behavior of the sidecar for handling outbound traffic from the application.
type PolicyTelemetryFeatureSpec_OutboundPolicy int32

const (
	// Outbound traffic to unknown destinations will be allowed, in case there are no
	// services or ServiceEntries for the destination port
	PolicyTelemetryFeatureSpec_ALLOW_ANY PolicyTelemetryFeatureSpec_OutboundPolicy = 0
	// Restrict outbound traffic to services defined in the service registry as well
	// as those defined through ServiceEntries
	PolicyTelemetryFeatureSpec_REGISTRY_ONLY PolicyTelemetryFeatureSpec_OutboundPolicy = 1
)

var PolicyTelemetryFeatureSpec_OutboundPolicy_name = map[int32]string{
	0: "ALLOW_ANY",
	1: "REGISTRY_ONLY",
}

var PolicyTelemetryFeatureSpec_OutboundPolicy_value = map[string]int32{
	"ALLOW_ANY":     0,
	"REGISTRY_ONLY": 1,
}

func (x PolicyTelemetryFeatureSpec_OutboundPolicy) String() string {
	return proto.EnumName(PolicyTelemetryFeatureSpec_OutboundPolicy_name, int32(x))
}

func (PolicyTelemetryFeatureSpec_OutboundPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{3, 0}
}

// LogLevel sets the component log level. Mappings to underlying log levels are not necessarily 1:1 and depend on
// component support of these levels e.g. DEBUG or INFO may result in the same log verbosity.
type CommonComponentSpec_LogLevel int32

const (
	CommonComponentSpec_NONE  CommonComponentSpec_LogLevel = 0
	CommonComponentSpec_ERROR CommonComponentSpec_LogLevel = 1
	CommonComponentSpec_WARN  CommonComponentSpec_LogLevel = 2
	CommonComponentSpec_DEBUG CommonComponentSpec_LogLevel = 3
	CommonComponentSpec_INFO  CommonComponentSpec_LogLevel = 4
)

var CommonComponentSpec_LogLevel_name = map[int32]string{
	0: "NONE",
	1: "ERROR",
	2: "WARN",
	3: "DEBUG",
	4: "INFO",
}

var CommonComponentSpec_LogLevel_value = map[string]int32{
	"NONE":  0,
	"ERROR": 1,
	"WARN":  2,
	"DEBUG": 3,
	"INFO":  4,
}

func (x CommonComponentSpec_LogLevel) String() string {
	return proto.EnumName(CommonComponentSpec_LogLevel_name, int32(x))
}

func (CommonComponentSpec_LogLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{15, 0}
}

// Selects the type of ingress.
// Ingress type.
type IngressGatewaySpec_IngressType int32

const (
	IngressGatewaySpec_ISTIO      IngressGatewaySpec_IngressType = 0
	IngressGatewaySpec_KUBERNETES IngressGatewaySpec_IngressType = 1
)

var IngressGatewaySpec_IngressType_name = map[int32]string{
	0: "ISTIO",
	1: "KUBERNETES",
}

var IngressGatewaySpec_IngressType_value = map[string]int32{
	"ISTIO":      0,
	"KUBERNETES": 1,
}

func (x IngressGatewaySpec_IngressType) String() string {
	return proto.EnumName(IngressGatewaySpec_IngressType_name, int32(x))
}

func (IngressGatewaySpec_IngressType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{17, 0}
}

// change to Local to preserve source IP or Cluster for default behaviour or leave commented out
// ???
// External traffic policy.
type IngressGatewaySpec_ExternalTrafficPolicy int32

const (
	IngressGatewaySpec_NONE IngressGatewaySpec_ExternalTrafficPolicy = 0
	// Preserves source IP.
	IngressGatewaySpec_LOCAL   IngressGatewaySpec_ExternalTrafficPolicy = 1
	IngressGatewaySpec_CLUSTER IngressGatewaySpec_ExternalTrafficPolicy = 2
)

var IngressGatewaySpec_ExternalTrafficPolicy_name = map[int32]string{
	0: "NONE",
	1: "LOCAL",
	2: "CLUSTER",
}

var IngressGatewaySpec_ExternalTrafficPolicy_value = map[string]int32{
	"NONE":    0,
	"LOCAL":   1,
	"CLUSTER": 2,
}

func (x IngressGatewaySpec_ExternalTrafficPolicy) String() string {
	return proto.EnumName(IngressGatewaySpec_ExternalTrafficPolicy_name, int32(x))
}

func (IngressGatewaySpec_ExternalTrafficPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{17, 1}
}

type InstallerStatus_Status int32

const (
	InstallerStatus_NONE     InstallerStatus_Status = 0
	InstallerStatus_UPDATING InstallerStatus_Status = 1
	InstallerStatus_HEALTHY  InstallerStatus_Status = 2
	InstallerStatus_ERROR    InstallerStatus_Status = 3
)

var InstallerStatus_Status_name = map[int32]string{
	0: "NONE",
	1: "UPDATING",
	2: "HEALTHY",
	3: "ERROR",
}

var InstallerStatus_Status_value = map[string]int32{
	"NONE":     0,
	"UPDATING": 1,
	"HEALTHY":  2,
	"ERROR":    3,
}

func (x InstallerStatus_Status) String() string {
	return proto.EnumName(InstallerStatus_Status_name, int32(x))
}

func (InstallerStatus_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{24, 0}
}

type IstioInstaller struct {
	Spec                 *InstallerSpec   `protobuf:"bytes,3,opt,name=spec,proto3" json:"spec,omitempty"`
	Status               *InstallerStatus `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *IstioInstaller) Reset()         { *m = IstioInstaller{} }
func (m *IstioInstaller) String() string { return proto.CompactTextString(m) }
func (*IstioInstaller) ProtoMessage()    {}
func (*IstioInstaller) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{0}
}
func (m *IstioInstaller) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IstioInstaller) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IstioInstaller.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IstioInstaller) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IstioInstaller.Merge(m, src)
}
func (m *IstioInstaller) XXX_Size() int {
	return m.Size()
}
func (m *IstioInstaller) XXX_DiscardUnknown() {
	xxx_messageInfo_IstioInstaller.DiscardUnknown(m)
}

var xxx_messageInfo_IstioInstaller proto.InternalMessageInfo

func (m *IstioInstaller) GetSpec() *InstallerSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *IstioInstaller) GetStatus() *InstallerStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// InstallerSpec defines the desired state of IstioInstaller.
type InstallerSpec struct {
	// Prefix added to all namespaces for any installed component.
	DefaultNamespacePrefix string `protobuf:"bytes,5,opt,name=default_namespace_prefix,json=defaultNamespacePrefix,proto3" json:"default_namespace_prefix,omitempty"`
	// Selection and configuration of core Istio features.
	TrafficManagement *TrafficManagementFeatureSpec `protobuf:"bytes,25,opt,name=traffic_management,json=trafficManagement,proto3" json:"traffic_management,omitempty"`
	PolicyTelemetry   *PolicyTelemetryFeatureSpec   `protobuf:"bytes,26,opt,name=policy_telemetry,json=policyTelemetry,proto3" json:"policy_telemetry,omitempty"`
	Security          *SecurityFeatureSpec          `protobuf:"bytes,28,opt,name=security,proto3" json:"security,omitempty"`
	ConfigManagement  *ConfigManagementFeatureSpec  `protobuf:"bytes,29,opt,name=config_management,json=configManagement,proto3" json:"config_management,omitempty"`
	// Ingress/egress gateway installation and configuration.
	IngressGateway []*IngressGatewaySpec `protobuf:"bytes,30,rep,name=ingress_gateway,json=ingressGateway,proto3" json:"ingress_gateway,omitempty"`
	EgressGateway  []*EgressGatewaySpec  `protobuf:"bytes,31,rep,name=egress_gateway,json=egressGateway,proto3" json:"egress_gateway,omitempty"`
	// List of external operators that will be installed (but not managed)
	// by the IstioInstaller e.g. prometheus, grafana, kiali.
	ExternalOperators []*OperatorSpec `protobuf:"bytes,50,rep,name=external_operators,json=externalOperators,proto3" json:"external_operators,omitempty"`
	// Global k8s defaults. Can be overridden per component.
	K8SDefaults *KubernetesResourcesSpec `protobuf:"bytes,80,opt,name=k8s_defaults,json=k8sDefaults,proto3" json:"k8s_defaults,omitempty"`
	// URL for the install package. e.g.
	//   http://github.com/istio/istio/releases/install/1.1.2
	//   http://github.com/istio/istio/releases/install/lts
	//   file://tmp/istio-installer/nightly
	// Uses compiled in install package by default.
	CustomPackagePath string `protobuf:"bytes,100,opt,name=custom_package_path,json=customPackagePath,proto3" json:"custom_package_path,omitempty"`
	// Root for docker image paths e.g. docker.io/istio-release.
	// Releases are published to docker hub under 'istio' project.
	// Daily builds from prow are on gcr.io, and nightly builds from circle on docker.io/istionightly
	Hub string `protobuf:"bytes,101,opt,name=hub,proto3" json:"hub,omitempty"`
	// Version tag for docker images e.g. 1.0.6
	Tag                  string   `protobuf:"bytes,102,opt,name=tag,proto3" json:"tag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InstallerSpec) Reset()         { *m = InstallerSpec{} }
func (m *InstallerSpec) String() string { return proto.CompactTextString(m) }
func (*InstallerSpec) ProtoMessage()    {}
func (*InstallerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{1}
}
func (m *InstallerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstallerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstallerSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstallerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallerSpec.Merge(m, src)
}
func (m *InstallerSpec) XXX_Size() int {
	return m.Size()
}
func (m *InstallerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_InstallerSpec proto.InternalMessageInfo

func (m *InstallerSpec) GetDefaultNamespacePrefix() string {
	if m != nil {
		return m.DefaultNamespacePrefix
	}
	return ""
}

func (m *InstallerSpec) GetTrafficManagement() *TrafficManagementFeatureSpec {
	if m != nil {
		return m.TrafficManagement
	}
	return nil
}

func (m *InstallerSpec) GetPolicyTelemetry() *PolicyTelemetryFeatureSpec {
	if m != nil {
		return m.PolicyTelemetry
	}
	return nil
}

func (m *InstallerSpec) GetSecurity() *SecurityFeatureSpec {
	if m != nil {
		return m.Security
	}
	return nil
}

func (m *InstallerSpec) GetConfigManagement() *ConfigManagementFeatureSpec {
	if m != nil {
		return m.ConfigManagement
	}
	return nil
}

func (m *InstallerSpec) GetIngressGateway() []*IngressGatewaySpec {
	if m != nil {
		return m.IngressGateway
	}
	return nil
}

func (m *InstallerSpec) GetEgressGateway() []*EgressGatewaySpec {
	if m != nil {
		return m.EgressGateway
	}
	return nil
}

func (m *InstallerSpec) GetExternalOperators() []*OperatorSpec {
	if m != nil {
		return m.ExternalOperators
	}
	return nil
}

func (m *InstallerSpec) GetK8SDefaults() *KubernetesResourcesSpec {
	if m != nil {
		return m.K8SDefaults
	}
	return nil
}

func (m *InstallerSpec) GetCustomPackagePath() string {
	if m != nil {
		return m.CustomPackagePath
	}
	return ""
}

func (m *InstallerSpec) GetHub() string {
	if m != nil {
		return m.Hub
	}
	return ""
}

func (m *InstallerSpec) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

// Configuration options for traffic management.
type TrafficManagementFeatureSpec struct {
	// Selects whether traffic management is installed.
	// Must be enabled to enable any sub-component.
	Enabled *protobuf.BoolValue `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Namespace that all traffic management components are installed into.
	Namespace     string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	ClusterDomain string `protobuf:"bytes,24,opt,name=cluster_domain,json=clusterDomain,proto3" json:"cluster_domain,omitempty"`
	// Component specific config.
	Pilot                *PilotComponentSpec           `protobuf:"bytes,30,opt,name=pilot,proto3" json:"pilot,omitempty"`
	Proxy                *ProxyComponentSpec           `protobuf:"bytes,31,opt,name=proxy,proto3" json:"proxy,omitempty"`
	SidecarInjector      *SidecarInjectorComponentSpec `protobuf:"bytes,32,opt,name=sidecar_injector,json=sidecarInjector,proto3" json:"sidecar_injector,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *TrafficManagementFeatureSpec) Reset()         { *m = TrafficManagementFeatureSpec{} }
func (m *TrafficManagementFeatureSpec) String() string { return proto.CompactTextString(m) }
func (*TrafficManagementFeatureSpec) ProtoMessage()    {}
func (*TrafficManagementFeatureSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{2}
}
func (m *TrafficManagementFeatureSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrafficManagementFeatureSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrafficManagementFeatureSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrafficManagementFeatureSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrafficManagementFeatureSpec.Merge(m, src)
}
func (m *TrafficManagementFeatureSpec) XXX_Size() int {
	return m.Size()
}
func (m *TrafficManagementFeatureSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TrafficManagementFeatureSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TrafficManagementFeatureSpec proto.InternalMessageInfo

func (m *TrafficManagementFeatureSpec) GetEnabled() *protobuf.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *TrafficManagementFeatureSpec) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *TrafficManagementFeatureSpec) GetClusterDomain() string {
	if m != nil {
		return m.ClusterDomain
	}
	return ""
}

func (m *TrafficManagementFeatureSpec) GetPilot() *PilotComponentSpec {
	if m != nil {
		return m.Pilot
	}
	return nil
}

func (m *TrafficManagementFeatureSpec) GetProxy() *ProxyComponentSpec {
	if m != nil {
		return m.Proxy
	}
	return nil
}

func (m *TrafficManagementFeatureSpec) GetSidecarInjector() *SidecarInjectorComponentSpec {
	if m != nil {
		return m.SidecarInjector
	}
	return nil
}

// Configuration options for the policy and telemetry feature.
type PolicyTelemetryFeatureSpec struct {
	// If set, allows traffic in cases when the mixer policy service cannot be reached.
	PolicyCheckFailOpen *protobuf.BoolValue `protobuf:"bytes,10,opt,name=policy_check_fail_open,json=policyCheckFailOpen,proto3" json:"policy_check_fail_open,omitempty"`
	// Selects the outbound traffic policy mode.
	OutboundTrafficPolicyMode PolicyTelemetryFeatureSpec_OutboundPolicy `protobuf:"varint,11,opt,name=outbound_traffic_policy_mode,json=outboundTrafficPolicyMode,proto3,enum=v1alpha1.PolicyTelemetryFeatureSpec_OutboundPolicy" json:"outbound_traffic_policy_mode,omitempty"`
	Policy                    *PolicyComponentSpec                      `protobuf:"bytes,50,opt,name=policy,proto3" json:"policy,omitempty"`
	Telemetry                 *TelemetryComponentSpec                   `protobuf:"bytes,51,opt,name=telemetry,proto3" json:"telemetry,omitempty"`
	XXX_NoUnkeyedLiteral      struct{}                                  `json:"-"`
	XXX_unrecognized          []byte                                    `json:"-"`
	XXX_sizecache             int32                                     `json:"-"`
}

func (m *PolicyTelemetryFeatureSpec) Reset()         { *m = PolicyTelemetryFeatureSpec{} }
func (m *PolicyTelemetryFeatureSpec) String() string { return proto.CompactTextString(m) }
func (*PolicyTelemetryFeatureSpec) ProtoMessage()    {}
func (*PolicyTelemetryFeatureSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{3}
}
func (m *PolicyTelemetryFeatureSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicyTelemetryFeatureSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PolicyTelemetryFeatureSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PolicyTelemetryFeatureSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyTelemetryFeatureSpec.Merge(m, src)
}
func (m *PolicyTelemetryFeatureSpec) XXX_Size() int {
	return m.Size()
}
func (m *PolicyTelemetryFeatureSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyTelemetryFeatureSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyTelemetryFeatureSpec proto.InternalMessageInfo

func (m *PolicyTelemetryFeatureSpec) GetPolicyCheckFailOpen() *protobuf.BoolValue {
	if m != nil {
		return m.PolicyCheckFailOpen
	}
	return nil
}

func (m *PolicyTelemetryFeatureSpec) GetOutboundTrafficPolicyMode() PolicyTelemetryFeatureSpec_OutboundPolicy {
	if m != nil {
		return m.OutboundTrafficPolicyMode
	}
	return PolicyTelemetryFeatureSpec_ALLOW_ANY
}

func (m *PolicyTelemetryFeatureSpec) GetPolicy() *PolicyComponentSpec {
	if m != nil {
		return m.Policy
	}
	return nil
}

func (m *PolicyTelemetryFeatureSpec) GetTelemetry() *TelemetryComponentSpec {
	if m != nil {
		return m.Telemetry
	}
	return nil
}

// Configuration options for security feature.
type SecurityFeatureSpec struct {
	// Selects whether security feature is installed. Must be set for any sub-component to be installed.
	Enabled *protobuf.BoolValue `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Namespace that security components are installed into.
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Enables MTLS for control plane.
	// Will result in delays starting the pods while secrets are propagated, not recommended for tests.
	ControlPlaneMtls *protobuf.BoolValue `protobuf:"bytes,13,opt,name=control_plane_mtls,json=controlPlaneMtls,proto3" json:"control_plane_mtls,omitempty"`
	// Enables MTLS for service to service traffic.
	DataPlaneMtls        *protobuf.BoolValue       `protobuf:"bytes,14,opt,name=data_plane_mtls,json=dataPlaneMtls,proto3" json:"data_plane_mtls,omitempty"`
	TrustDomain          string                    `protobuf:"bytes,15,opt,name=trust_domain,json=trustDomain,proto3" json:"trust_domain,omitempty"`
	Citadel              *CitadelComponentSpec     `protobuf:"bytes,20,opt,name=citadel,proto3" json:"citadel,omitempty"`
	CertManager          *CertManagerComponentSpec `protobuf:"bytes,21,opt,name=cert_manager,json=certManager,proto3" json:"cert_manager,omitempty"`
	NodeAgent            *NodeAgentComponentSpec   `protobuf:"bytes,22,opt,name=node_agent,json=nodeAgent,proto3" json:"node_agent,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *SecurityFeatureSpec) Reset()         { *m = SecurityFeatureSpec{} }
func (m *SecurityFeatureSpec) String() string { return proto.CompactTextString(m) }
func (*SecurityFeatureSpec) ProtoMessage()    {}
func (*SecurityFeatureSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{4}
}
func (m *SecurityFeatureSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityFeatureSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityFeatureSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityFeatureSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityFeatureSpec.Merge(m, src)
}
func (m *SecurityFeatureSpec) XXX_Size() int {
	return m.Size()
}
func (m *SecurityFeatureSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityFeatureSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityFeatureSpec proto.InternalMessageInfo

func (m *SecurityFeatureSpec) GetEnabled() *protobuf.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *SecurityFeatureSpec) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *SecurityFeatureSpec) GetControlPlaneMtls() *protobuf.BoolValue {
	if m != nil {
		return m.ControlPlaneMtls
	}
	return nil
}

func (m *SecurityFeatureSpec) GetDataPlaneMtls() *protobuf.BoolValue {
	if m != nil {
		return m.DataPlaneMtls
	}
	return nil
}

func (m *SecurityFeatureSpec) GetTrustDomain() string {
	if m != nil {
		return m.TrustDomain
	}
	return ""
}

func (m *SecurityFeatureSpec) GetCitadel() *CitadelComponentSpec {
	if m != nil {
		return m.Citadel
	}
	return nil
}

func (m *SecurityFeatureSpec) GetCertManager() *CertManagerComponentSpec {
	if m != nil {
		return m.CertManager
	}
	return nil
}

func (m *SecurityFeatureSpec) GetNodeAgent() *NodeAgentComponentSpec {
	if m != nil {
		return m.NodeAgent
	}
	return nil
}

// Configuration options for configuration management feature.
type ConfigManagementFeatureSpec struct {
	Galley               *GalleyComponentSpec `protobuf:"bytes,1,opt,name=galley,proto3" json:"galley,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ConfigManagementFeatureSpec) Reset()         { *m = ConfigManagementFeatureSpec{} }
func (m *ConfigManagementFeatureSpec) String() string { return proto.CompactTextString(m) }
func (*ConfigManagementFeatureSpec) ProtoMessage()    {}
func (*ConfigManagementFeatureSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{5}
}
func (m *ConfigManagementFeatureSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigManagementFeatureSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigManagementFeatureSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigManagementFeatureSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigManagementFeatureSpec.Merge(m, src)
}
func (m *ConfigManagementFeatureSpec) XXX_Size() int {
	return m.Size()
}
func (m *ConfigManagementFeatureSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigManagementFeatureSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigManagementFeatureSpec proto.InternalMessageInfo

func (m *ConfigManagementFeatureSpec) GetGalley() *GalleyComponentSpec {
	if m != nil {
		return m.Galley
	}
	return nil
}

// Configuration options for the pilot component.
type PilotComponentSpec struct {
	Common *CommonComponentSpec `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	// Enables sidecar in the pilot pod.
	Sidecar              *protobuf.BoolValue `protobuf:"bytes,10,opt,name=sidecar,proto3" json:"sidecar,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *PilotComponentSpec) Reset()         { *m = PilotComponentSpec{} }
func (m *PilotComponentSpec) String() string { return proto.CompactTextString(m) }
func (*PilotComponentSpec) ProtoMessage()    {}
func (*PilotComponentSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{6}
}
func (m *PilotComponentSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PilotComponentSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PilotComponentSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PilotComponentSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PilotComponentSpec.Merge(m, src)
}
func (m *PilotComponentSpec) XXX_Size() int {
	return m.Size()
}
func (m *PilotComponentSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PilotComponentSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PilotComponentSpec proto.InternalMessageInfo

func (m *PilotComponentSpec) GetCommon() *CommonComponentSpec {
	if m != nil {
		return m.Common
	}
	return nil
}

func (m *PilotComponentSpec) GetSidecar() *protobuf.BoolValue {
	if m != nil {
		return m.Sidecar
	}
	return nil
}

// Configuration options for the proxy.
type ProxyComponentSpec struct {
	Common               *CommonComponentSpec `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ProxyComponentSpec) Reset()         { *m = ProxyComponentSpec{} }
func (m *ProxyComponentSpec) String() string { return proto.CompactTextString(m) }
func (*ProxyComponentSpec) ProtoMessage()    {}
func (*ProxyComponentSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{7}
}
func (m *ProxyComponentSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProxyComponentSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProxyComponentSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProxyComponentSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProxyComponentSpec.Merge(m, src)
}
func (m *ProxyComponentSpec) XXX_Size() int {
	return m.Size()
}
func (m *ProxyComponentSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ProxyComponentSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ProxyComponentSpec proto.InternalMessageInfo

func (m *ProxyComponentSpec) GetCommon() *CommonComponentSpec {
	if m != nil {
		return m.Common
	}
	return nil
}

// Configuration options for the sidecar injector component.
type SidecarInjectorComponentSpec struct {
	Common *CommonComponentSpec `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	// Selects whether auto-injection is enabled in namespaces by default.
	EnableNamespacesByDefault *protobuf.BoolValue `protobuf:"bytes,10,opt,name=enable_namespaces_by_default,json=enableNamespacesByDefault,proto3" json:"enable_namespaces_by_default,omitempty"`
	XXX_NoUnkeyedLiteral      struct{}            `json:"-"`
	XXX_unrecognized          []byte              `json:"-"`
	XXX_sizecache             int32               `json:"-"`
}

func (m *SidecarInjectorComponentSpec) Reset()         { *m = SidecarInjectorComponentSpec{} }
func (m *SidecarInjectorComponentSpec) String() string { return proto.CompactTextString(m) }
func (*SidecarInjectorComponentSpec) ProtoMessage()    {}
func (*SidecarInjectorComponentSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{8}
}
func (m *SidecarInjectorComponentSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SidecarInjectorComponentSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SidecarInjectorComponentSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SidecarInjectorComponentSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SidecarInjectorComponentSpec.Merge(m, src)
}
func (m *SidecarInjectorComponentSpec) XXX_Size() int {
	return m.Size()
}
func (m *SidecarInjectorComponentSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SidecarInjectorComponentSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SidecarInjectorComponentSpec proto.InternalMessageInfo

func (m *SidecarInjectorComponentSpec) GetCommon() *CommonComponentSpec {
	if m != nil {
		return m.Common
	}
	return nil
}

func (m *SidecarInjectorComponentSpec) GetEnableNamespacesByDefault() *protobuf.BoolValue {
	if m != nil {
		return m.EnableNamespacesByDefault
	}
	return nil
}

// Configuration options for the policy enforcement component.
type PolicyComponentSpec struct {
	Common               *CommonComponentSpec `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *PolicyComponentSpec) Reset()         { *m = PolicyComponentSpec{} }
func (m *PolicyComponentSpec) String() string { return proto.CompactTextString(m) }
func (*PolicyComponentSpec) ProtoMessage()    {}
func (*PolicyComponentSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{9}
}
func (m *PolicyComponentSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicyComponentSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PolicyComponentSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PolicyComponentSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyComponentSpec.Merge(m, src)
}
func (m *PolicyComponentSpec) XXX_Size() int {
	return m.Size()
}
func (m *PolicyComponentSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyComponentSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyComponentSpec proto.InternalMessageInfo

func (m *PolicyComponentSpec) GetCommon() *CommonComponentSpec {
	if m != nil {
		return m.Common
	}
	return nil
}

// Configuration options for the telemetry component.
type TelemetryComponentSpec struct {
	Common               *CommonComponentSpec `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *TelemetryComponentSpec) Reset()         { *m = TelemetryComponentSpec{} }
func (m *TelemetryComponentSpec) String() string { return proto.CompactTextString(m) }
func (*TelemetryComponentSpec) ProtoMessage()    {}
func (*TelemetryComponentSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{10}
}
func (m *TelemetryComponentSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TelemetryComponentSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TelemetryComponentSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TelemetryComponentSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TelemetryComponentSpec.Merge(m, src)
}
func (m *TelemetryComponentSpec) XXX_Size() int {
	return m.Size()
}
func (m *TelemetryComponentSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TelemetryComponentSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TelemetryComponentSpec proto.InternalMessageInfo

func (m *TelemetryComponentSpec) GetCommon() *CommonComponentSpec {
	if m != nil {
		return m.Common
	}
	return nil
}

// Configuration options for Citadel component.
type CitadelComponentSpec struct {
	Common               *CommonComponentSpec `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	SelfSigned           bool                 `protobuf:"varint,11,opt,name=self_signed,json=selfSigned,proto3" json:"self_signed,omitempty"`
	CreateMeshPolicy     bool                 `protobuf:"varint,12,opt,name=create_mesh_policy,json=createMeshPolicy,proto3" json:"create_mesh_policy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *CitadelComponentSpec) Reset()         { *m = CitadelComponentSpec{} }
func (m *CitadelComponentSpec) String() string { return proto.CompactTextString(m) }
func (*CitadelComponentSpec) ProtoMessage()    {}
func (*CitadelComponentSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{11}
}
func (m *CitadelComponentSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CitadelComponentSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CitadelComponentSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CitadelComponentSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CitadelComponentSpec.Merge(m, src)
}
func (m *CitadelComponentSpec) XXX_Size() int {
	return m.Size()
}
func (m *CitadelComponentSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CitadelComponentSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CitadelComponentSpec proto.InternalMessageInfo

func (m *CitadelComponentSpec) GetCommon() *CommonComponentSpec {
	if m != nil {
		return m.Common
	}
	return nil
}

func (m *CitadelComponentSpec) GetSelfSigned() bool {
	if m != nil {
		return m.SelfSigned
	}
	return false
}

func (m *CitadelComponentSpec) GetCreateMeshPolicy() bool {
	if m != nil {
		return m.CreateMeshPolicy
	}
	return false
}

// Configuration options for certificate manager component.
type CertManagerComponentSpec struct {
	Common               *CommonComponentSpec `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *CertManagerComponentSpec) Reset()         { *m = CertManagerComponentSpec{} }
func (m *CertManagerComponentSpec) String() string { return proto.CompactTextString(m) }
func (*CertManagerComponentSpec) ProtoMessage()    {}
func (*CertManagerComponentSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{12}
}
func (m *CertManagerComponentSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertManagerComponentSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CertManagerComponentSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CertManagerComponentSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertManagerComponentSpec.Merge(m, src)
}
func (m *CertManagerComponentSpec) XXX_Size() int {
	return m.Size()
}
func (m *CertManagerComponentSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CertManagerComponentSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CertManagerComponentSpec proto.InternalMessageInfo

func (m *CertManagerComponentSpec) GetCommon() *CommonComponentSpec {
	if m != nil {
		return m.Common
	}
	return nil
}

// Configuration options for node agent component.
type NodeAgentComponentSpec struct {
	Common               *CommonComponentSpec `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *NodeAgentComponentSpec) Reset()         { *m = NodeAgentComponentSpec{} }
func (m *NodeAgentComponentSpec) String() string { return proto.CompactTextString(m) }
func (*NodeAgentComponentSpec) ProtoMessage()    {}
func (*NodeAgentComponentSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{13}
}
func (m *NodeAgentComponentSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeAgentComponentSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeAgentComponentSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeAgentComponentSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeAgentComponentSpec.Merge(m, src)
}
func (m *NodeAgentComponentSpec) XXX_Size() int {
	return m.Size()
}
func (m *NodeAgentComponentSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeAgentComponentSpec.DiscardUnknown(m)
}

var xxx_messageInfo_NodeAgentComponentSpec proto.InternalMessageInfo

func (m *NodeAgentComponentSpec) GetCommon() *CommonComponentSpec {
	if m != nil {
		return m.Common
	}
	return nil
}

// Configuration options for node agent component.
type GalleyComponentSpec struct {
	Common               *CommonComponentSpec `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *GalleyComponentSpec) Reset()         { *m = GalleyComponentSpec{} }
func (m *GalleyComponentSpec) String() string { return proto.CompactTextString(m) }
func (*GalleyComponentSpec) ProtoMessage()    {}
func (*GalleyComponentSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{14}
}
func (m *GalleyComponentSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GalleyComponentSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GalleyComponentSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GalleyComponentSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GalleyComponentSpec.Merge(m, src)
}
func (m *GalleyComponentSpec) XXX_Size() int {
	return m.Size()
}
func (m *GalleyComponentSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_GalleyComponentSpec.DiscardUnknown(m)
}

var xxx_messageInfo_GalleyComponentSpec proto.InternalMessageInfo

func (m *GalleyComponentSpec) GetCommon() *CommonComponentSpec {
	if m != nil {
		return m.Common
	}
	return nil
}

// Configuration common to all components.
type CommonComponentSpec struct {
	// Selects whether policy enforcement is installed.
	// Q. is this enough to cover both mixer.policy.enabled and disablePolicyChecks?
	Enabled *protobuf.BoolValue `protobuf:"bytes,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Namespace that all resources for this feature are installed into.
	Namespace string                       `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Debug     CommonComponentSpec_LogLevel `protobuf:"varint,3,opt,name=debug,proto3,enum=v1alpha1.CommonComponentSpec_LogLevel" json:"debug,omitempty"`
	// Kubernetes resource spec.
	K8S                  *KubernetesResourcesSpec `protobuf:"bytes,80,opt,name=k8s,proto3" json:"k8s,omitempty"`
	ValuesOverrides      map[string]interface{}   `protobuf:"bytes,6,opt,name=data" json:"valuesOverrides,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *CommonComponentSpec) Reset()         { *m = CommonComponentSpec{} }
func (m *CommonComponentSpec) String() string { return proto.CompactTextString(m) }
func (*CommonComponentSpec) ProtoMessage()    {}
func (*CommonComponentSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{15}
}
func (m *CommonComponentSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommonComponentSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommonComponentSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommonComponentSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommonComponentSpec.Merge(m, src)
}
func (m *CommonComponentSpec) XXX_Size() int {
	return m.Size()
}
func (m *CommonComponentSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CommonComponentSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CommonComponentSpec proto.InternalMessageInfo

func (m *CommonComponentSpec) GetEnabled() *protobuf.BoolValue {
	if m != nil {
		return m.Enabled
	}
	return nil
}

func (m *CommonComponentSpec) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *CommonComponentSpec) GetDebug() CommonComponentSpec_LogLevel {
	if m != nil {
		return m.Debug
	}
	return CommonComponentSpec_NONE
}

func (m *CommonComponentSpec) GetK8S() *KubernetesResourcesSpec {
	if m != nil {
		return m.K8S
	}
	return nil
}

type CommonComponentSpec_UpdateSpec struct {
	Old                  string   `protobuf:"bytes,1,opt,name=old,proto3" json:"old,omitempty"`
	New                  string   `protobuf:"bytes,2,opt,name=new,proto3" json:"new,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommonComponentSpec_UpdateSpec) Reset()         { *m = CommonComponentSpec_UpdateSpec{} }
func (m *CommonComponentSpec_UpdateSpec) String() string { return proto.CompactTextString(m) }
func (*CommonComponentSpec_UpdateSpec) ProtoMessage()    {}
func (*CommonComponentSpec_UpdateSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{15, 0}
}
func (m *CommonComponentSpec_UpdateSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommonComponentSpec_UpdateSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommonComponentSpec_UpdateSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommonComponentSpec_UpdateSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommonComponentSpec_UpdateSpec.Merge(m, src)
}
func (m *CommonComponentSpec_UpdateSpec) XXX_Size() int {
	return m.Size()
}
func (m *CommonComponentSpec_UpdateSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CommonComponentSpec_UpdateSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CommonComponentSpec_UpdateSpec proto.InternalMessageInfo

func (m *CommonComponentSpec_UpdateSpec) GetOld() string {
	if m != nil {
		return m.Old
	}
	return ""
}

func (m *CommonComponentSpec_UpdateSpec) GetNew() string {
	if m != nil {
		return m.New
	}
	return ""
}

// KubernetesResourcesConfig is a common set of k8s resource configs for components.
type KubernetesResourcesSpec struct {
	// k8s resources settings.
	// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#resource-requests-and-limits-of-pod-and-container
	Resources *Resources `protobuf:"bytes,1,opt,name=resources,proto3" json:"resources,omitempty"`
	// k8s readinessProbe settings.
	// https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/
	ReadinessProbe *v1.Probe `protobuf:"bytes,2,opt,name=readiness_probe,json=readinessProbe,proto3" json:"readiness_probe,omitempty"`
	// k8s Deployment replicas setting.
	// https://kubernetes.io/docs/concepts/workloads/controllers/deployment/
	ReplicaCount uint32 `protobuf:"varint,3,opt,name=replica_count,json=replicaCount,proto3" json:"replica_count,omitempty"`
	// k8s HorizontalPodAutoscaler settings.
	// https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/
	HpaSpec *v11.HorizontalPodAutoscalerSpec `protobuf:"bytes,4,opt,name=hpa_spec,json=hpaSpec,proto3" json:"hpa_spec,omitempty"`
	// k8s DefaultPodDisruptionBudgetConfig settings.
	// https://kubernetes.io/docs/concepts/workloads/pods/disruptions/#how-disruption-budgets-work
	PodDisruptionBudget *PodDisruptionBudgetSpec `protobuf:"bytes,5,opt,name=pod_disruption_budget,json=podDisruptionBudget,proto3" json:"pod_disruption_budget,omitempty"`
	// k8s pod annotations.
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
	PodAnnotations map[string]string `protobuf:"bytes,6,rep,name=pod_annotations,json=podAnnotations,proto3" json:"pod_annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// k8s nodeSelector.
	// https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
	NodeSelector map[string]string                     `protobuf:"bytes,7,rep,name=node_selector,json=nodeSelector,proto3" json:"node_selector,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	NodeAffinity *KubernetesResourcesSpec_NodeAffinity `protobuf:"bytes,8,opt,name=node_affinity,json=nodeAffinity,proto3" json:"node_affinity,omitempty"`
	// k8s imagePullPolicy.
	// https://kubernetes.io/docs/concepts/containers/images/
	ImagePullPolicy string `protobuf:"bytes,9,opt,name=image_pull_policy,json=imagePullPolicy,proto3" json:"image_pull_policy,omitempty"`
	// k8s priority_class_name. Default for all resources unless overridden.
	// https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass
	PriorityClassName string `protobuf:"bytes,10,opt,name=priority_class_name,json=priorityClassName,proto3" json:"priority_class_name,omitempty"`
	// Kustomize style overrides for k8s resources in rendered manifests.
	Overlays             []*K8SObjectOverlay `protobuf:"bytes,100,rep,name=overlays,proto3" json:"overlays,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *KubernetesResourcesSpec) Reset()         { *m = KubernetesResourcesSpec{} }
func (m *KubernetesResourcesSpec) String() string { return proto.CompactTextString(m) }
func (*KubernetesResourcesSpec) ProtoMessage()    {}
func (*KubernetesResourcesSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{16}
}
func (m *KubernetesResourcesSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubernetesResourcesSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubernetesResourcesSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubernetesResourcesSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesResourcesSpec.Merge(m, src)
}
func (m *KubernetesResourcesSpec) XXX_Size() int {
	return m.Size()
}
func (m *KubernetesResourcesSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesResourcesSpec.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesResourcesSpec proto.InternalMessageInfo

func (m *KubernetesResourcesSpec) GetResources() *Resources {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *KubernetesResourcesSpec) GetReadinessProbe() *v1.Probe {
	if m != nil {
		return m.ReadinessProbe
	}
	return nil
}

func (m *KubernetesResourcesSpec) GetReplicaCount() uint32 {
	if m != nil {
		return m.ReplicaCount
	}
	return 0
}

func (m *KubernetesResourcesSpec) GetHpaSpec() *v11.HorizontalPodAutoscalerSpec {
	if m != nil {
		return m.HpaSpec
	}
	return nil
}

func (m *KubernetesResourcesSpec) GetPodDisruptionBudget() *PodDisruptionBudgetSpec {
	if m != nil {
		return m.PodDisruptionBudget
	}
	return nil
}

func (m *KubernetesResourcesSpec) GetPodAnnotations() map[string]string {
	if m != nil {
		return m.PodAnnotations
	}
	return nil
}

func (m *KubernetesResourcesSpec) GetNodeSelector() map[string]string {
	if m != nil {
		return m.NodeSelector
	}
	return nil
}

func (m *KubernetesResourcesSpec) GetNodeAffinity() *KubernetesResourcesSpec_NodeAffinity {
	if m != nil {
		return m.NodeAffinity
	}
	return nil
}

func (m *KubernetesResourcesSpec) GetImagePullPolicy() string {
	if m != nil {
		return m.ImagePullPolicy
	}
	return ""
}

func (m *KubernetesResourcesSpec) GetPriorityClassName() string {
	if m != nil {
		return m.PriorityClassName
	}
	return ""
}

func (m *KubernetesResourcesSpec) GetOverlays() []*K8SObjectOverlay {
	if m != nil {
		return m.Overlays
	}
	return nil
}

// k8s node affinity.
// https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
type KubernetesResourcesSpec_NodeAffinity struct {
	ArchAmd64            uint32   `protobuf:"varint,1,opt,name=arch_amd64,json=archAmd64,proto3" json:"arch_amd64,omitempty"`
	ArchS390X            uint32   `protobuf:"varint,2,opt,name=arch_s390x,json=archS390x,proto3" json:"arch_s390x,omitempty"`
	ArchPpc64Le          uint32   `protobuf:"varint,3,opt,name=arch_ppc64le,json=archPpc64le,proto3" json:"arch_ppc64le,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KubernetesResourcesSpec_NodeAffinity) Reset()         { *m = KubernetesResourcesSpec_NodeAffinity{} }
func (m *KubernetesResourcesSpec_NodeAffinity) String() string { return proto.CompactTextString(m) }
func (*KubernetesResourcesSpec_NodeAffinity) ProtoMessage()    {}
func (*KubernetesResourcesSpec_NodeAffinity) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{16, 2}
}
func (m *KubernetesResourcesSpec_NodeAffinity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubernetesResourcesSpec_NodeAffinity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubernetesResourcesSpec_NodeAffinity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubernetesResourcesSpec_NodeAffinity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesResourcesSpec_NodeAffinity.Merge(m, src)
}
func (m *KubernetesResourcesSpec_NodeAffinity) XXX_Size() int {
	return m.Size()
}
func (m *KubernetesResourcesSpec_NodeAffinity) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesResourcesSpec_NodeAffinity.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesResourcesSpec_NodeAffinity proto.InternalMessageInfo

func (m *KubernetesResourcesSpec_NodeAffinity) GetArchAmd64() uint32 {
	if m != nil {
		return m.ArchAmd64
	}
	return 0
}

func (m *KubernetesResourcesSpec_NodeAffinity) GetArchS390X() uint32 {
	if m != nil {
		return m.ArchS390X
	}
	return 0
}

func (m *KubernetesResourcesSpec_NodeAffinity) GetArchPpc64Le() uint32 {
	if m != nil {
		return m.ArchPpc64Le
	}
	return 0
}

// Configuration options for ingress gateways.
type IngressGatewaySpec struct {
	// Common gateway configuration.
	Gateway      *GatewayConfig                 `protobuf:"bytes,10,opt,name=gateway,proto3" json:"gateway,omitempty"`
	IngressType  IngressGatewaySpec_IngressType `protobuf:"varint,11,opt,name=ingress_type,json=ingressType,proto3,enum=v1alpha1.IngressGatewaySpec_IngressType" json:"ingress_type,omitempty"`
	LoadBalancer *LoadBalancerConfig            `protobuf:"bytes,13,opt,name=load_balancer,json=loadBalancer,proto3" json:"load_balancer,omitempty"`
	// If true, ingress gateway fetches credentials from SDS server to handle TLS connections.
	SdsEnabled            *protobuf.BoolValue                      `protobuf:"bytes,16,opt,name=sds_enabled,json=sdsEnabled,proto3" json:"sds_enabled,omitempty"`
	ExternalTrafficPolicy IngressGatewaySpec_ExternalTrafficPolicy `protobuf:"varint,17,opt,name=externalTrafficPolicy,proto3,enum=v1alpha1.IngressGatewaySpec_ExternalTrafficPolicy" json:"externalTrafficPolicy,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}                                 `json:"-"`
	XXX_unrecognized      []byte                                   `json:"-"`
	XXX_sizecache         int32                                    `json:"-"`
}

func (m *IngressGatewaySpec) Reset()         { *m = IngressGatewaySpec{} }
func (m *IngressGatewaySpec) String() string { return proto.CompactTextString(m) }
func (*IngressGatewaySpec) ProtoMessage()    {}
func (*IngressGatewaySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{17}
}
func (m *IngressGatewaySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngressGatewaySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngressGatewaySpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IngressGatewaySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngressGatewaySpec.Merge(m, src)
}
func (m *IngressGatewaySpec) XXX_Size() int {
	return m.Size()
}
func (m *IngressGatewaySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_IngressGatewaySpec.DiscardUnknown(m)
}

var xxx_messageInfo_IngressGatewaySpec proto.InternalMessageInfo

func (m *IngressGatewaySpec) GetGateway() *GatewayConfig {
	if m != nil {
		return m.Gateway
	}
	return nil
}

func (m *IngressGatewaySpec) GetIngressType() IngressGatewaySpec_IngressType {
	if m != nil {
		return m.IngressType
	}
	return IngressGatewaySpec_ISTIO
}

func (m *IngressGatewaySpec) GetLoadBalancer() *LoadBalancerConfig {
	if m != nil {
		return m.LoadBalancer
	}
	return nil
}

func (m *IngressGatewaySpec) GetSdsEnabled() *protobuf.BoolValue {
	if m != nil {
		return m.SdsEnabled
	}
	return nil
}

func (m *IngressGatewaySpec) GetExternalTrafficPolicy() IngressGatewaySpec_ExternalTrafficPolicy {
	if m != nil {
		return m.ExternalTrafficPolicy
	}
	return IngressGatewaySpec_NONE
}

// Configuration options for egress gateways.
type EgressGatewaySpec struct {
	// Common gateway configuration.
	Gateway              *GatewayConfig `protobuf:"bytes,10,opt,name=gateway,proto3" json:"gateway,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *EgressGatewaySpec) Reset()         { *m = EgressGatewaySpec{} }
func (m *EgressGatewaySpec) String() string { return proto.CompactTextString(m) }
func (*EgressGatewaySpec) ProtoMessage()    {}
func (*EgressGatewaySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{18}
}
func (m *EgressGatewaySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EgressGatewaySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EgressGatewaySpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EgressGatewaySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EgressGatewaySpec.Merge(m, src)
}
func (m *EgressGatewaySpec) XXX_Size() int {
	return m.Size()
}
func (m *EgressGatewaySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_EgressGatewaySpec.DiscardUnknown(m)
}

var xxx_messageInfo_EgressGatewaySpec proto.InternalMessageInfo

func (m *EgressGatewaySpec) GetGateway() *GatewayConfig {
	if m != nil {
		return m.Gateway
	}
	return nil
}

// Configuration options for internal load balancer gateways.
type LoadBalancingGatewayConfig struct {
	// Common gateway configuration.
	Gateway *GatewayConfig `protobuf:"bytes,10,opt,name=gateway,proto3" json:"gateway,omitempty"`
	// Load balancer config.
	LoadBalancer         *LoadBalancerConfig `protobuf:"bytes,11,opt,name=load_balancer,json=loadBalancer,proto3" json:"load_balancer,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *LoadBalancingGatewayConfig) Reset()         { *m = LoadBalancingGatewayConfig{} }
func (m *LoadBalancingGatewayConfig) String() string { return proto.CompactTextString(m) }
func (*LoadBalancingGatewayConfig) ProtoMessage()    {}
func (*LoadBalancingGatewayConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{19}
}
func (m *LoadBalancingGatewayConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadBalancingGatewayConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoadBalancingGatewayConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoadBalancingGatewayConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadBalancingGatewayConfig.Merge(m, src)
}
func (m *LoadBalancingGatewayConfig) XXX_Size() int {
	return m.Size()
}
func (m *LoadBalancingGatewayConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadBalancingGatewayConfig.DiscardUnknown(m)
}

var xxx_messageInfo_LoadBalancingGatewayConfig proto.InternalMessageInfo

func (m *LoadBalancingGatewayConfig) GetGateway() *GatewayConfig {
	if m != nil {
		return m.Gateway
	}
	return nil
}

func (m *LoadBalancingGatewayConfig) GetLoadBalancer() *LoadBalancerConfig {
	if m != nil {
		return m.LoadBalancer
	}
	return nil
}

// Common config for all gateway types.
type GatewayConfig struct {
	Common *CommonComponentSpec `protobuf:"bytes,1,opt,name=common,proto3" json:"common,omitempty"`
	// NodePort, ClusterIP or LoadBalancer.
	Type                 string   `protobuf:"bytes,10,opt,name=type,proto3" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GatewayConfig) Reset()         { *m = GatewayConfig{} }
func (m *GatewayConfig) String() string { return proto.CompactTextString(m) }
func (*GatewayConfig) ProtoMessage()    {}
func (*GatewayConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{20}
}
func (m *GatewayConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GatewayConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GatewayConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GatewayConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GatewayConfig.Merge(m, src)
}
func (m *GatewayConfig) XXX_Size() int {
	return m.Size()
}
func (m *GatewayConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GatewayConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GatewayConfig proto.InternalMessageInfo

func (m *GatewayConfig) GetCommon() *CommonComponentSpec {
	if m != nil {
		return m.Common
	}
	return nil
}

func (m *GatewayConfig) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

// Configuration options for internal load balancer gateways.
// Subset of k8s.io/api/core/v1 ServiceSpec.
type LoadBalancerConfig struct {
	// The list of ports that are exposed by this service.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	Ports []*v1.ServicePort `protobuf:"bytes,1,rep,name=ports,proto3" json:"ports,omitempty"`
	// clusterIP is the IP address of the service and is usually assigned
	// randomly by the master. If an address is specified manually and is not in
	// use by others, it will be allocated to the service; otherwise, creation
	// of the service will fail. This field can not be changed through updates.
	// Valid values are "None", empty string (""), or a valid IP address. "None"
	// can be specified for headless services when proxying is not required.
	// Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if
	// type is ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	// +optional
	ClusterIP string `protobuf:"bytes,3,opt,name=clusterIP,proto3" json:"clusterIP,omitempty"`
	// externalIPs is a list of IP addresses for which nodes in the cluster
	// will also accept traffic for this service.  These IPs are not managed by
	// Kubernetes.  The user is responsible for ensuring that traffic arrives
	// at a node with this IP.  A common example is external load-balancers
	// that are not part of the Kubernetes system.
	// +optional
	ExternalIPs []string `protobuf:"bytes,5,rep,name=externalIPs,proto3" json:"externalIPs,omitempty"`
	// Supports "ClientIP" and "None". Used to maintain session affinity.
	// Enable client IP based session affinity.
	// Must be ClientIP or None.
	// Defaults to None.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	// +optional
	SessionAffinity string `protobuf:"bytes,7,opt,name=sessionAffinity,proto3" json:"sessionAffinity,omitempty"`
	// LoadBalancer will get created with the IP specified in this field.
	// This feature depends on whether the underlying cloud-provider supports specifying
	// the loadBalancerIP when a load balancer is created.
	// This field will be ignored if the cloud-provider does not support the feature.
	// +optional
	LoadBalancerIP string `protobuf:"bytes,8,opt,name=loadBalancerIP,proto3" json:"loadBalancerIP,omitempty"`
	// If specified and supported by the platform, this will restrict traffic through the cloud-provider
	// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
	// cloud-provider does not support the feature."
	// More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/
	// +optional
	LoadBalancerSourceRanges []string `protobuf:"bytes,9,rep,name=loadBalancerSourceRanges,proto3" json:"loadBalancerSourceRanges,omitempty"`
	// externalName is the external reference that kubedns or equivalent will
	// return as a CNAME record for this service. No proxying will be involved.
	// Must be a valid RFC-1123 hostname (https://tools.ietf.org/html/rfc1123)
	// and requires Type to be ExternalName.
	// +optional
	ExternalName string `protobuf:"bytes,10,opt,name=externalName,proto3" json:"externalName,omitempty"`
	// externalTrafficPolicy denotes if this Service desires to route external
	// traffic to node-local or cluster-wide endpoints. "Local" preserves the
	// client source IP and avoids a second hop for LoadBalancer and Nodeport
	// type services, but risks potentially imbalanced traffic spreading.
	// "Cluster" obscures the client source IP and may cause a second hop to
	// another node, but should have good overall load-spreading.
	// +optional
	ExternalTrafficPolicy string   `protobuf:"bytes,11,opt,name=externalTrafficPolicy,proto3" json:"externalTrafficPolicy,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *LoadBalancerConfig) Reset()         { *m = LoadBalancerConfig{} }
func (m *LoadBalancerConfig) String() string { return proto.CompactTextString(m) }
func (*LoadBalancerConfig) ProtoMessage()    {}
func (*LoadBalancerConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{21}
}
func (m *LoadBalancerConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadBalancerConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoadBalancerConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoadBalancerConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadBalancerConfig.Merge(m, src)
}
func (m *LoadBalancerConfig) XXX_Size() int {
	return m.Size()
}
func (m *LoadBalancerConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadBalancerConfig.DiscardUnknown(m)
}

var xxx_messageInfo_LoadBalancerConfig proto.InternalMessageInfo

func (m *LoadBalancerConfig) GetPorts() []*v1.ServicePort {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *LoadBalancerConfig) GetClusterIP() string {
	if m != nil {
		return m.ClusterIP
	}
	return ""
}

func (m *LoadBalancerConfig) GetExternalIPs() []string {
	if m != nil {
		return m.ExternalIPs
	}
	return nil
}

func (m *LoadBalancerConfig) GetSessionAffinity() string {
	if m != nil {
		return m.SessionAffinity
	}
	return ""
}

func (m *LoadBalancerConfig) GetLoadBalancerIP() string {
	if m != nil {
		return m.LoadBalancerIP
	}
	return ""
}

func (m *LoadBalancerConfig) GetLoadBalancerSourceRanges() []string {
	if m != nil {
		return m.LoadBalancerSourceRanges
	}
	return nil
}

func (m *LoadBalancerConfig) GetExternalName() string {
	if m != nil {
		return m.ExternalName
	}
	return ""
}

func (m *LoadBalancerConfig) GetExternalTrafficPolicy() string {
	if m != nil {
		return m.ExternalTrafficPolicy
	}
	return ""
}

// OperatorConfig defines a config used to install an external operator.
type OperatorSpec struct {
	// manifest_path is the URL for the operator install manifest.
	ManifestPath string `protobuf:"bytes,1,opt,name=manifest_path,json=manifestPath,proto3" json:"manifest_path,omitempty"`
	// namespace is the namespace the operator manifest and CR are installed into.
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// spec is the initial CR for the operator.
	Spec                 *K8SObjectOverlay `protobuf:"bytes,100,opt,name=spec,proto3" json:"spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *OperatorSpec) Reset()         { *m = OperatorSpec{} }
func (m *OperatorSpec) String() string { return proto.CompactTextString(m) }
func (*OperatorSpec) ProtoMessage()    {}
func (*OperatorSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{22}
}
func (m *OperatorSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperatorSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperatorSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperatorSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperatorSpec.Merge(m, src)
}
func (m *OperatorSpec) XXX_Size() int {
	return m.Size()
}
func (m *OperatorSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_OperatorSpec.DiscardUnknown(m)
}

var xxx_messageInfo_OperatorSpec proto.InternalMessageInfo

func (m *OperatorSpec) GetManifestPath() string {
	if m != nil {
		return m.ManifestPath
	}
	return ""
}

func (m *OperatorSpec) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *OperatorSpec) GetSpec() *K8SObjectOverlay {
	if m != nil {
		return m.Spec
	}
	return nil
}

// Patch for an existing k8s resource.
type K8SObjectOverlay struct {
	// Resource API version.
	ApiVersion string `protobuf:"bytes,1,opt,name=api_version,json=apiVersion,proto3" json:"api_version,omitempty"`
	// Resource kind.
	Kind string `protobuf:"bytes,2,opt,name=kind,proto3" json:"kind,omitempty"`
	// Name of resource.
	// Namespace is always the component namespace.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// List of patches to apply to resource.
	Patches              []*K8SObjectOverlay_PathValue `protobuf:"bytes,4,rep,name=patches,proto3" json:"patches,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *K8SObjectOverlay) Reset()         { *m = K8SObjectOverlay{} }
func (m *K8SObjectOverlay) String() string { return proto.CompactTextString(m) }
func (*K8SObjectOverlay) ProtoMessage()    {}
func (*K8SObjectOverlay) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{23}
}
func (m *K8SObjectOverlay) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *K8SObjectOverlay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_K8SObjectOverlay.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *K8SObjectOverlay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_K8SObjectOverlay.Merge(m, src)
}
func (m *K8SObjectOverlay) XXX_Size() int {
	return m.Size()
}
func (m *K8SObjectOverlay) XXX_DiscardUnknown() {
	xxx_messageInfo_K8SObjectOverlay.DiscardUnknown(m)
}

var xxx_messageInfo_K8SObjectOverlay proto.InternalMessageInfo

func (m *K8SObjectOverlay) GetApiVersion() string {
	if m != nil {
		return m.ApiVersion
	}
	return ""
}

func (m *K8SObjectOverlay) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *K8SObjectOverlay) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *K8SObjectOverlay) GetPatches() []*K8SObjectOverlay_PathValue {
	if m != nil {
		return m.Patches
	}
	return nil
}

type K8SObjectOverlay_PathValue struct {
	// Path of the form a.b:c.e.:f
	// Where b:c is a list element selector of the form key:value and :f is a list selector of the form :value.
	// All path intermediate nodes must exist.
	Path                 string   `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Value                interface{} `protobuf:"bytes,4,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *K8SObjectOverlay_PathValue) Reset()         { *m = K8SObjectOverlay_PathValue{} }
func (m *K8SObjectOverlay_PathValue) String() string { return proto.CompactTextString(m) }
func (*K8SObjectOverlay_PathValue) ProtoMessage()    {}
func (*K8SObjectOverlay_PathValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{23, 0}
}
func (m *K8SObjectOverlay_PathValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *K8SObjectOverlay_PathValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_K8SObjectOverlay_PathValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *K8SObjectOverlay_PathValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_K8SObjectOverlay_PathValue.Merge(m, src)
}
func (m *K8SObjectOverlay_PathValue) XXX_Size() int {
	return m.Size()
}
func (m *K8SObjectOverlay_PathValue) XXX_DiscardUnknown() {
	xxx_messageInfo_K8SObjectOverlay_PathValue.DiscardUnknown(m)
}

var xxx_messageInfo_K8SObjectOverlay_PathValue proto.InternalMessageInfo

func (m *K8SObjectOverlay_PathValue) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// Observed state of IstioInstaller.
type InstallerStatus struct {
	TrafficManagement    *InstallerStatus_VersionStatus   `protobuf:"bytes,1,opt,name=traffic_management,json=trafficManagement,proto3" json:"traffic_management,omitempty"`
	PolicyTelemetry      *InstallerStatus_VersionStatus   `protobuf:"bytes,2,opt,name=policy_telemetry,json=policyTelemetry,proto3" json:"policy_telemetry,omitempty"`
	Security             *InstallerStatus_VersionStatus   `protobuf:"bytes,3,opt,name=security,proto3" json:"security,omitempty"`
	ConfigManagement     *InstallerStatus_VersionStatus   `protobuf:"bytes,4,opt,name=config_management,json=configManagement,proto3" json:"config_management,omitempty"`
	IngressGateway       []*InstallerStatus_VersionStatus `protobuf:"bytes,5,rep,name=ingress_gateway,json=ingressGateway,proto3" json:"ingress_gateway,omitempty"`
	EgressGateway        []*InstallerStatus_VersionStatus `protobuf:"bytes,6,rep,name=egress_gateway,json=egressGateway,proto3" json:"egress_gateway,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *InstallerStatus) Reset()         { *m = InstallerStatus{} }
func (m *InstallerStatus) String() string { return proto.CompactTextString(m) }
func (*InstallerStatus) ProtoMessage()    {}
func (*InstallerStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{24}
}
func (m *InstallerStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstallerStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstallerStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstallerStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallerStatus.Merge(m, src)
}
func (m *InstallerStatus) XXX_Size() int {
	return m.Size()
}
func (m *InstallerStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallerStatus.DiscardUnknown(m)
}

var xxx_messageInfo_InstallerStatus proto.InternalMessageInfo

func (m *InstallerStatus) GetTrafficManagement() *InstallerStatus_VersionStatus {
	if m != nil {
		return m.TrafficManagement
	}
	return nil
}

func (m *InstallerStatus) GetPolicyTelemetry() *InstallerStatus_VersionStatus {
	if m != nil {
		return m.PolicyTelemetry
	}
	return nil
}

func (m *InstallerStatus) GetSecurity() *InstallerStatus_VersionStatus {
	if m != nil {
		return m.Security
	}
	return nil
}

func (m *InstallerStatus) GetConfigManagement() *InstallerStatus_VersionStatus {
	if m != nil {
		return m.ConfigManagement
	}
	return nil
}

func (m *InstallerStatus) GetIngressGateway() []*InstallerStatus_VersionStatus {
	if m != nil {
		return m.IngressGateway
	}
	return nil
}

func (m *InstallerStatus) GetEgressGateway() []*InstallerStatus_VersionStatus {
	if m != nil {
		return m.EgressGateway
	}
	return nil
}

type InstallerStatus_VersionStatus struct {
	Version              string                 `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	Status               InstallerStatus_Status `protobuf:"varint,2,opt,name=status,proto3,enum=v1alpha1.InstallerStatus_Status" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *InstallerStatus_VersionStatus) Reset()         { *m = InstallerStatus_VersionStatus{} }
func (m *InstallerStatus_VersionStatus) String() string { return proto.CompactTextString(m) }
func (*InstallerStatus_VersionStatus) ProtoMessage()    {}
func (*InstallerStatus_VersionStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{24, 0}
}
func (m *InstallerStatus_VersionStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstallerStatus_VersionStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstallerStatus_VersionStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstallerStatus_VersionStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallerStatus_VersionStatus.Merge(m, src)
}
func (m *InstallerStatus_VersionStatus) XXX_Size() int {
	return m.Size()
}
func (m *InstallerStatus_VersionStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallerStatus_VersionStatus.DiscardUnknown(m)
}

var xxx_messageInfo_InstallerStatus_VersionStatus proto.InternalMessageInfo

func (m *InstallerStatus_VersionStatus) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *InstallerStatus_VersionStatus) GetStatus() InstallerStatus_Status {
	if m != nil {
		return m.Status
	}
	return InstallerStatus_NONE
}

// Mirrors k8s.io.api.core.v1.ResourceRequirements for unmarshaling.
type Resources struct {
	Limits               map[string]string `protobuf:"bytes,1,rep,name=limits,proto3" json:"limits,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Requests             map[string]string `protobuf:"bytes,2,rep,name=requests,proto3" json:"requests,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Resources) Reset()         { *m = Resources{} }
func (m *Resources) String() string { return proto.CompactTextString(m) }
func (*Resources) ProtoMessage()    {}
func (*Resources) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{25}
}
func (m *Resources) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Resources) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Resources.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Resources) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Resources.Merge(m, src)
}
func (m *Resources) XXX_Size() int {
	return m.Size()
}
func (m *Resources) XXX_DiscardUnknown() {
	xxx_messageInfo_Resources.DiscardUnknown(m)
}

var xxx_messageInfo_Resources proto.InternalMessageInfo

func (m *Resources) GetLimits() map[string]string {
	if m != nil {
		return m.Limits
	}
	return nil
}

func (m *Resources) GetRequests() map[string]string {
	if m != nil {
		return m.Requests
	}
	return nil
}

// Mirrors k8s.io.api.policy.v1beta1.DefaultPodDisruptionBudgetConfig for unmarshaling.
type PodDisruptionBudgetSpec struct {
	MinAvailable         uint32             `protobuf:"varint,1,opt,name=min_available,json=minAvailable,proto3" json:"min_available,omitempty"`
	Selector             *v12.LabelSelector `protobuf:"bytes,2,opt,name=selector,proto3" json:"selector,omitempty"`
	MaxUnavailable       uint32             `protobuf:"varint,3,opt,name=max_unavailable,json=maxUnavailable,proto3" json:"max_unavailable,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *PodDisruptionBudgetSpec) Reset()         { *m = PodDisruptionBudgetSpec{} }
func (m *PodDisruptionBudgetSpec) String() string { return proto.CompactTextString(m) }
func (*PodDisruptionBudgetSpec) ProtoMessage()    {}
func (*PodDisruptionBudgetSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{26}
}
func (m *PodDisruptionBudgetSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodDisruptionBudgetSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodDisruptionBudgetSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodDisruptionBudgetSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodDisruptionBudgetSpec.Merge(m, src)
}
func (m *PodDisruptionBudgetSpec) XXX_Size() int {
	return m.Size()
}
func (m *PodDisruptionBudgetSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PodDisruptionBudgetSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PodDisruptionBudgetSpec proto.InternalMessageInfo

func (m *PodDisruptionBudgetSpec) GetMinAvailable() uint32 {
	if m != nil {
		return m.MinAvailable
	}
	return 0
}

func (m *PodDisruptionBudgetSpec) GetSelector() *v12.LabelSelector {
	if m != nil {
		return m.Selector
	}
	return nil
}

func (m *PodDisruptionBudgetSpec) GetMaxUnavailable() uint32 {
	if m != nil {
		return m.MaxUnavailable
	}
	return 0
}

type ObjectMeta struct {
	// From k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta
	Name                 string   `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	Namespace            string   `protobuf:"bytes,6,opt,name=namespace,proto3" json:"namespace,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ObjectMeta) Reset()         { *m = ObjectMeta{} }
func (m *ObjectMeta) String() string { return proto.CompactTextString(m) }
func (*ObjectMeta) ProtoMessage()    {}
func (*ObjectMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{27}
}
func (m *ObjectMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectMeta.Merge(m, src)
}
func (m *ObjectMeta) XXX_Size() int {
	return m.Size()
}
func (m *ObjectMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectMeta.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectMeta proto.InternalMessageInfo

func (m *ObjectMeta) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ObjectMeta) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// TESTING ONLY
type TestKube struct {
	Env                 map[string]string                `protobuf:"bytes,60,rep,name=env,proto3" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Resources           *Resources                       `protobuf:"bytes,80,opt,name=resources,proto3" json:"resources,omitempty"`
	ReadinessProbe      *v1.Probe                        `protobuf:"bytes,81,opt,name=readiness_probe,json=readinessProbe,proto3" json:"readiness_probe,omitempty"`
	HpaSpec             *v11.HorizontalPodAutoscalerSpec `protobuf:"bytes,86,opt,name=hpa_spec,json=hpaSpec,proto3" json:"hpa_spec,omitempty"`
	PodDisruptionBudget *PodDisruptionBudgetSpec         `protobuf:"bytes,87,opt,name=pod_disruption_budget,json=podDisruptionBudget,proto3" json:"pod_disruption_budget,omitempty"`
	PodAnnotations      map[string]string                `protobuf:"bytes,90,rep,name=pod_annotations,json=podAnnotations,proto3" json:"pod_annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	NodeSelector        map[string]string                `protobuf:"bytes,92,rep,name=node_selector,json=nodeSelector,proto3" json:"node_selector,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Kustomize style overrides for k8s resources in rendered manifests.
	K8SObjectOverride    []*K8SObjectOverlay `protobuf:"bytes,100,rep,name=k8s_object_override,json=k8sObjectOverride,proto3" json:"k8s_object_override,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TestKube) Reset()         { *m = TestKube{} }
func (m *TestKube) String() string { return proto.CompactTextString(m) }
func (*TestKube) ProtoMessage()    {}
func (*TestKube) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a1188b3d395975, []int{28}
}
func (m *TestKube) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestKube) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestKube.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestKube) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestKube.Merge(m, src)
}
func (m *TestKube) XXX_Size() int {
	return m.Size()
}
func (m *TestKube) XXX_DiscardUnknown() {
	xxx_messageInfo_TestKube.DiscardUnknown(m)
}

var xxx_messageInfo_TestKube proto.InternalMessageInfo

func (m *TestKube) GetEnv() map[string]string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *TestKube) GetResources() *Resources {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *TestKube) GetReadinessProbe() *v1.Probe {
	if m != nil {
		return m.ReadinessProbe
	}
	return nil
}

func (m *TestKube) GetHpaSpec() *v11.HorizontalPodAutoscalerSpec {
	if m != nil {
		return m.HpaSpec
	}
	return nil
}

func (m *TestKube) GetPodDisruptionBudget() *PodDisruptionBudgetSpec {
	if m != nil {
		return m.PodDisruptionBudget
	}
	return nil
}

func (m *TestKube) GetPodAnnotations() map[string]string {
	if m != nil {
		return m.PodAnnotations
	}
	return nil
}

func (m *TestKube) GetNodeSelector() map[string]string {
	if m != nil {
		return m.NodeSelector
	}
	return nil
}

func (m *TestKube) GetK8SObjectOverride() []*K8SObjectOverlay {
	if m != nil {
		return m.K8SObjectOverride
	}
	return nil
}

func init() {
	proto.RegisterEnum("v1alpha1.PolicyTelemetryFeatureSpec_OutboundPolicy", PolicyTelemetryFeatureSpec_OutboundPolicy_name, PolicyTelemetryFeatureSpec_OutboundPolicy_value)
	proto.RegisterEnum("v1alpha1.CommonComponentSpec_LogLevel", CommonComponentSpec_LogLevel_name, CommonComponentSpec_LogLevel_value)
	proto.RegisterEnum("v1alpha1.IngressGatewaySpec_IngressType", IngressGatewaySpec_IngressType_name, IngressGatewaySpec_IngressType_value)
	proto.RegisterEnum("v1alpha1.IngressGatewaySpec_ExternalTrafficPolicy", IngressGatewaySpec_ExternalTrafficPolicy_name, IngressGatewaySpec_ExternalTrafficPolicy_value)
	proto.RegisterEnum("v1alpha1.InstallerStatus_Status", InstallerStatus_Status_name, InstallerStatus_Status_value)
	proto.RegisterType((*IstioInstaller)(nil), "v1alpha1.IstioInstaller")
	proto.RegisterType((*InstallerSpec)(nil), "v1alpha1.InstallerSpec")
	proto.RegisterType((*TrafficManagementFeatureSpec)(nil), "v1alpha1.TrafficManagementFeatureSpec")
	proto.RegisterType((*PolicyTelemetryFeatureSpec)(nil), "v1alpha1.PolicyTelemetryFeatureSpec")
	proto.RegisterType((*SecurityFeatureSpec)(nil), "v1alpha1.SecurityFeatureSpec")
	proto.RegisterType((*ConfigManagementFeatureSpec)(nil), "v1alpha1.ConfigManagementFeatureSpec")
	proto.RegisterType((*PilotComponentSpec)(nil), "v1alpha1.PilotComponentSpec")
	proto.RegisterType((*ProxyComponentSpec)(nil), "v1alpha1.ProxyComponentSpec")
	proto.RegisterType((*SidecarInjectorComponentSpec)(nil), "v1alpha1.SidecarInjectorComponentSpec")
	proto.RegisterType((*PolicyComponentSpec)(nil), "v1alpha1.PolicyComponentSpec")
	proto.RegisterType((*TelemetryComponentSpec)(nil), "v1alpha1.TelemetryComponentSpec")
	proto.RegisterType((*CitadelComponentSpec)(nil), "v1alpha1.CitadelComponentSpec")
	proto.RegisterType((*CertManagerComponentSpec)(nil), "v1alpha1.CertManagerComponentSpec")
	proto.RegisterType((*NodeAgentComponentSpec)(nil), "v1alpha1.NodeAgentComponentSpec")
	proto.RegisterType((*GalleyComponentSpec)(nil), "v1alpha1.GalleyComponentSpec")
	proto.RegisterType((*CommonComponentSpec)(nil), "v1alpha1.CommonComponentSpec")
	proto.RegisterType((*CommonComponentSpec_UpdateSpec)(nil), "v1alpha1.CommonComponentSpec.UpdateSpec")
	proto.RegisterType((*KubernetesResourcesSpec)(nil), "v1alpha1.KubernetesResourcesSpec")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.KubernetesResourcesSpec.NodeSelectorEntry")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.KubernetesResourcesSpec.PodAnnotationsEntry")
	proto.RegisterType((*KubernetesResourcesSpec_NodeAffinity)(nil), "v1alpha1.KubernetesResourcesSpec.NodeAffinity")
	proto.RegisterType((*IngressGatewaySpec)(nil), "v1alpha1.IngressGatewaySpec")
	proto.RegisterType((*EgressGatewaySpec)(nil), "v1alpha1.EgressGatewaySpec")
	proto.RegisterType((*LoadBalancingGatewayConfig)(nil), "v1alpha1.LoadBalancingGatewayConfig")
	proto.RegisterType((*GatewayConfig)(nil), "v1alpha1.GatewayConfig")
	proto.RegisterType((*LoadBalancerConfig)(nil), "v1alpha1.LoadBalancerConfig")
	proto.RegisterType((*OperatorSpec)(nil), "v1alpha1.OperatorSpec")
	proto.RegisterType((*K8SObjectOverlay)(nil), "v1alpha1.k8sObjectOverlay")
	proto.RegisterType((*K8SObjectOverlay_PathValue)(nil), "v1alpha1.k8sObjectOverlay.PathValue")
	proto.RegisterType((*InstallerStatus)(nil), "v1alpha1.InstallerStatus")
	proto.RegisterType((*InstallerStatus_VersionStatus)(nil), "v1alpha1.InstallerStatus.VersionStatus")
	proto.RegisterType((*Resources)(nil), "v1alpha1.Resources")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.Resources.LimitsEntry")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.Resources.RequestsEntry")
	proto.RegisterType((*PodDisruptionBudgetSpec)(nil), "v1alpha1.PodDisruptionBudgetSpec")
	proto.RegisterType((*ObjectMeta)(nil), "v1alpha1.ObjectMeta")
	proto.RegisterType((*TestKube)(nil), "v1alpha1.TestKube")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.TestKube.EnvEntry")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.TestKube.NodeSelectorEntry")
	proto.RegisterMapType((map[string]string)(nil), "v1alpha1.TestKube.PodAnnotationsEntry")
}

func init() { proto.RegisterFile("istioinstaller_types.proto", fileDescriptor_d0a1188b3d395975) }

var fileDescriptor_d0a1188b3d395975 = []byte{
	// 2647 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x59, 0x49, 0x73, 0x1b, 0xc7,
	0xf5, 0x17, 0x08, 0x6e, 0x78, 0x00, 0x48, 0xb0, 0x69, 0xc9, 0x23, 0x98, 0xa6, 0xe8, 0xf9, 0x7b,
	0xe1, 0x3f, 0x0b, 0x68, 0x91, 0xb2, 0x42, 0xd9, 0x8e, 0x1c, 0x90, 0x82, 0x24, 0x46, 0x10, 0x01,
	0x0d, 0x49, 0x39, 0x72, 0x52, 0x99, 0x6a, 0xcc, 0x34, 0x81, 0x09, 0x07, 0xd3, 0x93, 0xe9, 0x06,
	0x2d, 0xe4, 0xe6, 0x2f, 0x90, 0x43, 0x4e, 0x49, 0x55, 0x3e, 0x45, 0x4e, 0x39, 0xe4, 0x03, 0xe4,
	0x94, 0xca, 0x21, 0xc7, 0x1c, 0x52, 0xf6, 0x35, 0xb7, 0x1c, 0x72, 0x48, 0x55, 0x2a, 0xd5, 0xcb,
	0x60, 0x06, 0x0b, 0xc5, 0xc5, 0x71, 0x55, 0x6e, 0x83, 0xdf, 0x7b, 0xef, 0xd7, 0xeb, 0xdb, 0x1a,
	0x50, 0xf6, 0x18, 0xf7, 0xa8, 0x17, 0x30, 0x8e, 0x7d, 0x9f, 0x44, 0x36, 0xef, 0x87, 0x84, 0x55,
	0xc2, 0x88, 0x72, 0x8a, 0xe6, 0x4f, 0x6f, 0x63, 0x3f, 0xec, 0xe0, 0xdb, 0x65, 0xf3, 0x64, 0x9b,
	0x55, 0x3c, 0xba, 0x81, 0x43, 0x6f, 0xc3, 0xa1, 0x11, 0xd9, 0x38, 0xbd, 0xbd, 0xd1, 0x26, 0x01,
	0x89, 0x30, 0x27, 0xae, 0xd2, 0x2e, 0xff, 0x7f, 0x4a, 0x07, 0xf7, 0x38, 0x65, 0x0e, 0xf6, 0xbd,
	0xa0, 0x3d, 0x49, 0xf5, 0x4e, 0xa2, 0xda, 0xc5, 0x4e, 0xc7, 0x0b, 0x48, 0xd4, 0xdf, 0x08, 0x4f,
	0xda, 0x02, 0x60, 0x1b, 0x5d, 0xc2, 0xf1, 0x24, 0xab, 0x1f, 0xb4, 0x3d, 0xde, 0xe9, 0xb5, 0x2a,
	0x0e, 0xed, 0x6e, 0xb4, 0x69, 0x9b, 0x6e, 0x48, 0xb8, 0xd5, 0x3b, 0x4e, 0x3e, 0xda, 0x94, 0xb6,
	0x7d, 0x92, 0xfc, 0xfe, 0x3c, 0xc2, 0x61, 0x48, 0x22, 0xbd, 0x20, 0x33, 0x84, 0x85, 0x3d, 0xb1,
	0xdc, 0xbd, 0x78, 0xb9, 0xe8, 0xdb, 0x30, 0xcd, 0x42, 0xe2, 0x18, 0xd9, 0xb5, 0xcc, 0x7a, 0x7e,
	0xf3, 0xf5, 0x4a, 0xbc, 0xe2, 0xca, 0x40, 0xe5, 0x20, 0x24, 0x8e, 0x25, 0x95, 0xd0, 0x6d, 0x98,
	0x65, 0x1c, 0xf3, 0x1e, 0x33, 0xa6, 0xa5, 0xfa, 0xcd, 0x49, 0xea, 0x52, 0xc1, 0xd2, 0x8a, 0xe6,
	0xdf, 0x67, 0xa0, 0x38, 0x44, 0x85, 0xb6, 0xc1, 0x70, 0xc9, 0x31, 0xee, 0xf9, 0xdc, 0x0e, 0x70,
	0x97, 0xb0, 0x10, 0x3b, 0xc4, 0x0e, 0x23, 0x72, 0xec, 0xbd, 0x34, 0x66, 0xd6, 0x32, 0xeb, 0x39,
	0xeb, 0x86, 0x96, 0xef, 0xc7, 0xe2, 0xa6, 0x94, 0xa2, 0x23, 0x40, 0x3c, 0xc2, 0xc7, 0xc7, 0x9e,
	0x63, 0x77, 0x71, 0x80, 0xdb, 0xa4, 0x4b, 0x02, 0x6e, 0xdc, 0x94, 0x53, 0x79, 0x37, 0x99, 0xca,
	0xa1, 0xd2, 0x79, 0x3a, 0x50, 0x79, 0x48, 0x30, 0xef, 0x45, 0x44, 0x2e, 0x64, 0x89, 0x8f, 0x4a,
	0x51, 0x03, 0x4a, 0x21, 0xf5, 0x3d, 0xa7, 0x6f, 0x73, 0xe2, 0x93, 0x2e, 0xe1, 0x51, 0xdf, 0x28,
	0x4b, 0xd2, 0xb7, 0x13, 0xd2, 0xa6, 0xd4, 0x38, 0x8c, 0x15, 0xd2, 0x94, 0x8b, 0xe1, 0xb0, 0x0c,
	0xdd, 0x83, 0x79, 0x46, 0x9c, 0x5e, 0xe4, 0xf1, 0xbe, 0xb1, 0x22, 0x89, 0xde, 0x4c, 0x88, 0x0e,
	0xb4, 0x24, 0xcd, 0x30, 0x50, 0x47, 0x16, 0x2c, 0x39, 0x34, 0x38, 0xf6, 0xda, 0xe9, 0x15, 0xbe,
	0x29, 0x39, 0xde, 0x49, 0x38, 0x76, 0xa5, 0xca, 0xe4, 0x05, 0x96, 0x9c, 0x11, 0x21, 0xaa, 0xc1,
	0xa2, 0x17, 0xb4, 0x23, 0xc2, 0x98, 0xdd, 0xc6, 0x9c, 0x7c, 0x8e, 0xfb, 0xc6, 0xea, 0x5a, 0x76,
	0x3d, 0xbf, 0xb9, 0x92, 0x3e, 0x3e, 0xa9, 0xf0, 0x48, 0xc9, 0x25, 0xd1, 0x82, 0x37, 0x84, 0xa1,
	0x1d, 0x58, 0x20, 0xc3, 0x2c, 0xb7, 0x24, 0xcb, 0x1b, 0x09, 0x4b, 0x6d, 0x8c, 0xa4, 0x48, 0x86,
	0x38, 0x6a, 0x80, 0xc8, 0x4b, 0x4e, 0xa2, 0x00, 0xfb, 0x36, 0x0d, 0xc5, 0xe5, 0xa6, 0x11, 0x33,
	0x36, 0x25, 0xcf, 0x8d, 0x84, 0xa7, 0xa1, 0x45, 0xea, 0xc4, 0x62, 0x8b, 0x18, 0x65, 0xe8, 0x01,
	0x14, 0x4e, 0xb6, 0x99, 0xad, 0xaf, 0x09, 0x33, 0x9a, 0x72, 0x83, 0xde, 0x4a, 0x08, 0x9e, 0xf4,
	0x5a, 0x24, 0x0a, 0x08, 0x27, 0xcc, 0x22, 0x8c, 0xf6, 0x22, 0x87, 0x30, 0xc9, 0x95, 0x3f, 0xd9,
	0x66, 0x0f, 0xb4, 0x15, 0xaa, 0xc0, 0xb2, 0xd3, 0x63, 0x9c, 0x76, 0xed, 0x10, 0x3b, 0x27, 0xb8,
	0x4d, 0xec, 0x10, 0xf3, 0x8e, 0xe1, 0xca, 0x3b, 0xb8, 0xa4, 0x44, 0x4d, 0x25, 0x69, 0x62, 0xde,
	0x41, 0x25, 0xc8, 0x76, 0x7a, 0x2d, 0x83, 0x48, 0xb9, 0xf8, 0x14, 0x08, 0xc7, 0x6d, 0xe3, 0x58,
	0x21, 0x1c, 0xb7, 0xcd, 0xbf, 0x4c, 0xc1, 0xca, 0xab, 0xee, 0x1f, 0xba, 0x03, 0x73, 0x24, 0xc0,
	0x2d, 0x9f, 0xb8, 0x46, 0x46, 0xce, 0xba, 0x5c, 0x51, 0x3e, 0x5b, 0x89, 0x7d, 0xb6, 0xb2, 0x43,
	0xa9, 0xff, 0x1c, 0xfb, 0x3d, 0x62, 0xc5, 0xaa, 0x68, 0x05, 0x72, 0x03, 0x5f, 0x31, 0xa6, 0xe4,
	0x70, 0x09, 0x80, 0xde, 0x81, 0x05, 0xc7, 0xef, 0x31, 0x4e, 0x22, 0xdb, 0xa5, 0x5d, 0xec, 0x05,
	0x86, 0x21, 0x55, 0x8a, 0x1a, 0x7d, 0x20, 0x41, 0xb4, 0x09, 0x33, 0xa1, 0xe7, 0x53, 0x6e, 0xac,
	0xca, 0x81, 0x53, 0xa7, 0xdf, 0x14, 0xf0, 0x2e, 0xed, 0x86, 0x34, 0x20, 0x01, 0x97, 0x3b, 0xa5,
	0x54, 0xa5, 0x4d, 0x44, 0x5f, 0x8a, 0xb3, 0x1e, 0xb5, 0x11, 0xf0, 0xa8, 0x8d, 0xc0, 0xd0, 0x33,
	0x28, 0x31, 0xcf, 0x25, 0x0e, 0x8e, 0x6c, 0x2f, 0xf8, 0x19, 0x71, 0x38, 0x8d, 0x8c, 0xb5, 0x51,
	0x27, 0x3d, 0x50, 0x1a, 0x7b, 0x5a, 0x61, 0x98, 0x68, 0x91, 0x0d, 0x4b, 0xcd, 0x5f, 0x66, 0xa1,
	0x7c, 0xb6, 0x07, 0xa2, 0x06, 0xdc, 0xd0, 0x1e, 0xec, 0x74, 0x88, 0x73, 0x62, 0x1f, 0x63, 0x4f,
	0xde, 0xaf, 0xc0, 0x80, 0x73, 0xf7, 0x78, 0x59, 0x59, 0xee, 0x0a, 0xc3, 0x87, 0xd8, 0x13, 0xb7,
	0x2c, 0x40, 0x1c, 0x56, 0x68, 0x8f, 0xb7, 0x68, 0x2f, 0x70, 0xed, 0x38, 0xe4, 0xe8, 0x11, 0xba,
	0xd4, 0x25, 0x46, 0x7e, 0x2d, 0xb3, 0xbe, 0xb0, 0xb9, 0x75, 0x91, 0xf0, 0x50, 0x69, 0x68, 0x22,
	0xa5, 0x62, 0xdd, 0x8c, 0x89, 0xf5, 0x35, 0x51, 0xf0, 0x53, 0xea, 0x12, 0xf4, 0x01, 0xcc, 0xaa,
	0x41, 0x8c, 0xcd, 0xd1, 0xa8, 0xa1, 0xb4, 0x86, 0x77, 0x49, 0x2b, 0xa3, 0xfb, 0x90, 0x4b, 0x02,
	0xd7, 0x96, 0xb4, 0x5c, 0x4b, 0x45, 0xc3, 0x58, 0x34, 0x6c, 0x9c, 0x98, 0x98, 0x9b, 0xb0, 0x30,
	0x3c, 0x47, 0x54, 0x84, 0x5c, 0xb5, 0x5e, 0x6f, 0x7c, 0x6a, 0x57, 0xf7, 0x5f, 0x94, 0xae, 0xa1,
	0x25, 0x28, 0x5a, 0xb5, 0x47, 0x7b, 0x07, 0x87, 0xd6, 0x0b, 0xbb, 0xb1, 0x5f, 0x7f, 0x51, 0xca,
	0x98, 0x7f, 0xcd, 0xc2, 0xf2, 0x84, 0x48, 0xf6, 0x8d, 0x5c, 0xef, 0xc7, 0x80, 0x1c, 0x1a, 0xf0,
	0x88, 0xfa, 0x76, 0xe8, 0xe3, 0x80, 0xd8, 0x5d, 0xee, 0x33, 0xa3, 0x78, 0x2e, 0x7d, 0x49, 0x5b,
	0x35, 0x85, 0xd1, 0x53, 0xee, 0x33, 0xb4, 0x03, 0x8b, 0x2e, 0xe6, 0x38, 0x4d, 0xb3, 0x70, 0x2e,
	0x4d, 0x51, 0x98, 0x24, 0x1c, 0x6f, 0x41, 0x81, 0x47, 0x3d, 0xc6, 0x63, 0x57, 0x5b, 0x94, 0xd3,
	0xcd, 0x4b, 0x4c, 0x3b, 0xda, 0x36, 0xcc, 0x39, 0x1e, 0xc7, 0x2e, 0xf1, 0x8d, 0xd7, 0x24, 0xfd,
	0x6a, 0x2a, 0x74, 0x2b, 0xc1, 0xf0, 0x61, 0xc4, 0xea, 0xa8, 0x06, 0x05, 0x87, 0x44, 0x5c, 0x07,
	0xff, 0xc8, 0xb8, 0x2e, 0xcd, 0xcd, 0x94, 0x39, 0x89, 0xb8, 0x0a, 0x2c, 0x23, 0x2e, 0x93, 0x77,
	0x12, 0x09, 0xfa, 0x04, 0x20, 0xa0, 0x2e, 0xb1, 0x71, 0x5b, 0xa4, 0x8f, 0x1b, 0xa3, 0x57, 0x62,
	0x9f, 0xba, 0xa4, 0x2a, 0x44, 0x23, 0x57, 0x22, 0x88, 0x71, 0xf3, 0x10, 0xde, 0x78, 0x45, 0x8e,
	0x11, 0x17, 0xb5, 0x2d, 0x12, 0x7a, 0x5f, 0x1f, 0x72, 0xea, 0xa2, 0x3e, 0x92, 0xf8, 0xc8, 0x45,
	0x55, 0xca, 0xe6, 0x17, 0x19, 0x40, 0xe3, 0xa1, 0x46, 0xb0, 0x39, 0xb4, 0xdb, 0xa5, 0xc1, 0x38,
	0xdb, 0xae, 0xc4, 0x47, 0xd8, 0x94, 0xb2, 0xb8, 0x6a, 0x3a, 0x4c, 0x5c, 0xc0, 0xcb, 0x63, 0x55,
	0xf3, 0x09, 0xa0, 0xf1, 0xc8, 0x75, 0xc5, 0x29, 0x98, 0xbf, 0xcb, 0xc0, 0xca, 0xab, 0x02, 0xd9,
	0x55, 0x97, 0xf6, 0x63, 0x58, 0x51, 0xae, 0x91, 0x54, 0x48, 0xcc, 0x6e, 0xf5, 0xe3, 0x84, 0x77,
	0x81, 0xf5, 0xde, 0x54, 0xf6, 0x83, 0x0a, 0x8a, 0xed, 0xf4, 0x75, 0xde, 0x33, 0xeb, 0xb0, 0x3c,
	0x21, 0x9a, 0x5c, 0x75, 0x0b, 0x1a, 0x70, 0x63, 0x72, 0x84, 0xb9, 0x2a, 0xe1, 0x6f, 0x33, 0xf0,
	0xda, 0x24, 0x27, 0xb9, 0xea, 0x5e, 0xde, 0x82, 0x3c, 0x23, 0xfe, 0xb1, 0xcd, 0xbc, 0x76, 0x40,
	0x5c, 0x19, 0xb9, 0xe7, 0x2d, 0x10, 0xd0, 0x81, 0x44, 0xd0, 0x77, 0x00, 0x39, 0x11, 0xc1, 0x9c,
	0xd8, 0x5d, 0xc2, 0x3a, 0x3a, 0xcc, 0x1b, 0x05, 0xa9, 0x57, 0x52, 0x92, 0xa7, 0x84, 0x75, 0xd4,
	0x9e, 0x99, 0xcf, 0xc0, 0x38, 0xcb, 0x07, 0xbf, 0xc6, 0x16, 0x4e, 0xf6, 0xc8, 0xab, 0x12, 0xd6,
	0x61, 0x79, 0x82, 0x1b, 0x5e, 0x95, 0xed, 0x4f, 0x53, 0xb0, 0x3c, 0x41, 0xfe, 0x8d, 0x84, 0xfa,
	0x8f, 0x61, 0xc6, 0x25, 0xad, 0x5e, 0x5b, 0xb6, 0x23, 0x0b, 0xe9, 0x7a, 0x61, 0xc2, 0x0c, 0x2a,
	0x75, 0xda, 0xae, 0x93, 0x53, 0xe2, 0x5b, 0xca, 0x08, 0x6d, 0x41, 0xf6, 0x64, 0xfb, 0x12, 0xd5,
	0xa0, 0xd0, 0x2e, 0xbf, 0x0f, 0x70, 0x14, 0xba, 0x98, 0xab, 0xc8, 0x56, 0x82, 0x2c, 0xf5, 0xd5,
	0x82, 0x72, 0x96, 0xf8, 0x14, 0x48, 0x40, 0x3e, 0xd7, 0x53, 0x15, 0x9f, 0xe6, 0x7d, 0x98, 0x8f,
	0x47, 0x46, 0xf3, 0x30, 0xbd, 0xdf, 0xd8, 0xaf, 0x95, 0xae, 0xa1, 0x1c, 0xcc, 0xd4, 0x2c, 0xab,
	0x61, 0x95, 0x32, 0x02, 0xfc, 0xb4, 0x6a, 0xed, 0x97, 0xa6, 0x04, 0xf8, 0xa0, 0xb6, 0x73, 0xf4,
	0xa8, 0x94, 0x15, 0xe0, 0xde, 0xfe, 0xc3, 0x46, 0x69, 0xda, 0xfc, 0xe7, 0x1c, 0xbc, 0x7e, 0xc6,
	0x94, 0xd0, 0x6d, 0xc8, 0x45, 0x31, 0xa0, 0xb7, 0x75, 0x39, 0x59, 0xc8, 0x40, 0xd7, 0x4a, 0xb4,
	0x44, 0x52, 0x8b, 0x08, 0x76, 0xbd, 0x40, 0x94, 0xe6, 0x61, 0x44, 0x5b, 0x6a, 0x5f, 0x45, 0x77,
	0xa6, 0xba, 0xcc, 0x0a, 0x0e, 0xbd, 0x8a, 0x68, 0x5a, 0x2b, 0xa7, 0xb2, 0x6c, 0x6b, 0x11, 0x6b,
	0x61, 0x60, 0x21, 0x7f, 0xa3, 0xff, 0x83, 0x62, 0x44, 0x42, 0xdf, 0x73, 0xb0, 0xed, 0xd0, 0x5e,
	0xc0, 0xe5, 0xfe, 0x17, 0xad, 0x82, 0x06, 0x77, 0x05, 0x86, 0x9e, 0xc1, 0x7c, 0x27, 0xc4, 0xb6,
	0x6c, 0x17, 0x55, 0xff, 0x77, 0x37, 0x3d, 0x42, 0xaa, 0xe5, 0x15, 0x03, 0x3d, 0xa6, 0x91, 0xf7,
	0x0b, 0x1a, 0x70, 0xec, 0x37, 0xa9, 0x5b, 0xd5, 0x32, 0xdd, 0x4d, 0xce, 0x75, 0x42, 0x2c, 0x97,
	0x7b, 0x04, 0xd7, 0x43, 0xea, 0xda, 0xae, 0xc7, 0xa2, 0x5e, 0xc8, 0x3d, 0x1a, 0xd8, 0xad, 0x9e,
	0xdb, 0x26, 0x5c, 0x36, 0x82, 0x43, 0x67, 0xd8, 0xa4, 0xee, 0x83, 0x81, 0xd6, 0x8e, 0x54, 0x92,
	0x54, 0xcb, 0xe1, 0xb8, 0x00, 0xfd, 0x14, 0x16, 0x05, 0x2d, 0x0e, 0x02, 0xca, 0xb1, 0xc0, 0x99,
	0x31, 0x2b, 0x7b, 0x8c, 0x0f, 0xce, 0xbd, 0x14, 0x62, 0xa0, 0x6a, 0x62, 0x57, 0x0b, 0x78, 0xd4,
	0xb7, 0x16, 0xc2, 0x21, 0x10, 0xfd, 0x08, 0x8a, 0x32, 0xbf, 0x32, 0xe2, 0xab, 0xf2, 0x76, 0x4e,
	0xb2, 0x6f, 0x9d, 0xcf, 0x2e, 0x1c, 0xfd, 0x40, 0x5b, 0x29, 0xee, 0x42, 0x90, 0x82, 0xd0, 0x81,
	0x66, 0x16, 0xa5, 0x61, 0x20, 0xfa, 0xc7, 0x79, 0xb9, 0x11, 0x95, 0x8b, 0x31, 0x57, 0xb5, 0x95,
	0x22, 0x8d, 0x7f, 0xa1, 0x6f, 0xc1, 0x92, 0xd7, 0x95, 0xfd, 0x4d, 0xcf, 0xf7, 0xe3, 0x00, 0x97,
	0x93, 0x17, 0x7a, 0x51, 0x0a, 0x9a, 0x3d, 0xdf, 0xd7, 0xa5, 0x5f, 0x05, 0x96, 0xc3, 0xc8, 0xa3,
	0xa2, 0xae, 0xb3, 0x1d, 0x1f, 0x33, 0x26, 0x53, 0x90, 0xcc, 0x38, 0x39, 0x6b, 0x29, 0x16, 0xed,
	0x0a, 0x89, 0x48, 0x2e, 0xe8, 0x2e, 0xcc, 0xd3, 0x53, 0x12, 0xf9, 0xb8, 0xcf, 0x0c, 0x57, 0xee,
	0x42, 0x39, 0x99, 0xeb, 0xc9, 0x36, 0x6b, 0xb4, 0x44, 0x5e, 0x6c, 0x28, 0x15, 0x6b, 0xa0, 0x5b,
	0xae, 0x8a, 0x2c, 0x34, 0xb6, 0xd3, 0xc2, 0xdb, 0x4e, 0x74, 0x59, 0x91, 0xb3, 0xc4, 0x27, 0x7a,
	0x0d, 0x66, 0x4e, 0x45, 0x08, 0xd1, 0x1e, 0xa8, 0x7e, 0x7c, 0x38, 0xb5, 0x9d, 0x29, 0x7f, 0x02,
	0x4b, 0x63, 0xdb, 0x79, 0x29, 0x02, 0x0a, 0x85, 0xf4, 0xae, 0xa1, 0x37, 0x01, 0x70, 0xe4, 0x74,
	0x6c, 0xdc, 0x75, 0xef, 0xde, 0x91, 0x14, 0x45, 0x2b, 0x27, 0x90, 0xaa, 0x00, 0x06, 0x62, 0xb6,
	0x75, 0xef, 0xfd, 0x97, 0x92, 0x4d, 0x8b, 0x0f, 0x04, 0x20, 0x0a, 0x43, 0x29, 0x0e, 0x43, 0xe7,
	0xee, 0x1d, 0x9f, 0x68, 0x17, 0xca, 0x0b, 0xac, 0xa9, 0x20, 0xf3, 0xab, 0x2c, 0xa0, 0xf1, 0x4e,
	0x1b, 0xdd, 0x86, 0xb9, 0xb8, 0xa5, 0x86, 0xd1, 0x67, 0x18, 0xad, 0xa7, 0xaa, 0x31, 0x2b, 0xd6,
	0x43, 0x4f, 0xa0, 0x10, 0xf7, 0xf4, 0xbc, 0x1f, 0xc6, 0x0d, 0xc9, 0xfa, 0xab, 0x1a, 0xfa, 0x18,
	0x3a, 0xec, 0x87, 0xc4, 0xca, 0x7b, 0xc9, 0x0f, 0x54, 0x85, 0xa2, 0x4f, 0xb1, 0x6b, 0xb7, 0xb0,
	0x8f, 0x03, 0x87, 0x44, 0xba, 0xb6, 0x4e, 0x35, 0x7b, 0x75, 0x8a, 0xdd, 0x1d, 0x2d, 0xd5, 0x53,
	0x29, 0xf8, 0x29, 0x0c, 0x7d, 0x04, 0x79, 0xe6, 0x32, 0x3b, 0x4e, 0x08, 0xa5, 0x73, 0x13, 0x02,
	0x30, 0x97, 0xd5, 0x74, 0x4e, 0xe8, 0xc0, 0xf5, 0xb8, 0xc7, 0x1f, 0x6a, 0x8a, 0x8c, 0x25, 0xb9,
	0xaa, 0xcd, 0x57, 0xae, 0xaa, 0x36, 0xc9, 0xd2, 0x9a, 0x4c, 0x68, 0xae, 0x43, 0x3e, 0xb5, 0x0b,
	0x22, 0x3c, 0xef, 0x1d, 0x1c, 0xee, 0x35, 0x4a, 0xd7, 0xd0, 0x02, 0xc0, 0x93, 0xa3, 0x9d, 0x9a,
	0xb5, 0x5f, 0x3b, 0xac, 0x1d, 0x94, 0x32, 0xe6, 0x3d, 0xb8, 0x3e, 0x91, 0x79, 0x38, 0xe2, 0xd7,
	0x1b, 0xbb, 0xd5, 0x7a, 0x29, 0x83, 0xf2, 0x30, 0xb7, 0x5b, 0x3f, 0x3a, 0x38, 0xac, 0x59, 0xa5,
	0x29, 0xf3, 0x21, 0x2c, 0xd5, 0xfe, 0x0b, 0x67, 0x6c, 0xfe, 0x2a, 0x03, 0xe5, 0x64, 0xe3, 0xbd,
	0xa0, 0x3d, 0xa4, 0x77, 0x95, 0x5b, 0x33, 0x76, 0xd0, 0xf9, 0xcb, 0x1e, 0xb4, 0xf9, 0x19, 0x14,
	0x87, 0xa7, 0x71, 0xc5, 0xb2, 0x0c, 0xc1, 0xb4, 0xbc, 0xb8, 0x2a, 0xb0, 0xc8, 0x6f, 0xf3, 0x1f,
	0x53, 0x80, 0xc6, 0x27, 0x80, 0x3e, 0x80, 0x99, 0x90, 0x46, 0x5c, 0xe4, 0x43, 0x11, 0x5f, 0x6e,
	0x4d, 0x4a, 0x6b, 0x07, 0x24, 0x3a, 0xf5, 0x1c, 0xd2, 0xa4, 0x11, 0xb7, 0x94, 0xb6, 0xa8, 0x34,
	0xf4, 0xfb, 0xc7, 0x5e, 0x53, 0x3a, 0x63, 0xce, 0x4a, 0x00, 0xb4, 0x06, 0xf9, 0xf8, 0x8a, 0xec,
	0x35, 0x99, 0x31, 0xb3, 0x96, 0x15, 0x5d, 0x5c, 0x0a, 0x42, 0xeb, 0xb0, 0xc8, 0x08, 0x63, 0x1e,
	0x0d, 0xe2, 0x00, 0x61, 0xcc, 0xa9, 0x98, 0x39, 0x02, 0xa3, 0x77, 0x61, 0x21, 0xbd, 0x47, 0x7b,
	0x4d, 0x19, 0xb5, 0x73, 0xd6, 0x08, 0x8a, 0x3e, 0x04, 0x23, 0x8d, 0x1c, 0xc8, 0xe8, 0x6d, 0xe1,
	0xa0, 0x4d, 0x98, 0x91, 0x93, 0x13, 0x38, 0x53, 0x8e, 0x4c, 0x28, 0xc4, 0x93, 0xdb, 0x4f, 0x02,
	0xf2, 0x10, 0x86, 0xee, 0x9c, 0xe5, 0x47, 0x79, 0xa9, 0x7c, 0x86, 0x4f, 0x7c, 0x91, 0x81, 0x42,
	0xfa, 0xc1, 0x4d, 0x14, 0x03, 0x5d, 0x1c, 0x78, 0xc7, 0x84, 0x71, 0xf5, 0x22, 0xa6, 0x82, 0x69,
	0x21, 0x06, 0xe5, 0x63, 0xd8, 0xab, 0xeb, 0xb8, 0x8a, 0x7e, 0x55, 0x76, 0x75, 0x1c, 0x38, 0x3b,
	0x23, 0x48, 0x3d, 0xf3, 0x0f, 0x19, 0x28, 0x8d, 0x8a, 0x44, 0xe5, 0x8e, 0x43, 0xcf, 0x3e, 0x25,
	0x91, 0xd8, 0x6d, 0x3d, 0x0b, 0xc0, 0xa1, 0xf7, 0x5c, 0x21, 0xe2, 0x0e, 0x9d, 0x78, 0x81, 0xab,
	0x87, 0x97, 0xdf, 0x02, 0x93, 0x09, 0x4b, 0x1d, 0xb8, 0xfc, 0x46, 0xf7, 0x61, 0x2e, 0xc4, 0xdc,
	0xe9, 0x10, 0x66, 0x4c, 0xcb, 0x2b, 0xf4, 0xf6, 0xd9, 0x13, 0xaa, 0x88, 0xd5, 0xe9, 0x9a, 0x55,
	0x1b, 0x95, 0x6f, 0x41, 0x6e, 0x80, 0x8a, 0x01, 0x52, 0x9b, 0x22, 0xbf, 0xcd, 0xdf, 0xcc, 0xc0,
	0xe2, 0xc8, 0x03, 0x38, 0x7a, 0x3e, 0xf1, 0xb1, 0x5a, 0xf9, 0xc8, 0x7b, 0x67, 0xbe, 0x9b, 0x57,
	0xf4, 0xda, 0xf4, 0x2b, 0xfa, 0x84, 0xd7, 0x6a, 0x6b, 0xc2, 0x6b, 0xf5, 0xd4, 0xe5, 0x58, 0xc7,
	0x1e, 0xac, 0x77, 0x53, 0x0f, 0xd6, 0xd9, 0xcb, 0x71, 0x25, 0x4f, 0xd7, 0x87, 0x93, 0x9e, 0xae,
	0xa7, 0x2f, 0xc7, 0x36, 0xfe, 0x78, 0xdd, 0x1c, 0x7f, 0xbc, 0x9e, 0x91, 0x67, 0x78, 0x61, 0xce,
	0xd1, 0x77, 0xec, 0xfd, 0xb1, 0x77, 0xec, 0xd9, 0xcb, 0x11, 0x0e, 0xbf, 0x69, 0x97, 0x1d, 0x28,
	0x0e, 0xc9, 0x91, 0x01, 0x73, 0xc3, 0x77, 0x36, 0xfe, 0x89, 0xb6, 0x07, 0xff, 0x9f, 0x4c, 0xc9,
	0xcc, 0xb6, 0x76, 0xf6, 0x90, 0x23, 0x7f, 0xa3, 0x6c, 0xc3, 0xac, 0x66, 0x4f, 0xf2, 0x4f, 0x01,
	0xe6, 0x8f, 0x9a, 0x0f, 0xaa, 0x87, 0x7b, 0xfb, 0x8f, 0x54, 0x0a, 0x7a, 0x5c, 0xab, 0xd6, 0x0f,
	0x1f, 0xbf, 0x50, 0x7d, 0x87, 0x6a, 0x46, 0xb2, 0xe6, 0xbf, 0x32, 0x90, 0x1b, 0x54, 0x8a, 0xe8,
	0x7b, 0x30, 0xeb, 0x7b, 0x5d, 0x2f, 0x15, 0x4c, 0xc7, 0x9b, 0x8b, 0x4a, 0x5d, 0x6a, 0xa8, 0xf2,
	0x54, 0xab, 0xa3, 0xef, 0xc3, 0x7c, 0x44, 0x7e, 0xde, 0x23, 0x8c, 0x8b, 0xc9, 0x67, 0x87, 0x8b,
	0xf3, 0xc4, 0xd4, 0xd2, 0x3a, 0xca, 0x78, 0x60, 0x52, 0xbe, 0x07, 0xf9, 0x14, 0xeb, 0xa5, 0xaa,
	0xb4, 0x8f, 0xa0, 0x38, 0xc4, 0x7a, 0x19, 0x63, 0xf3, 0xf7, 0x19, 0x78, 0xfd, 0x8c, 0xd6, 0x41,
	0xc6, 0x39, 0x2f, 0xb0, 0xf1, 0x29, 0xf6, 0x7c, 0x51, 0x88, 0xe8, 0x8a, 0xaf, 0xd0, 0xf5, 0x82,
	0x6a, 0x8c, 0xa1, 0x86, 0x70, 0x0d, 0x5d, 0xe5, 0x2b, 0x37, 0xdb, 0x4a, 0xe5, 0x9f, 0xc1, 0x9f,
	0x77, 0x95, 0xf0, 0xa4, 0x2d, 0x00, 0x56, 0xe9, 0x12, 0x8e, 0x45, 0x46, 0xaa, 0xe3, 0x16, 0xf1,
	0xe3, 0xda, 0xd4, 0x1a, 0x90, 0xa0, 0xf7, 0x60, 0xb1, 0x8b, 0x5f, 0xda, 0xbd, 0x20, 0x19, 0x57,
	0x55, 0x8a, 0x0b, 0x5d, 0xfc, 0xf2, 0x28, 0x41, 0xcd, 0xfb, 0x00, 0x2a, 0x32, 0x3d, 0x25, 0x1c,
	0x0f, 0xe2, 0xda, 0x4c, 0x2a, 0xae, 0x0d, 0xc5, 0xe0, 0xd9, 0x91, 0x18, 0x6c, 0xfe, 0x7b, 0x06,
	0xe6, 0x0f, 0x09, 0xe3, 0xa2, 0x61, 0x40, 0xdf, 0x85, 0x2c, 0x09, 0x4e, 0x8d, 0x8f, 0x47, 0xff,
	0xb1, 0x89, 0x15, 0x2a, 0xb5, 0xe0, 0x54, 0x9d, 0x99, 0xd0, 0x1b, 0x6e, 0x43, 0x9b, 0x57, 0x6d,
	0x43, 0x9f, 0x5d, 0xb6, 0x0d, 0x4d, 0x77, 0x98, 0xcf, 0xbf, 0xe1, 0x0e, 0xf3, 0xd3, 0xaf, 0xd5,
	0x61, 0x36, 0xc6, 0x3b, 0xcc, 0xcf, 0xe4, 0xde, 0xbe, 0x3b, 0x61, 0x6f, 0x2f, 0xd2, 0x52, 0xee,
	0x8d, 0xb6, 0x94, 0x3f, 0x19, 0xcd, 0x54, 0x03, 0xba, 0xf3, 0x7a, 0xc8, 0x1f, 0xc2, 0xf2, 0xc9,
	0x36, 0xb3, 0xa9, 0xbc, 0x3c, 0xb6, 0xe8, 0xb8, 0x22, 0xcf, 0x25, 0x17, 0xe8, 0xce, 0x96, 0x86,
	0x10, 0x61, 0x54, 0xbe, 0x0b, 0xf3, 0xf1, 0xcd, 0xb8, 0x94, 0xd3, 0xfe, 0x0f, 0xb4, 0x77, 0x3b,
	0xa5, 0x3f, 0x7e, 0xb9, 0x9a, 0xf9, 0xf3, 0x97, 0xab, 0x99, 0xbf, 0x7d, 0xb9, 0x9a, 0xf9, 0xf5,
	0x57, 0xab, 0xd7, 0x5a, 0xb3, 0xb2, 0x11, 0xd9, 0xfa, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x87,
	0xb4, 0x72, 0xbc, 0xf4, 0x1f, 0x00, 0x00,
}

func (m *IstioInstaller) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IstioInstaller) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Spec.Size()))
		n1, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Status != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Status.Size()))
		n2, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InstallerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstallerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DefaultNamespacePrefix) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.DefaultNamespacePrefix)))
		i += copy(dAtA[i:], m.DefaultNamespacePrefix)
	}
	if m.TrafficManagement != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.TrafficManagement.Size()))
		n3, err := m.TrafficManagement.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.PolicyTelemetry != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.PolicyTelemetry.Size()))
		n4, err := m.PolicyTelemetry.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Security != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Security.Size()))
		n5, err := m.Security.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.ConfigManagement != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ConfigManagement.Size()))
		n6, err := m.ConfigManagement.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.IngressGateway) > 0 {
		for _, msg := range m.IngressGateway {
			dAtA[i] = 0xf2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EgressGateway) > 0 {
		for _, msg := range m.EgressGateway {
			dAtA[i] = 0xfa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ExternalOperators) > 0 {
		for _, msg := range m.ExternalOperators {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.K8SDefaults != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.K8SDefaults.Size()))
		n7, err := m.K8SDefaults.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.CustomPackagePath) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.CustomPackagePath)))
		i += copy(dAtA[i:], m.CustomPackagePath)
	}
	if len(m.Hub) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Hub)))
		i += copy(dAtA[i:], m.Hub)
	}
	if len(m.Tag) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Tag)))
		i += copy(dAtA[i:], m.Tag)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TrafficManagementFeatureSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrafficManagementFeatureSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Enabled.Size()))
		n8, err := m.Enabled.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.ClusterDomain) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.ClusterDomain)))
		i += copy(dAtA[i:], m.ClusterDomain)
	}
	if m.Pilot != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Pilot.Size()))
		n9, err := m.Pilot.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Proxy != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Proxy.Size()))
		n10, err := m.Proxy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.SidecarInjector != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.SidecarInjector.Size()))
		n11, err := m.SidecarInjector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PolicyTelemetryFeatureSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyTelemetryFeatureSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PolicyCheckFailOpen != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.PolicyCheckFailOpen.Size()))
		n12, err := m.PolicyCheckFailOpen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.OutboundTrafficPolicyMode != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.OutboundTrafficPolicyMode))
	}
	if m.Policy != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Policy.Size()))
		n13, err := m.Policy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Telemetry != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Telemetry.Size()))
		n14, err := m.Telemetry.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SecurityFeatureSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityFeatureSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Enabled.Size()))
		n15, err := m.Enabled.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if m.ControlPlaneMtls != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ControlPlaneMtls.Size()))
		n16, err := m.ControlPlaneMtls.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.DataPlaneMtls != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.DataPlaneMtls.Size()))
		n17, err := m.DataPlaneMtls.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.TrustDomain) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.TrustDomain)))
		i += copy(dAtA[i:], m.TrustDomain)
	}
	if m.Citadel != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Citadel.Size()))
		n18, err := m.Citadel.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.CertManager != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.CertManager.Size()))
		n19, err := m.CertManager.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.NodeAgent != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.NodeAgent.Size()))
		n20, err := m.NodeAgent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConfigManagementFeatureSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigManagementFeatureSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Galley != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Galley.Size()))
		n21, err := m.Galley.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PilotComponentSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PilotComponentSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n22, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.Sidecar != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Sidecar.Size()))
		n23, err := m.Sidecar.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProxyComponentSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProxyComponentSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n24, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SidecarInjectorComponentSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SidecarInjectorComponentSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n25, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.EnableNamespacesByDefault != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.EnableNamespacesByDefault.Size()))
		n26, err := m.EnableNamespacesByDefault.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PolicyComponentSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyComponentSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n27, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TelemetryComponentSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TelemetryComponentSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n28, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CitadelComponentSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CitadelComponentSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n29, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.SelfSigned {
		dAtA[i] = 0x58
		i++
		if m.SelfSigned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CreateMeshPolicy {
		dAtA[i] = 0x60
		i++
		if m.CreateMeshPolicy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CertManagerComponentSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertManagerComponentSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n30, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NodeAgentComponentSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeAgentComponentSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n31, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GalleyComponentSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GalleyComponentSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n32, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommonComponentSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommonComponentSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Enabled.Size()))
		n33, err := m.Enabled.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if m.Debug != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Debug))
	}
	if m.K8S != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.K8S.Size()))
		n34, err := m.K8S.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommonComponentSpec_UpdateSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommonComponentSpec_UpdateSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Old) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Old)))
		i += copy(dAtA[i:], m.Old)
	}
	if len(m.New) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.New)))
		i += copy(dAtA[i:], m.New)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KubernetesResourcesSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesResourcesSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Resources != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Resources.Size()))
		n35, err := m.Resources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.ReadinessProbe != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ReadinessProbe.Size()))
		n36, err := m.ReadinessProbe.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.ReplicaCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ReplicaCount))
	}
	if m.HpaSpec != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.HpaSpec.Size()))
		n37, err := m.HpaSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.PodDisruptionBudget != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.PodDisruptionBudget.Size()))
		n38, err := m.PodDisruptionBudget.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if len(m.PodAnnotations) > 0 {
		for k, _ := range m.PodAnnotations {
			dAtA[i] = 0x32
			i++
			v := m.PodAnnotations[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.NodeSelector) > 0 {
		for k, _ := range m.NodeSelector {
			dAtA[i] = 0x3a
			i++
			v := m.NodeSelector[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.NodeAffinity != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.NodeAffinity.Size()))
		n39, err := m.NodeAffinity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if len(m.ImagePullPolicy) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.ImagePullPolicy)))
		i += copy(dAtA[i:], m.ImagePullPolicy)
	}
	if len(m.PriorityClassName) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.PriorityClassName)))
		i += copy(dAtA[i:], m.PriorityClassName)
	}
	if len(m.Overlays) > 0 {
		for _, msg := range m.Overlays {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KubernetesResourcesSpec_NodeAffinity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesResourcesSpec_NodeAffinity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ArchAmd64 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ArchAmd64))
	}
	if m.ArchS390X != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ArchS390X))
	}
	if m.ArchPpc64Le != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ArchPpc64Le))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *IngressGatewaySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngressGatewaySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Gateway != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Gateway.Size()))
		n40, err := m.Gateway.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.IngressType != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.IngressType))
	}
	if m.LoadBalancer != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.LoadBalancer.Size()))
		n41, err := m.LoadBalancer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.SdsEnabled != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.SdsEnabled.Size()))
		n42, err := m.SdsEnabled.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.ExternalTrafficPolicy != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ExternalTrafficPolicy))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EgressGatewaySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EgressGatewaySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Gateway != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Gateway.Size()))
		n43, err := m.Gateway.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LoadBalancingGatewayConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadBalancingGatewayConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Gateway != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Gateway.Size()))
		n44, err := m.Gateway.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.LoadBalancer != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.LoadBalancer.Size()))
		n45, err := m.LoadBalancer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GatewayConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GatewayConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Common != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Common.Size()))
		n46, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LoadBalancerConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadBalancerConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ClusterIP) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.ClusterIP)))
		i += copy(dAtA[i:], m.ClusterIP)
	}
	if len(m.ExternalIPs) > 0 {
		for _, s := range m.ExternalIPs {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.SessionAffinity) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.SessionAffinity)))
		i += copy(dAtA[i:], m.SessionAffinity)
	}
	if len(m.LoadBalancerIP) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.LoadBalancerIP)))
		i += copy(dAtA[i:], m.LoadBalancerIP)
	}
	if len(m.LoadBalancerSourceRanges) > 0 {
		for _, s := range m.LoadBalancerSourceRanges {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ExternalName) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.ExternalName)))
		i += copy(dAtA[i:], m.ExternalName)
	}
	if len(m.ExternalTrafficPolicy) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.ExternalTrafficPolicy)))
		i += copy(dAtA[i:], m.ExternalTrafficPolicy)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OperatorSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperatorSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ManifestPath) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.ManifestPath)))
		i += copy(dAtA[i:], m.ManifestPath)
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if m.Spec != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Spec.Size()))
		n47, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *K8SObjectOverlay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SObjectOverlay) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiVersion) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.ApiVersion)))
		i += copy(dAtA[i:], m.ApiVersion)
	}
	if len(m.Kind) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Patches) > 0 {
		for _, msg := range m.Patches {
			dAtA[i] = 0x22
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *K8SObjectOverlay_PathValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SObjectOverlay_PathValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InstallerStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstallerStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TrafficManagement != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.TrafficManagement.Size()))
		n48, err := m.TrafficManagement.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	if m.PolicyTelemetry != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.PolicyTelemetry.Size()))
		n49, err := m.PolicyTelemetry.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if m.Security != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Security.Size()))
		n50, err := m.Security.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.ConfigManagement != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ConfigManagement.Size()))
		n51, err := m.ConfigManagement.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if len(m.IngressGateway) > 0 {
		for _, msg := range m.IngressGateway {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EgressGateway) > 0 {
		for _, msg := range m.EgressGateway {
			dAtA[i] = 0x32
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InstallerStatus_VersionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstallerStatus_VersionStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Resources) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resources) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Limits) > 0 {
		for k, _ := range m.Limits {
			dAtA[i] = 0xa
			i++
			v := m.Limits[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Requests) > 0 {
		for k, _ := range m.Requests {
			dAtA[i] = 0x12
			i++
			v := m.Requests[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PodDisruptionBudgetSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodDisruptionBudgetSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MinAvailable != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.MinAvailable))
	}
	if m.Selector != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Selector.Size()))
		n52, err := m.Selector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if m.MaxUnavailable != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.MaxUnavailable))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ObjectMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TestKube) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestKube) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Env) > 0 {
		for k, _ := range m.Env {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x3
			i++
			v := m.Env[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Resources != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.Resources.Size()))
		n53, err := m.Resources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if m.ReadinessProbe != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.ReadinessProbe.Size()))
		n54, err := m.ReadinessProbe.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if m.HpaSpec != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.HpaSpec.Size()))
		n55, err := m.HpaSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	if m.PodDisruptionBudget != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x5
		i++
		i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(m.PodDisruptionBudget.Size()))
		n56, err := m.PodDisruptionBudget.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if len(m.PodAnnotations) > 0 {
		for k, _ := range m.PodAnnotations {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x5
			i++
			v := m.PodAnnotations[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.NodeSelector) > 0 {
		for k, _ := range m.NodeSelector {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x5
			i++
			v := m.NodeSelector[k]
			mapSize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.K8SObjectOverride) > 0 {
		for _, msg := range m.K8SObjectOverride {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintIstioinstallerTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintIstioinstallerTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *IstioInstaller) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InstallerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DefaultNamespacePrefix)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.TrafficManagement != nil {
		l = m.TrafficManagement.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.PolicyTelemetry != nil {
		l = m.PolicyTelemetry.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Security != nil {
		l = m.Security.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ConfigManagement != nil {
		l = m.ConfigManagement.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.IngressGateway) > 0 {
		for _, e := range m.IngressGateway {
			l = e.Size()
			n += 2 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if len(m.EgressGateway) > 0 {
		for _, e := range m.EgressGateway {
			l = e.Size()
			n += 2 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if len(m.ExternalOperators) > 0 {
		for _, e := range m.ExternalOperators {
			l = e.Size()
			n += 2 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if m.K8SDefaults != nil {
		l = m.K8SDefaults.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.CustomPackagePath)
	if l > 0 {
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.Hub)
	if l > 0 {
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TrafficManagementFeatureSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.ClusterDomain)
	if l > 0 {
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Pilot != nil {
		l = m.Pilot.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Proxy != nil {
		l = m.Proxy.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.SidecarInjector != nil {
		l = m.SidecarInjector.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PolicyTelemetryFeatureSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PolicyCheckFailOpen != nil {
		l = m.PolicyCheckFailOpen.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.OutboundTrafficPolicyMode != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.OutboundTrafficPolicyMode))
	}
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Telemetry != nil {
		l = m.Telemetry.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityFeatureSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ControlPlaneMtls != nil {
		l = m.ControlPlaneMtls.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.DataPlaneMtls != nil {
		l = m.DataPlaneMtls.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.TrustDomain)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Citadel != nil {
		l = m.Citadel.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.CertManager != nil {
		l = m.CertManager.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.NodeAgent != nil {
		l = m.NodeAgent.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigManagementFeatureSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Galley != nil {
		l = m.Galley.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PilotComponentSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Sidecar != nil {
		l = m.Sidecar.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProxyComponentSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SidecarInjectorComponentSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.EnableNamespacesByDefault != nil {
		l = m.EnableNamespacesByDefault.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PolicyComponentSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TelemetryComponentSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CitadelComponentSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.SelfSigned {
		n += 2
	}
	if m.CreateMeshPolicy {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CertManagerComponentSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeAgentComponentSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GalleyComponentSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommonComponentSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Debug != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.Debug))
	}
	if m.K8S != nil {
		l = m.K8S.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommonComponentSpec_UpdateSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Old)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.New)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KubernetesResourcesSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ReadinessProbe != nil {
		l = m.ReadinessProbe.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ReplicaCount != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.ReplicaCount))
	}
	if m.HpaSpec != nil {
		l = m.HpaSpec.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.PodDisruptionBudget != nil {
		l = m.PodDisruptionBudget.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.PodAnnotations) > 0 {
		for k, v := range m.PodAnnotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if len(m.NodeSelector) > 0 {
		for k, v := range m.NodeSelector {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if m.NodeAffinity != nil {
		l = m.NodeAffinity.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.ImagePullPolicy)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.PriorityClassName)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.Overlays) > 0 {
		for _, e := range m.Overlays {
			l = e.Size()
			n += 2 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KubernetesResourcesSpec_NodeAffinity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ArchAmd64 != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.ArchAmd64))
	}
	if m.ArchS390X != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.ArchS390X))
	}
	if m.ArchPpc64Le != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.ArchPpc64Le))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IngressGatewaySpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gateway != nil {
		l = m.Gateway.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.IngressType != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.IngressType))
	}
	if m.LoadBalancer != nil {
		l = m.LoadBalancer.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.SdsEnabled != nil {
		l = m.SdsEnabled.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ExternalTrafficPolicy != 0 {
		n += 2 + sovIstioinstallerTypes(uint64(m.ExternalTrafficPolicy))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EgressGatewaySpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gateway != nil {
		l = m.Gateway.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoadBalancingGatewayConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gateway != nil {
		l = m.Gateway.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.LoadBalancer != nil {
		l = m.LoadBalancer.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GatewayConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoadBalancerConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	l = len(m.ClusterIP)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.ExternalIPs) > 0 {
		for _, s := range m.ExternalIPs {
			l = len(s)
			n += 1 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	l = len(m.SessionAffinity)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.LoadBalancerIP)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.LoadBalancerSourceRanges) > 0 {
		for _, s := range m.LoadBalancerSourceRanges {
			l = len(s)
			n += 1 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	l = len(m.ExternalName)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.ExternalTrafficPolicy)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OperatorSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ManifestPath)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *K8SObjectOverlay) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ApiVersion)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.Patches) > 0 {
		for _, e := range m.Patches {
			l = e.Size()
			n += 1 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *K8SObjectOverlay_PathValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InstallerStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TrafficManagement != nil {
		l = m.TrafficManagement.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.PolicyTelemetry != nil {
		l = m.PolicyTelemetry.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Security != nil {
		l = m.Security.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ConfigManagement != nil {
		l = m.ConfigManagement.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.IngressGateway) > 0 {
		for _, e := range m.IngressGateway {
			l = e.Size()
			n += 1 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if len(m.EgressGateway) > 0 {
		for _, e := range m.EgressGateway {
			l = e.Size()
			n += 1 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InstallerStatus_VersionStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Resources) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Limits) > 0 {
		for k, v := range m.Limits {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Requests) > 0 {
		for k, v := range m.Requests {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PodDisruptionBudgetSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinAvailable != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.MinAvailable))
	}
	if m.Selector != nil {
		l = m.Selector.Size()
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.MaxUnavailable != 0 {
		n += 1 + sovIstioinstallerTypes(uint64(m.MaxUnavailable))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestKube) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Env) > 0 {
		for k, v := range m.Env {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.ReadinessProbe != nil {
		l = m.ReadinessProbe.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.HpaSpec != nil {
		l = m.HpaSpec.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if m.PodDisruptionBudget != nil {
		l = m.PodDisruptionBudget.Size()
		n += 2 + l + sovIstioinstallerTypes(uint64(l))
	}
	if len(m.PodAnnotations) > 0 {
		for k, v := range m.PodAnnotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if len(m.NodeSelector) > 0 {
		for k, v := range m.NodeSelector {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIstioinstallerTypes(uint64(len(k))) + 1 + len(v) + sovIstioinstallerTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovIstioinstallerTypes(uint64(mapEntrySize))
		}
	}
	if len(m.K8SObjectOverride) > 0 {
		for _, e := range m.K8SObjectOverride {
			l = e.Size()
			n += 2 + l + sovIstioinstallerTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovIstioinstallerTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozIstioinstallerTypes(x uint64) (n int) {
	return sovIstioinstallerTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *IstioInstaller) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IstioInstaller: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IstioInstaller: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &InstallerSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &InstallerStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstallerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstallerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstallerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultNamespacePrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultNamespacePrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficManagement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrafficManagement == nil {
				m.TrafficManagement = &TrafficManagementFeatureSpec{}
			}
			if err := m.TrafficManagement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyTelemetry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PolicyTelemetry == nil {
				m.PolicyTelemetry = &PolicyTelemetryFeatureSpec{}
			}
			if err := m.PolicyTelemetry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Security", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Security == nil {
				m.Security = &SecurityFeatureSpec{}
			}
			if err := m.Security.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigManagement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigManagement == nil {
				m.ConfigManagement = &ConfigManagementFeatureSpec{}
			}
			if err := m.ConfigManagement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngressGateway = append(m.IngressGateway, &IngressGatewaySpec{})
			if err := m.IngressGateway[len(m.IngressGateway)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgressGateway = append(m.EgressGateway, &EgressGatewaySpec{})
			if err := m.EgressGateway[len(m.EgressGateway)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalOperators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalOperators = append(m.ExternalOperators, &OperatorSpec{})
			if err := m.ExternalOperators[len(m.ExternalOperators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 80:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8SDefaults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.K8SDefaults == nil {
				m.K8SDefaults = &KubernetesResourcesSpec{}
			}
			if err := m.K8SDefaults.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomPackagePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomPackagePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hub", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hub = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrafficManagementFeatureSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrafficManagementFeatureSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrafficManagementFeatureSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &protobuf.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pilot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pilot == nil {
				m.Pilot = &PilotComponentSpec{}
			}
			if err := m.Pilot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proxy == nil {
				m.Proxy = &ProxyComponentSpec{}
			}
			if err := m.Proxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SidecarInjector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SidecarInjector == nil {
				m.SidecarInjector = &SidecarInjectorComponentSpec{}
			}
			if err := m.SidecarInjector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyTelemetryFeatureSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyTelemetryFeatureSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyTelemetryFeatureSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyCheckFailOpen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PolicyCheckFailOpen == nil {
				m.PolicyCheckFailOpen = &protobuf.BoolValue{}
			}
			if err := m.PolicyCheckFailOpen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutboundTrafficPolicyMode", wireType)
			}
			m.OutboundTrafficPolicyMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutboundTrafficPolicyMode |= PolicyTelemetryFeatureSpec_OutboundPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &PolicyComponentSpec{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Telemetry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Telemetry == nil {
				m.Telemetry = &TelemetryComponentSpec{}
			}
			if err := m.Telemetry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityFeatureSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityFeatureSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityFeatureSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &protobuf.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlPlaneMtls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ControlPlaneMtls == nil {
				m.ControlPlaneMtls = &protobuf.BoolValue{}
			}
			if err := m.ControlPlaneMtls.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataPlaneMtls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataPlaneMtls == nil {
				m.DataPlaneMtls = &protobuf.BoolValue{}
			}
			if err := m.DataPlaneMtls.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Citadel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Citadel == nil {
				m.Citadel = &CitadelComponentSpec{}
			}
			if err := m.Citadel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertManager", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CertManager == nil {
				m.CertManager = &CertManagerComponentSpec{}
			}
			if err := m.CertManager.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAgent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeAgent == nil {
				m.NodeAgent = &NodeAgentComponentSpec{}
			}
			if err := m.NodeAgent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigManagementFeatureSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigManagementFeatureSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigManagementFeatureSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Galley", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Galley == nil {
				m.Galley = &GalleyComponentSpec{}
			}
			if err := m.Galley.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PilotComponentSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PilotComponentSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PilotComponentSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentSpec{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sidecar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sidecar == nil {
				m.Sidecar = &protobuf.BoolValue{}
			}
			if err := m.Sidecar.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProxyComponentSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProxyComponentSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProxyComponentSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentSpec{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SidecarInjectorComponentSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SidecarInjectorComponentSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SidecarInjectorComponentSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentSpec{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableNamespacesByDefault", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnableNamespacesByDefault == nil {
				m.EnableNamespacesByDefault = &protobuf.BoolValue{}
			}
			if err := m.EnableNamespacesByDefault.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyComponentSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyComponentSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyComponentSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentSpec{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TelemetryComponentSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TelemetryComponentSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TelemetryComponentSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentSpec{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CitadelComponentSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CitadelComponentSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CitadelComponentSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentSpec{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfSigned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SelfSigned = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateMeshPolicy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateMeshPolicy = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertManagerComponentSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertManagerComponentSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertManagerComponentSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentSpec{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeAgentComponentSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeAgentComponentSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeAgentComponentSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentSpec{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GalleyComponentSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GalleyComponentSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GalleyComponentSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentSpec{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommonComponentSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommonComponentSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommonComponentSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &protobuf.BoolValue{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			m.Debug = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Debug |= CommonComponentSpec_LogLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 80:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8S", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.K8S == nil {
				m.K8S = &KubernetesResourcesSpec{}
			}
			if err := m.K8S.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommonComponentSpec_UpdateSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Old", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Old = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field New", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.New = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesResourcesSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubernetesResourcesSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubernetesResourcesSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &Resources{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadinessProbe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadinessProbe == nil {
				m.ReadinessProbe = &v1.Probe{}
			}
			if err := m.ReadinessProbe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaCount", wireType)
			}
			m.ReplicaCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HpaSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HpaSpec == nil {
				m.HpaSpec = &v11.HorizontalPodAutoscalerSpec{}
			}
			if err := m.HpaSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultPodDisruptionBudgetConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodDisruptionBudget == nil {
				m.PodDisruptionBudget = &PodDisruptionBudgetSpec{}
			}
			if err := m.PodDisruptionBudget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodAnnotations == nil {
				m.PodAnnotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PodAnnotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeSelector == nil {
				m.NodeSelector = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeSelector[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAffinity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeAffinity == nil {
				m.NodeAffinity = &KubernetesResourcesSpec_NodeAffinity{}
			}
			if err := m.NodeAffinity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePullPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImagePullPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriorityClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriorityClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Overlays", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Overlays = append(m.Overlays, &K8SObjectOverlay{})
			if err := m.Overlays[len(m.Overlays)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesResourcesSpec_NodeAffinity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeAffinity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeAffinity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArchAmd64", wireType)
			}
			m.ArchAmd64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArchAmd64 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArchS390X", wireType)
			}
			m.ArchS390X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArchS390X |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArchPpc64Le", wireType)
			}
			m.ArchPpc64Le = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArchPpc64Le |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngressGatewaySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngressGatewaySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngressGatewaySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gateway == nil {
				m.Gateway = &GatewayConfig{}
			}
			if err := m.Gateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressType", wireType)
			}
			m.IngressType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IngressType |= IngressGatewaySpec_IngressType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LoadBalancer == nil {
				m.LoadBalancer = &LoadBalancerConfig{}
			}
			if err := m.LoadBalancer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SdsEnabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SdsEnabled == nil {
				m.SdsEnabled = &protobuf.BoolValue{}
			}
			if err := m.SdsEnabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalTrafficPolicy", wireType)
			}
			m.ExternalTrafficPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalTrafficPolicy |= IngressGatewaySpec_ExternalTrafficPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EgressGatewaySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EgressGatewaySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EgressGatewaySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gateway == nil {
				m.Gateway = &GatewayConfig{}
			}
			if err := m.Gateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadBalancingGatewayConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadBalancingGatewayConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadBalancingGatewayConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gateway == nil {
				m.Gateway = &GatewayConfig{}
			}
			if err := m.Gateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LoadBalancer == nil {
				m.LoadBalancer = &LoadBalancerConfig{}
			}
			if err := m.LoadBalancer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GatewayConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GatewayConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GatewayConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &CommonComponentSpec{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadBalancerConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadBalancerConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadBalancerConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &v1.ServicePort{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalIPs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalIPs = append(m.ExternalIPs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionAffinity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionAffinity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancerIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadBalancerIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancerSourceRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadBalancerSourceRanges = append(m.LoadBalancerSourceRanges, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalTrafficPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalTrafficPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperatorSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperatorSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperatorSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManifestPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManifestPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &K8SObjectOverlay{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SObjectOverlay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: k8sObjectOverlay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: k8sObjectOverlay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Patches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Patches = append(m.Patches, &K8SObjectOverlay_PathValue{})
			if err := m.Patches[len(m.Patches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SObjectOverlay_PathValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstallerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstallerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstallerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficManagement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrafficManagement == nil {
				m.TrafficManagement = &InstallerStatus_VersionStatus{}
			}
			if err := m.TrafficManagement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyTelemetry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PolicyTelemetry == nil {
				m.PolicyTelemetry = &InstallerStatus_VersionStatus{}
			}
			if err := m.PolicyTelemetry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Security", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Security == nil {
				m.Security = &InstallerStatus_VersionStatus{}
			}
			if err := m.Security.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigManagement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigManagement == nil {
				m.ConfigManagement = &InstallerStatus_VersionStatus{}
			}
			if err := m.ConfigManagement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngressGateway = append(m.IngressGateway, &InstallerStatus_VersionStatus{})
			if err := m.IngressGateway[len(m.IngressGateway)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgressGateway = append(m.EgressGateway, &InstallerStatus_VersionStatus{})
			if err := m.EgressGateway[len(m.EgressGateway)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstallerStatus_VersionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= InstallerStatus_Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resources) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Resources: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Resources: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limits == nil {
				m.Limits = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Limits[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Requests == nil {
				m.Requests = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Requests[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodDisruptionBudgetSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodDisruptionBudgetSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodDisruptionBudgetSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAvailable", wireType)
			}
			m.MinAvailable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinAvailable |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Selector == nil {
				m.Selector = &v12.LabelSelector{}
			}
			if err := m.Selector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUnavailable", wireType)
			}
			m.MaxUnavailable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxUnavailable |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestKube) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestKube: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestKube: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Env == nil {
				m.Env = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Env[mapkey] = mapvalue
			iNdEx = postIndex
		case 80:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &Resources{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 81:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadinessProbe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadinessProbe == nil {
				m.ReadinessProbe = &v1.Probe{}
			}
			if err := m.ReadinessProbe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 86:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HpaSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HpaSpec == nil {
				m.HpaSpec = &v11.HorizontalPodAutoscalerSpec{}
			}
			if err := m.HpaSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 87:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultPodDisruptionBudgetConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodDisruptionBudget == nil {
				m.PodDisruptionBudget = &PodDisruptionBudgetSpec{}
			}
			if err := m.PodDisruptionBudget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 90:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodAnnotations == nil {
				m.PodAnnotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PodAnnotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 92:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeSelector == nil {
				m.NodeSelector = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIstioinstallerTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthIstioinstallerTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeSelector[mapkey] = mapvalue
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8SObjectOverride", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.K8SObjectOverride = append(m.K8SObjectOverride, &K8SObjectOverlay{})
			if err := m.K8SObjectOverride[len(m.K8SObjectOverride)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIstioinstallerTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIstioinstallerTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipIstioinstallerTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowIstioinstallerTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIstioinstallerTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthIstioinstallerTypes
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthIstioinstallerTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowIstioinstallerTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipIstioinstallerTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthIstioinstallerTypes
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthIstioinstallerTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowIstioinstallerTypes   = fmt.Errorf("proto: integer overflow")
)
