// TODO:
// - Add pod (anti)affinity for all components.
// - Debug level functionality (add to API, comment that itâ€™s binary for now)

syntax = "proto3";

package v1alpha1;

import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/api/autoscaling/v1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "github.com/gogo/protobuf/protobuf/google/protobuf/wrappers.proto";

// 	protobuf "github.com/gogo/protobuf/types"

message IstioInstaller {
    InstallerSpec spec = 3;
    InstallerStatus status = 4;
}

// InstallerSpec defines the desired state of IstioInstaller.
message InstallerSpec {
    // URL for the install package. e.g.
    //   http://github.com/istio/istio/releases/install/1.1.2
    //   http://github.com/istio/istio/releases/install/lts
    //   file://tmp/istio-installer/nightly
    // Uses compiled in install package by default.
    string install_package_path = 1;

    // Root for docker image paths e.g. docker.io/istio-release.
    // Releases are published to docker hub under 'istio' project.
    //  Daily builds from prow are on gcr.io, and nightly builds from circle on docker.io/istionightly
    string hub = 3;
    // Version tag for docker images e.g. 1.0.6
    string tag = 4;

    // Prefix added to all namespaces for any installed component.
    string default_namespace_prefix = 5;

    // Selection and configuration of core Istio features.
    TrafficManagementConfig traffic_management = 25;
    PolicyTelemetryConfig policy_telemetry = 26;
    SecurityConfig security = 28;
    ConfigManagementConfig config_management = 29;

    // Ingress/egress gateway installation and configuration.
    repeated IngressGatewayConfig ingress_gateway = 30;
    repeated EgressGatewayConfig egress_gateway = 31;

    // List of external operators that will be installed (but not managed)
    // by the IstioInstaller e.g. prometheus, grafana, kiali.
    repeated OperatorConfig external_operators = 50;

    // Global k8s defaults. Can be overridden per component.
    KubernetesResourcesConfig k8s_defaults = 80;
}

// Configuration options for traffic management.
message TrafficManagementConfig {
    // Selects whether traffic management is installed.
    // Must be enabled to enable any sub-component.
    google.protobuf.BoolValue enabled = 1;
    // Namespace that all traffic management components are installed into.
    string namespace = 2;

    string cluster_domain = 24;

    // Component specific config.
    PilotComponentConfig pilot = 30;
    ProxyComponentConfig proxy = 31;
    SidecarInjectorComponentConfig sidecar_injector = 32;
}

// Configuration options for the policy and telemetry feature.
message PolicyTelemetryConfig {
    // Default behavior of the sidecar for handling outbound traffic from the application.
    enum OutboundPolicy {
        // Outbound traffic to unknown destinations will be allowed, in case there are no
        // services or ServiceEntries for the destination port
        ALLOW_ANY = 0;
        // Restrict outbound traffic to services defined in the service registry as well
        // as those defined through ServiceEntries
        REGISTRY_ONLY = 1;
    }

    // If set, allows traffic in cases when the mixer policy service cannot be reached.
    google.protobuf.BoolValue policy_check_fail_open = 10;
    // Selects the outbound traffic policy mode.
    OutboundPolicy outbound_traffic_policy_mode = 11;

    PolicyComponentConfig policy = 50;
    TelemetryComponentConfig telemetry = 51;
}

// Configuration options for security feature.
message SecurityConfig {
    // Selects whether security feature is installed. Must be set for any sub-component to be installed.
    google.protobuf.BoolValue enabled = 1;

    // Namespace that security components are installed into.
    string namespace = 2;

    // Enables MTLS for control plane.
    // Will result in delays starting the pods while secrets are propagated, not recommended for tests.
    google.protobuf.BoolValue control_plane_mtls = 13;

    // Enables MTLS for service to service traffic.
    google.protobuf.BoolValue data_plane_mtls = 14;

    string trust_domain = 15;

    google.protobuf.BoolValue self_signed = 16;
    google.protobuf.BoolValue create_mesh_policy = 17;

    CitadelComponentConfig citadel = 20;
    CertManagerComponentConfig cert_manager = 21;
    NodeAgentComponentConfig node_agent = 22;
}

// Configuration options for the pilot component.
message PilotComponentConfig {
    CommonComponentConfig common = 1;

    // Enables sidecar in the pilot pod.
    google.protobuf.BoolValue sidecar = 10;
}

// Configuration options for the proxy.
message ProxyComponentConfig {
    CommonComponentConfig common = 1;
}

// Configuration options for the sidecar injector component.
message SidecarInjectorComponentConfig {
    CommonComponentConfig common = 1;

    // Selects whether auto-injection is enabled in namespaces by default.
    google.protobuf.BoolValue enable_namespaces_by_default = 10;
}

// Configuration options for the policy enforcement component.
message PolicyComponentConfig {
    CommonComponentConfig common = 1;
}

// Configuration options for the telemetry component.
message TelemetryComponentConfig {
    CommonComponentConfig common = 1;
}

// Configuration options for Citadel component.
message CitadelComponentConfig {
    CommonComponentConfig common = 1;
}

// Configuration options for certificate manager component.
message CertManagerComponentConfig {
    CommonComponentConfig common = 1;
}

// Configuration options for node agent component.
message NodeAgentComponentConfig {
    CommonComponentConfig common = 1;
}

// Configuration options for configuration management feature.
message ConfigManagementConfig {
    CommonComponentConfig common = 1;
}

// Configuration common to all components.
message CommonComponentConfig {
    // Selects whether policy enforcement is installed.
    // Q. is this enough to cover both mixer.policy.enabled and disablePolicyChecks?
    google.protobuf.BoolValue enabled = 1;
    // Namespace that all resources for this feature are installed into.
    string namespace = 2;
    // LogLevel sets the component log level. Mappings to underlying log levels are not necessarily 1:1 and depend on
    // component support of these levels e.g. DEBUG or INFO may result in the same log verbosity.
    enum LogLevel {
        NONE = 0;
        ERROR = 1;
        WARN = 2;
        DEBUG = 3;
        INFO = 4;
    }
    LogLevel debug = 3;

    message UpdateSpec {
        string old = 1;
        string new = 2;
    }
    // Additional environment variables for the container.
    map<string, UpdateSpec> env = 60;
    // Additional command line arguments for the container.
    map<string, UpdateSpec> args = 61;

    // Kubernetes resource spec.
    KubernetesResourcesConfig k8s = 80;

    // Kustomize style overrides for default values.yaml.
    // google.protobuf.Struct values_overrides = 100;
    // ValuesOverrides map[string]interface{} `protobuf:"bytes,6,opt,name=data" json:"valuesOverrides,omitempty"`
}

// KubernetesResourcesConfig is a common set of k8s resource configs for components.
message KubernetesResourcesConfig {
    // k8s resources settings.
    // https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#resource-requests-and-limits-of-pod-and-container
    Resources resources = 1;
    // k8s readinessProbe settings.
    // https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/
    k8s.io.api.core.v1.Probe readiness_probe = 2;
    // k8s Deployment replicas setting.
    // https://kubernetes.io/docs/concepts/workloads/controllers/deployment/
    uint32 replica_count = 3;
    // k8s HorizontalPodAutoscaler settings.
    // https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/
    k8s.io.api.autoscaling.v1.HorizontalPodAutoscalerSpec hpa_spec = 4;
    // k8s PodDisruptionBudget settings.
    // https://kubernetes.io/docs/concepts/workloads/pods/disruptions/#how-disruption-budgets-work
    PodDisruptionBudgetSpec pod_disruption_budget = 5;
    // k8s pod annotations.
    // https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
    map<string, string> pod_annotations = 6;
    // k8s nodeSelector.
    // https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
    map<string, string> node_selector = 7;
    // k8s ImagePullPolicy setting for all containers.
    // https://kubernetes.io/docs/concepts/containers/images/#updating-images

    // k8s node affinity.
    // https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
    message NodeAffinity {
        uint32 arch_amd64 = 1;
        uint32 arch_s390x = 2;
        uint32 arch_ppc64le = 3;
    }
    NodeAffinity node_affinity = 8;
    // k8s imagePullPolicy.
    // https://kubernetes.io/docs/concepts/containers/images/
    string image_pull_policy = 9;
    // k8s priority_class_name. Default for all resources unless overridden.
    // https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass
    string priority_class_name = 10;

    // Kustomize style overrides for k8s resources in rendered manifests.
    repeated k8sObjectOverlay overlays = 100;
}

// Configuration options for ingress gateways.
message IngressGatewayConfig {
    // Common gateway configuration.
    GatewayConfig gateway = 10;
    // Selects the type of ingress.
    // Ingress type.
    enum IngressType {
        ISTIO = 0;
        KUBERNETES = 1;
    }
    IngressType ingress_type = 11;

    // enableHttps will add port 443 on the ingress.
    // It REQUIRES that the certificates are installed  in the
    // expected secrets - enabling this option without certificates
    // will result in LDS rejection and the ingress will not work.
    google.protobuf.BoolValue https_enabled = 12;

    LoadBalancerConfig load_balancer = 13;

    // If true, ingress gateway fetches credentials from SDS server to handle TLS connections.
    google.protobuf.BoolValue sds_enabled = 16;

    // change to Local to preserve source IP or Cluster for default behaviour or leave commented out
    // ???
    // External traffic policy.
    enum ExternalTrafficPolicy {
        NONE = 0;
        // Preserves source IP.
        LOCAL = 1;
        CLUSTER = 2;
    }
    ExternalTrafficPolicy externalTrafficPolicy = 17;
}

// Configuration options for egress gateways.
message EgressGatewayConfig {
    // Common gateway configuration.
    GatewayConfig gateway = 10;
}

// Configuration options for internal load balancer gateways.
message LoadBalancingGatewayConfig {
    // Common gateway configuration.
    GatewayConfig gateway = 10;

    // Load balancer config.
    LoadBalancerConfig load_balancer = 11;
}

// Common config for all gateway types.
message GatewayConfig {
    CommonComponentConfig common = 1;

    // NodePort, ClusterIP or LoadBalancer.
    string type = 10;
}

// Configuration options for internal load balancer gateways.
// Subset of k8s.io/api/core/v1 ServiceSpec.
message LoadBalancerConfig {
    // The list of ports that are exposed by this service.
    // More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
    repeated k8s.io.api.core.v1.ServicePort ports = 1;

    // clusterIP is the IP address of the service and is usually assigned
    // randomly by the master. If an address is specified manually and is not in
    // use by others, it will be allocated to the service; otherwise, creation
    // of the service will fail. This field can not be changed through updates.
    // Valid values are "None", empty string (""), or a valid IP address. "None"
    // can be specified for headless services when proxying is not required.
    // Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if
    // type is ExternalName.
    // More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
    // +optional
    string clusterIP = 3;

    // externalIPs is a list of IP addresses for which nodes in the cluster
    // will also accept traffic for this service.  These IPs are not managed by
    // Kubernetes.  The user is responsible for ensuring that traffic arrives
    // at a node with this IP.  A common example is external load-balancers
    // that are not part of the Kubernetes system.
    // +optional
    repeated string externalIPs = 5;

    // Supports "ClientIP" and "None". Used to maintain session affinity.
    // Enable client IP based session affinity.
    // Must be ClientIP or None.
    // Defaults to None.
    // More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
    // +optional
    string sessionAffinity = 7;

    // LoadBalancer will get created with the IP specified in this field.
    // This feature depends on whether the underlying cloud-provider supports specifying
    // the loadBalancerIP when a load balancer is created.
    // This field will be ignored if the cloud-provider does not support the feature.
    // +optional
    string loadBalancerIP = 8;

    // If specified and supported by the platform, this will restrict traffic through the cloud-provider
    // load-balancer will be restricted to the specified client IPs. This field will be ignored if the
    // cloud-provider does not support the feature."
    // More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/
    // +optional
    repeated string loadBalancerSourceRanges = 9;

    // externalName is the external reference that kubedns or equivalent will
    // return as a CNAME record for this service. No proxying will be involved.
    // Must be a valid RFC-1123 hostname (https://tools.ietf.org/html/rfc1123)
    // and requires Type to be ExternalName.
    // +optional
    string externalName = 10;

    // externalTrafficPolicy denotes if this Service desires to route external
    // traffic to node-local or cluster-wide endpoints. "Local" preserves the
    // client source IP and avoids a second hop for LoadBalancer and Nodeport
    // type services, but risks potentially imbalanced traffic spreading.
    // "Cluster" obscures the client source IP and may cause a second hop to
    // another node, but should have good overall load-spreading.
    // +optional
    string externalTrafficPolicy = 11;
}

// OperatorConfig defines a config used to install an external operator.
message OperatorConfig {
    // manifest_path is the URL for the operator install manifest.
    string manifest_path = 1;

    // namespace is the namespace the operator manifest and CR are installed into.
    string namespace = 2;

    // spec is the initial CR for the operator.
    k8sObjectOverlay spec = 100;
}

// Patch for an existing k8s resource.
message k8sObjectOverlay {
    enum PatchType {
        STRATEGIC = 0;
        JSON = 1;
    }
    enum Op {
        ADD = 0;
        REMOVE = 1;
        REPLACE = 2;
    }

    PatchType patch_type = 1;
    Op op = 2;
    // google.protobuf.Struct Data = 6;
    //    	Data                 *unstructured.Unstructured  `protobuf:"bytes,6,opt,name=data" json:"data,omitempty"`
}

// Observed state of IstioInstaller.
message InstallerStatus {
    enum Status {
        NONE = 0;
        UPDATING = 1;
        HEALTHY = 2;
        ERROR = 3;
    }
    message VersionStatus {
        string version = 1;
        Status status = 2;
    }

    VersionStatus traffic_management = 1;
    VersionStatus policy_telemetry = 2;
    VersionStatus security = 3;
    VersionStatus config_management = 4;

    repeated VersionStatus ingress_gateway = 5;
    repeated VersionStatus egress_gateway = 6;
}

// Mirrors k8s.io.api.core.v1.ResourceRequirements for unmarshaling.
message Resources {
    map<string, string> limits = 1;
    map<string, string> requests = 2;
}

// Mirrors k8s.io.api.policy.v1beta1.PodDisruptionBudget for unmarshaling.
message PodDisruptionBudgetSpec {
    uint32 min_available = 1;
    k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2;
    uint32 max_unavailable = 3;
}

message ObjectMeta {
    // From k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta
    string name = 5;
    string namespace = 6;
}

// TESTING ONLY
message TestKube {
    map<string, string> env = 60;

    Resources resources = 80;
    k8s.io.api.core.v1.Probe readiness_probe = 81;
    k8s.io.api.autoscaling.v1.HorizontalPodAutoscalerSpec hpa_spec = 86;
    PodDisruptionBudgetSpec pod_disruption_budget = 87;

    map<string, string> pod_annotations = 90;
    map<string, string> node_selector = 92;

    // Kustomize style overrides for k8s resources in rendered manifests.
    repeated k8sObjectOverlay k8s_object_override = 100;
}